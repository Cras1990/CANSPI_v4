
CANSPI_v4.elf:     file format elf32-littlearm
CANSPI_v4.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000189

Program Header:
    LOAD off    0x00010000 vaddr 0x08000000 paddr 0x08000000 align 2**16
         filesz 0x0000725d memsz 0x0000725d flags rwx
    LOAD off    0x00020000 vaddr 0x20000000 paddr 0x08007260 align 2**16
         filesz 0x00000144 memsz 0x00000144 flags rw-
    LOAD off    0x00020144 vaddr 0x20000144 paddr 0x20000144 align 2**16
         filesz 0x00000000 memsz 0x00001e4c flags rw-
private flags = 5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .isr_vector   00000330  08000000  08000000  00010000  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .inits        00000028  08000330  08000330  00010330  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data         00000144  20000000  08007260  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  3 .data_CCMRAM  00000000  10000000  10000000  00020144  2**2  CONTENTS
  4 .bss          00001d4c  20000144  20000144  00020144  2**2  ALLOC
  5 .text         00006efd  08000360  08000360  00010360  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .noinit       00000000  20001e90  20001e90  00020144  2**2  CONTENTS
  7 ._check_stack 00000100  20001e90  20001e90  00020144  2**2  ALLOC
  8 .comment      0000005d  00000000  00000000  00020144  2**0  CONTENTS, READONLY
  9 .ARM.attributes 00000031  00000000  00000000  000201a1  2**0  CONTENTS, READONLY
 10 .debug_aranges 00001548  00000000  00000000  000201d8  2**3  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00020745  00000000  00000000  00021720  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00004cbe  00000000  00000000  00041e65  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00013434  00000000  00000000  00046b23  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003848  00000000  00000000  00059f58  2**2  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00081771  00000000  00000000  0005d7a0  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000ed33  00000000  00000000  000def11  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000012f8  00000000  00000000  000edc44  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_macro  00018a23  00000000  00000000  000eef3c  2**0  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
08000000 l    d  .isr_vector	00000000 .isr_vector
08000330 l    d  .inits	00000000 .inits
20000000 l    d  .data	00000000 .data
10000000 l    d  .data_CCMRAM	00000000 .data_CCMRAM
20000144 l    d  .bss	00000000 .bss
08000360 l    d  .text	00000000 .text
20001e90 l    d  .noinit	00000000 .noinit
20001e90 l    d  ._check_stack	00000000 ._check_stack
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    df *ABS*	00000000 vectors_stm32f407xx.c
00000000 l    df *ABS*	00000000 _startup.c
20000144 l     O .bss	00000004 __bss_begin_guard
20000140 l     O .data	00000004 __data_end_guard
20001e8c l     O .bss	00000004 __bss_end_guard
20000000 l     O .data	00000004 __data_begin_guard
00000000 l    df *ABS*	00000000 exception_handlers.c
00000000 l    df *ABS*	00000000 _syscalls.c
2000014c l     O .bss	00000001 name.4237
20000004 l     O .data	00000008 argv.4238
00000000 l    df *ABS*	00000000 system_stm32f4xx.c
00000000 l    df *ABS*	00000000 led_button.c
20001a28 l     O .bss	00000001 button
00000000 l    df *ABS*	00000000 diskio.c
00000000 l    df *ABS*	00000000 fatfs_sd.c
08002fd4 l     F .text	00000034 TM_SPI_Send
08003008 l     F .text	00000004 SDCARD_IsDetected
0800300c l     F .text	00000004 SDCARD_IsWriteEnabled
08003010 l     F .text	00000028 init_spi
08003038 l     F .text	00000014 rcvr_spi_multi
0800304c l     F .text	00000014 xmit_spi_multi
08003060 l     F .text	00000064 wait_ready
080030c4 l     F .text	00000050 deselect
08003114 l     F .text	00000068 select
0800317c l     F .text	00000134 xmit_datablock
080032b0 l     F .text	000000e8 rcvr_datablock
08003398 l     F .text	00000248 send_cmd
20001a34 l     O .bss	00000001 TM_FATFS_SD_CardType
200000d8 l     O .data	00000001 TM_FATFS_SD_Stat
00000000 l    df *ABS*	00000000 impure.c
200000dc l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 stm32f4xx_hal.c
00000000 l    df *ABS*	00000000 stm32f4xx_hal_can.c
08000934 l     F .text	00000068 CAN_Transmit_IT
0800099c l     F .text	0000015c CAN_Receive_IT
00000000 l    df *ABS*	00000000 stm32f4xx_hal_cortex.c
00000000 l    df *ABS*	00000000 stm32f4xx_hal_gpio.c
00000000 l    df *ABS*	00000000 stm32f4xx_hal_rcc.c
00000000 l    df *ABS*	00000000 stm32f4xx_hal_spi.c
00000000 l    df *ABS*	00000000 stm32f4xx_hal_tim.c
00000000 l    df *ABS*	00000000 stm32f4xx_hal_tim_ex.c
00000000 l    df *ABS*	00000000 _exit.c
00000000 l    df *ABS*	00000000 _sbrk.c
20000148 l     O .bss	00000004 current_heap_end.3921
00000000 l    df *ABS*	00000000 assert.c
00000000 l    df *ABS*	00000000 _initialize_hardware.c
00000000 l    df *ABS*	00000000 _reset_hardware.c
00000000 l    df *ABS*	00000000 PtCan_Can.c
2000014e l     O .bss	00000002 vehicle_speed
20000150 l     O .bss	00000002 left_wheel_speed
20000152 l     O .bss	00000002 trq_eng_in3
20000154 l     O .bss	00000024 RxMessage
20000178 l     O .bss	00000002 trq_eng_in1
00000000 l    df *ABS*	00000000 PtCan_ErrHandling.c
00000000 l    df *ABS*	00000000 PtCan_SdStorage.c
080024c0 l     F .text	00000018 PtCan_SdStorage_openFile
080024d8 l     F .text	00000014 PtCan_SdStorage_closeFile
080024ec l     F .text	00000084 PtCan_SdStorage_sendData
2000017c l     O .bss	00001000 arr2SD
2000117c l     O .bss	00000001 save_files
20001180 l     O .bss	00000228 fil_torque1
200013a8 l     O .bss	00000228 fil_torque3
200015d0 l     O .bss	00000228 fil_gesch_wheel
200017f8 l     O .bss	00000228 fil_gesch_car
20001a20 l     O .bss	00000001 cantrans_sdstor_init
00000000 l    df *ABS*	00000000 PtCan_Tim.c
20001a24 l     O .bss	00000004 counter
00000000 l    df *ABS*	00000000 main.c
08002b30 l     F .text	000000a4 SystemClock_Config
08002bd4 l     F .text	0000003c main_StartStorage
08002c10 l     F .text	00000026 main_StopStorage
08002c68 l     F .text	00000044 main_InitMcu
20001a29 l     O .bss	00000001 program_start
00000000 l    df *ABS*	00000000 stm32f4xx_hal_msp.c
20001a2c l     O .bss	00000004 CAN2_CLK_ENABLED
20001a30 l     O .bss	00000004 CAN1_CLK_ENABLED
00000000 l    df *ABS*	00000000 stm32f4xx_it.c
00000000 l    df *ABS*	00000000 ff.c
08003c00 l     F .text	00000014 mem_cpy
08003c14 l     F .text	00000010 mem_set
08003c24 l     F .text	00000022 mem_cmp
08003c48 l     F .text	00000012 chk_chr
08003c5c l     F .text	00000084 chk_lock
08003ce0 l     F .text	00000024 enq_lock
08003d04 l     F .text	000000c4 inc_lock
08003dc8 l     F .text	00000048 dec_lock
08003e10 l     F .text	00000030 clear_lock
08003e40 l     F .text	0000001e ld_clust
08003e60 l     F .text	00000012 st_clust
08003e74 l     F .text	00000060 fit_lfn
08003ed4 l     F .text	000000a0 gen_numname
08003f74 l     F .text	0000001c sum_sfn
08003f90 l     F .text	000000b4 get_ldnumber
08004044 l     F .text	00000054 sync_window
08004098 l     F .text	00000034 move_window
080040cc l     F .text	00000090 check_fs
0800415c l     F .text	00000038 validate
08004194 l     F .text	0000037e find_volume
08004514 l     F .text	00000280 create_name
08004794 l     F .text	000000ac cmp_lfn
08004840 l     F .text	000000bc sync_fs
08004a00 l     F .text	00000094 dir_sdi
08004bbc l     F .text	000000b8 create_chain
08004c74 l     F .text	0000011e dir_next
08004d94 l     F .text	000000e2 dir_find
08004e78 l     F .text	000000a4 follow_path
08004f1c l     F .text	0000004a dir_alloc
08004f68 l     F .text	0000012c dir_register
08005094 l     F .text	00000068 remove_chain
20001a35 l     O .bss	00000001 CurrVol
0800681c l     O .text	00000080 ExCvt
0800693c l     O .text	0000000d LfnOfs
20001a38 l     O .bss	00000078 Files
20001ab0 l     O .bss	00000002 Fsid
20001ab4 l     O .bss	00000024 FatFs
0800694c l     O .text	00000024 str.4426
00000000 l    df *ABS*	00000000 syscall.c
00000000 l    df *ABS*	00000000 tm_stm32_delay.c
20001ad8 l     O .bss	00000018 CustomTimers
00000000 l    df *ABS*	00000000 tm_stm32_gpio.c
20001af8 l     O .bss	0000001a GPIO_UsedPins
00000000 l    df *ABS*	00000000 tm_stm32_spi.c
08005b80 l     F .text	000000fc TM_SPIx_Init
00000000 l    df *ABS*	00000000 unicode.c
08006970 l     O .text	000003dc lower.3901
08006d4c l     O .text	00000100 Tbl
08006e4c l     O .text	000003dc upper.3902
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 nano-vfprintf.c
00000000 l    df *ABS*	00000000 nano-vfprintf_i.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcpy-stub.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 
08000358 l       .inits	00000000 __fini_array_end
20001e90 l       .noinit	00000000 _end_noinit
08000358 l       .inits	00000000 __fini_array_start
08000358 l       .inits	00000000 __init_array_end
08000358 l       .inits	00000000 __preinit_array_end
08000358 l       .inits	00000000 __init_array_start
08000358 l       .inits	00000000 __preinit_array_start
0800032c  w    F .isr_vector	00000002 RTC_Alarm_IRQHandler
08006648 g     F .text	00000014 _malloc_usable_size_r
0800032c  w    F .isr_vector	00000002 HASH_RNG_IRQHandler
080066f0 g     O .text	00000010 APBAHBPrescTable
0800032c  w    F .isr_vector	00000002 EXTI2_IRQHandler
0800032c  w    F .isr_vector	00000002 TIM8_CC_IRQHandler
08002ecc  w    F .text	00000004 TM_FATFS_SDRAM_disk_initialize
080035e0 g     F .text	00000020 TM_FATFS_InitPins
08004914 g     F .text	000000ea get_fat
08000310  w    F .isr_vector	00000002 DebugMon_Handler
08002c38 g     F .text	00000030 MX_GPIO_Init
20001af4 g     O .bss	00000004 TM_Time2
20000000 g       .data	00000000 __data_start__
2001fc00 g       *ABS*	00000000 _Heap_Limit
08000358 g       .inits	00000000 __bss_regions_array_end
0800032c  w    F .isr_vector	00000002 TIM1_CC_IRQHandler
08000cc4 g     F .text	00000084 HAL_NVIC_SetPriority
08002868 g     F .text	00000024 MX_TIM2_Init
0800032c  w    F .isr_vector	00000002 DMA2_Stream5_IRQHandler
080002c0  w    F .isr_vector	00000014 HardFault_Handler
08002438 g     F .text	00000014 PtCan_Can1Sleep
08002178  w    F .text	00000018 __initialize_hardware_early
08000000 g       *ABS*	00000000 __vectors_start__
0800032c  w    F .isr_vector	00000002 DMA1_Stream5_IRQHandler
080059e8 g     F .text	00000040 TM_SPI_ReadMulti
08002e64 g     F .text	0000000c SysTick_Handler
0800116c g     F .text	00000034 HAL_GPIO_WritePin
0800032c  w    F .isr_vector	00000002 PVD_IRQHandler
0800032c  w    F .isr_vector	00000002 SDIO_IRQHandler
080065c6 g     F .text	00000036 memmove
0800032c  w    F .isr_vector	00000002 TAMP_STAMP_IRQHandler
08001d88 g     F .text	00000172 HAL_TIM_IRQHandler
20000024 g     O .data	000000b4 FATFS_LowLevelDrivers
08007260 g       *ABS*	00000000 _sidata
08001a88 g     F .text	00000034 HAL_RCC_GetHCLKFreq
08005724 g     F .text	0000003c TM_DELAY_Init
08000314  w    F .isr_vector	00000002 PendSV_Handler
080002bc  w    F .isr_vector	00000002 NMI_Handler
08000d48 g     F .text	0000002c HAL_NVIC_EnableIRQ
08007260 g       .data	00000000 __exidx_end
0800032c  w    F .isr_vector	00000002 CAN2_RX1_IRQHandler
0800032c  w    F .isr_vector	00000002 EXTI3_IRQHandler
080019e8  w    F .text	000000a0 HAL_RCC_GetSysClockFreq
08002a48 g     F .text	00000020 BSP_LED_Off
08005d6c g     F .text	0000000c __errno
08007260 g       .data	00000000 __etext
20001e90 g       .noinit	00000000 _Heap_Begin
0800032c  w    F .isr_vector	00000002 TIM8_TRG_COM_TIM14_IRQHandler
08002170  w    F .text	00000006 assert_failed
080011c0 g     F .text	00000018 HAL_GPIO_EXTI_IRQHandler
08002ce0 g     F .text	00000016 HAL_MspInit
08002f08  w    F .text	00000004 TM_FATFS_USBHS_disk_write
0800032c  w    F .isr_vector	00000002 TIM1_UP_TIM10_IRQHandler
08000e34  w    F .text	00000002 HAL_SYSTICK_Callback
080011a0 g     F .text	00000020 HAL_GPIO_TogglePin
20001b1c g     O .bss	00000004 errno
08007260 g       .data	00000000 _etext
20000144 g       .bss	00000000 _sbss
08005760  w    F .text	00000002 TM_DELAY_1msHandler
2001fc00 g       *ABS*	00000000 __Main_Stack_Limit
0800032c  w    F .isr_vector	00000002 TIM8_UP_TIM13_IRQHandler
08005d1c g     F .text	00000050 ff_wtoupper
0800032c  w    F .isr_vector	00000002 I2C3_ER_IRQHandler
08005c7c g     F .text	00000064 TM_SPI_Init
08000e40 g     F .text	0000032c HAL_GPIO_Init
20000020 g     O .data	00000004 BUTTON_PORT
08002ec4  w    F .text	00000004 TM_FATFS_USBFS_disk_initialize
0800229c g     F .text	00000088 MX_CAN1_Init
080065b0 g     F .text	00000016 memcpy
08002104  w    F .text	00000002 HAL_TIMEx_CommutationCallback
08005fe8 g     F .text	000001e8 _svfprintf_r
08002a68 g     F .text	0000007c BSP_PB_Init
08002e90 g     F .text	0000000a EXTI0_IRQHandler
0800032c  w    F .isr_vector	00000002 I2C2_EV_IRQHandler
08002f14 g     F .text	0000001c disk_initialize
20001e90 g       .noinit	00000000 _noinit
0800032c  w    F .isr_vector	00000002 DMA1_Stream2_IRQHandler
08002e70 g     F .text	00000010 CAN1_RX0_IRQHandler
0800032c  w    F .isr_vector	00000002 FPU_IRQHandler
080057f4 g     F .text	00000034 HAL_Delay
2000000c g     O .data	00000004 SystemCoreClock
0800032c  w    F .isr_vector	00000002 OTG_HS_WKUP_IRQHandler
08005d78 g     F .text	00000010 malloc
08000dcc g     F .text	00000030 HAL_NVIC_ClearPendingIRQ
08002ec8  w    F .text	00000004 TM_FATFS_USBHS_disk_initialize
080002f4  w    F .isr_vector	00000014 UsageFault_Handler
08002edc  w    F .text	00000004 TM_FATFS_SDRAM_disk_status
08002600 g     F .text	0000019c PtCan_SdStorage_storeRAM
0800032c  w    F .isr_vector	00000002 CAN2_SCE_IRQHandler
0800032c  w    F .isr_vector	00000002 DMA2_Stream2_IRQHandler
0800590c g     F .text	00000030 TM_GPIO_Init
08002f30 g     F .text	0000001c disk_status
20000144 g       .bss	00000000 __bss_start__
08006814 g     O .text	00000008 GPIO_PIN
20000000 g       .data	00000000 _sdata
0800032c  w    F .isr_vector	00000002 SPI1_IRQHandler
08005ecc g     F .text	00000020 _sbrk_r
080003bc g     F .text	00000170 HAL_CAN_ConfigFilter
08000798 g     F .text	000000ac HAL_CAN_Receive_IT
08001d78  w    F .text	00000002 HAL_TIM_OC_DelayElapsedCallback
0800288c g     F .text	00000028 MX_TIM3_Init
0800032c  w    F .isr_vector	00000002 TIM6_DAC_IRQHandler
08002fac g     F .text	00000020 disk_ioctl
0800032c  w    F .isr_vector	00000002 TIM1_BRK_TIM9_IRQHandler
0800032c  w    F .isr_vector	00000002 DCMI_IRQHandler
08002f10  w    F .text	00000004 TM_FATFS_SPI_FLASH_disk_write
0800032c  w    F .isr_vector	00000002 CAN2_RX0_IRQHandler
08000da0 g     F .text	0000002c HAL_SYSTICK_Config
08007260 g       .data	00000000 __exidx_start
08002ef8  w    F .text	00000004 TM_FATFS_USBHS_disk_read
0800032c  w    F .isr_vector	00000002 DMA2_Stream3_IRQHandler
080065fc g     F .text	0000004c _realloc_r
00000400 g       *ABS*	00000000 __Main_Stack_Size
08002420 g     F .text	00000018 PtCan_Can1ActivReceiveIT
080002d4  w    F .isr_vector	00000002 HardFault_Handler_C
08002114  w    F .text	00000008 abort
08002cf8 g     F .text	00000100 HAL_CAN_MspInit
0800211c g     F .text	00000044 _sbrk
080028b4 g     F .text	0000004c PtCan_Tim_SetState
08002f0c  w    F .text	00000004 TM_FATFS_SDRAM_disk_write
08001ac0 g     F .text	0000016c HAL_SPI_Init
0800032c  w    F .isr_vector	00000002 USART6_IRQHandler
08002160  w    F .text	00000010 __initialize_args
20001e14 g     O .bss	0000003c htim3
080002f0  w    F .isr_vector	00000002 BusFault_Handler_C
080059a4 g     F .text	00000044 TM_SPI_WriteMulti
08002460 g     F .text	00000020 Error_Handler_CANR
08001abc  w    F .text	00000002 HAL_SPI_MspInit
08002afc g     F .text	0000000c get_button_state
0800032c  w    F .isr_vector	00000002 USART3_IRQHandler
20001e90 g       .bss	00000000 _ebss
0800593c g     F .text	00000068 TM_GPIO_InitAlternate
080002b8 g     F .isr_vector	00000004 Reset_Handler
08001efc g     F .text	0000011c TIM_Base_SetConfig
0800032c  w    F .isr_vector	00000002 CAN1_RX1_IRQHandler
0800032c  w    F .isr_vector	00000002 UART5_IRQHandler
08002570 g     F .text	00000090 PtCan_SdStorage_storeSD
08001c2c g     F .text	0000009c HAL_TIM_Base_Start_IT
08002190  w    F .text	00000008 __initialize_hardware
0800032c  w    F .isr_vector	00000002 DMA2_Stream0_IRQHandler
08001cc8 g     F .text	000000b0 HAL_TIM_Base_Stop_IT
08000388 g     F .text	00000034 HAL_Init
08002198  w    F .text	00000024 __reset_hardware
0800032c  w    F .isr_vector	00000002 TIM4_IRQHandler
0800381c g     F .text	00000088 TM_FATFS_SD_disk_read
08005b2c g     F .text	00000054 TM_SPI3_INT_InitPins
08002b08 g     F .text	00000028 HAL_GPIO_EXTI_Callback
20001b20 g     O .bss	00000040 hcan2
0800032c  w    F .isr_vector	00000002 I2C1_EV_IRQHandler
08000930  w    F .text	00000002 HAL_CAN_TxCpltCallback
0800032c  w    F .isr_vector	00000002 DMA1_Stream6_IRQHandler
08002efc  w    F .text	00000004 TM_FATFS_SDRAM_disk_read
08005f34 g     F .text	000000b2 __ssputs_r
08000330 g       .inits	00000000 __data_regions_array_start
20000144 g       .data	00000000 __data_end__
08002a28 g     F .text	00000020 BSP_LED_On
0800032c  w    F .isr_vector	00000002 DMA1_Stream1_IRQHandler
0800032c  w    F .isr_vector	00000002 UART4_IRQHandler
08006510 g     F .text	00000000 memchr
20001e90 g       .bss	00000000 __bss_end__
08005d98 g     F .text	0000008c _free_r
20000010 g     O .data	00000010 GPIO_PORT
08002eb0 g     F .text	00000014 TIM3_IRQHandler
0800032c  w    F .isr_vector	00000002 RCC_IRQHandler
0800032c  w    F .isr_vector	00000002 TIM8_BRK_TIM12_IRQHandler
08005a2c g     F .text	00000050 TM_SPI1_INT_InitPins
0800558c g     F .text	00000028 f_close
0800032c  w    F .isr_vector	00000002 Default_Handler
08000188  w    F .isr_vector	00000130 _start
08006790 g     O .text	00000010 AHBPrescTable
0800032c  w    F .isr_vector	00000002 EXTI15_10_IRQHandler
00000100 g       *ABS*	00000000 _Minimum_Stack_Size
0800032c  w    F .isr_vector	00000002 ADC_IRQHandler
08001680 g     F .text	00000368 HAL_RCC_ClockConfig
08000c88 g     F .text	0000003c HAL_NVIC_SetPriorityGrouping
0800032c  w    F .isr_vector	00000002 DMA1_Stream7_IRQHandler
08000d74 g     F .text	0000002c HAL_NVIC_DisableIRQ
0800032c  w    F .isr_vector	00000002 TIM7_IRQHandler
08002e80 g     F .text	00000010 CAN2_TX_IRQHandler
0800032c  w    F .isr_vector	00000002 TIM5_IRQHandler
08002af0 g     F .text	0000000c reset_button_state
0800032c  w    F .isr_vector	00000002 DMA2_Stream7_IRQHandler
08002018 g     F .text	000000ec HAL_TIM_Base_Init
08002900 g     F .text	00000050 HAL_TIM_PeriodElapsedCallback
0800032c  w    F .isr_vector	00000002 I2C3_EV_IRQHandler
08000308  w    F .isr_vector	00000002 UsageFault_Handler_C
0800032c  w    F .isr_vector	00000002 EXTI9_5_IRQHandler
08000000 g       *ABS*	00000000 __vectors_start
08002f00  w    F .text	00000004 TM_FATFS_SPI_FLASH_disk_read
0800032c  w    F .isr_vector	00000002 RTC_WKUP_IRQHandler
08002fcc  w    F .text	00000008 get_fattime
0800032c  w    F .isr_vector	00000002 ETH_WKUP_IRQHandler
080057e8 g     F .text	0000000c HAL_GetTick
08002480 g     F .text	00000020 Error_Handler_fats
0800032c  w    F .isr_vector	00000002 SPI2_IRQHandler
08005a28  w    F .text	00000002 TM_SPI_InitCustomPinsCallback
0800032c  w    F .isr_vector	00000002 OTG_HS_EP1_IN_IRQHandler
080002d8  w    F .isr_vector	00000002 MemManage_Handler
08002cac g     F .text	00000034 main
0800032c  w    F .isr_vector	00000002 DMA1_Stream0_IRQHandler
080054ec g     F .text	000000a0 f_sync
0800032c  w    F .isr_vector	00000002 CAN1_TX_IRQHandler
0800030c  w    F .isr_vector	00000002 SVC_Handler
08005e24 g     F .text	000000a8 _malloc_r
08001d7c  w    F .text	00000002 HAL_TIM_IC_CaptureCallback
08002324 g     F .text	000000fc HAL_CAN_RxCpltCallback
080050fc g     F .text	00000060 f_mount
080008c0 g     F .text	00000070 HAL_CAN_WakeUp
0800281c g     F .text	00000034 PtCan_SdStorage_SDMount
08002eec  w    F .text	00000004 TM_FATFS_SDRAM_disk_ioctl
08002ae4 g     F .text	0000000c set_button_state
08005838 g     F .text	0000001c TM_GPIO_INT_EnableClock
08000af8  w    F .text	00000002 HAL_CAN_ErrorCallback
0800032c  w    F .isr_vector	00000002 EXTI4_IRQHandler
08002ed8  w    F .text	00000004 TM_FATFS_USBHS_disk_status
20001af0 g     O .bss	00000004 TM_Time
0800279c g     F .text	00000080 PtCan_initMemory
0800285c g     F .text	0000000c PtCan_SdStorage_setStorageState
080021bc g     F .text	00000040 SystemInit
08004a94 g     F .text	00000128 put_fat
080055b4 g     F .text	0000015e f_lseek
08001d80  w    F .text	00000002 HAL_TIM_PWM_PulseFinishedCallback
08005eec g     F .text	00000048 sprintf
08005a7c g     F .text	000000b0 TM_SPI2_INT_InitPins
08002ee0  w    F .text	00000004 TM_FATFS_SPI_FLASH_disk_status
080038a4 g     F .text	000000b4 TM_FATFS_SD_disk_write
08000360  w    F .text	00000028 HAL_InitTick
0800032c  w    F .isr_vector	00000002 ETH_IRQHandler
080061d0 g     F .text	000000ec _printf_common
08000844 g     F .text	0000007a HAL_CAN_Sleep
2000013c g     O .data	00000004 _impure_ptr
08005764 g     F .text	00000084 HAL_IncTick
0800032c  w    F .isr_vector	00000002 OTG_HS_EP1_OUT_IRQHandler
080037e8 g     F .text	00000034 TM_FATFS_SD_disk_status
08005fe8 g     F .text	000001e8 _svfiprintf_r
0800032c  w    F .isr_vector	00000002 WWDG_IRQHandler
0800571c g     F .text	00000008 ff_memfree
08000348 g       .inits	00000000 __data_regions_array_end
08001d84  w    F .text	00000002 HAL_TIM_TriggerCallback
08002e9c g     F .text	00000014 TIM2_IRQHandler
0800295c g     F .text	0000000c PtCan_Tim_ResetCounter
08000000 g     O .isr_vector	00000188 __isr_vectors
0800032c  w    F .isr_vector	00000002 OTG_FS_WKUP_IRQHandler
20001e50 g     O .bss	0000003c htim2
0800032c  w    F .isr_vector	00000002 TIM1_TRG_COM_TIM11_IRQHandler
08000afc g     F .text	0000018c HAL_CAN_IRQHandler
0800032c  w    F .isr_vector	00000002 OTG_HS_IRQHandler
08002a0c g     F .text	0000001c BSP_LED_Toggle
080048fc g     F .text	00000018 clust2sect
08000dfc g     F .text	00000038 HAL_SYSTICK_CLKSourceConfig
0800052c g     F .text	0000026c HAL_CAN_Init
20020000 g       *ABS*	00000000 _estack
20020000 g       .isr_vector	00000000 __stack
0800032c  w    F .isr_vector	00000002 EXTI1_IRQHandler
20001ba0 g     O .bss	00000040 FileDescriptorMap
08002ed0  w    F .text	00000004 TM_FATFS_SPI_FLASH_disk_initialize
20000144 g       .data	00000000 _edata
08002ee4  w    F .text	00000004 TM_FATFS_USBFS_disk_ioctl
08002f04  w    F .text	00000004 TM_FATFS_USBFS_disk_write
0800244c g     F .text	00000014 PtCan_Can1WU
0800533c g     F .text	000001b0 f_write
08002df8 g     F .text	0000006c HAL_TIM_Base_MspInit
08002950 g     F .text	0000000c PtCan_Tim_GetCounter
20001b60 g     O .bss	00000040 hcan1
08002ed4  w    F .text	00000004 TM_FATFS_USBFS_disk_status
08003958 g     F .text	000002a8 TM_FATFS_SD_disk_ioctl
0800032c  w    F .isr_vector	00000002 USART2_IRQHandler
08005828 g     F .text	0000000e TM_GPIO_GetPortSource
08002ef0  w    F .text	00000004 TM_FATFS_SPI_FLASH_disk_ioctl
080011d8  w    F .text	000004a8 HAL_RCC_OscConfig
0800515c g     F .text	000001e0 f_open
08002f7c g     F .text	00000030 disk_write
20001be0 g     O .bss	00000234 FS
080021fc g     F .text	000000a0 SystemCoreClockUpdate
08005854 g     F .text	000000b8 TM_GPIO_INT_Init
0800032c  w    F .isr_vector	00000002 I2C2_ER_IRQHandler
08002ef4  w    F .text	00000004 TM_FATFS_USBFS_disk_read
08002968 g     F .text	000000a4 BSP_LED_Init
08005eec g     F .text	00000048 siprintf
0800032c  w    F .isr_vector	00000002 DMA2_Stream1_IRQHandler
08000348 g       .inits	00000000 __bss_regions_array_start
0800032c  w    F .isr_vector	00000002 CAN1_SCE_IRQHandler
0800032c  w    F .isr_vector	00000002 FLASH_IRQHandler
0800210c  w    F .text	00000006 _exit
0800032c  w    F .isr_vector	00000002 DMA2_Stream4_IRQHandler
080002dc  w    F .isr_vector	00000014 BusFault_Handler
0800032c  w    F .isr_vector	00000002 USART1_IRQHandler
08002ee8  w    F .text	00000004 TM_FATFS_USBHS_disk_ioctl
08000e38 g     F .text	00000008 HAL_SYSTICK_IRQHandler
08002f4c g     F .text	00000030 disk_read
0800032c  w    F .isr_vector	00000002 OTG_FS_IRQHandler
080062bc g     F .text	0000024c _printf_i
0800032c  w    F .isr_vector	00000002 SPI3_IRQHandler
0800032c  w    F .isr_vector	00000002 DMA1_Stream4_IRQHandler
20001b14 g     O .bss	00000004 __malloc_sbrk_start
08002850 g     F .text	0000000c PtCan_SdStorage_getStorageState
0800032c  w    F .isr_vector	00000002 I2C1_ER_IRQHandler
0800032c  w    F .isr_vector	00000002 FMC_IRQHandler
08005ce0 g     F .text	0000003c ff_convert
20001b18 g     O .bss	00000004 __malloc_free_list
08002108  w    F .text	00000002 HAL_TIMEx_BreakCallback
08003600 g     F .text	000001e8 TM_FATFS_SD_disk_initialize
0800032c  w    F .isr_vector	00000002 DMA2_Stream6_IRQHandler
0800032c  w    F .isr_vector	00000002 DMA1_Stream3_IRQHandler
08005714 g     F .text	00000008 ff_memalloc
08005d88 g     F .text	00000010 free
080024a0 g     F .text	00000020 Error_Handler



Disassembly of section .isr_vector:

08000000 <__isr_vectors>:
 8000000:	00 00 02 20 b9 02 00 08 bd 02 00 08 c1 02 00 08     ... ............
 8000010:	d9 02 00 08 dd 02 00 08 f5 02 00 08 00 00 00 00     ................
	...
 800002c:	0d 03 00 08 11 03 00 08 00 00 00 00 15 03 00 08     ................
 800003c:	65 2e 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     e...-...-...-...
 800004c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 91 2e 00 08     -...-...-.......
 800005c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800006c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800007c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800008c:	2d 03 00 08 71 2e 00 08 2d 03 00 08 2d 03 00 08     -...q...-...-...
 800009c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 80000ac:	2d 03 00 08 9d 2e 00 08 b1 2e 00 08 2d 03 00 08     -...........-...
 80000bc:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 80000cc:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 80000dc:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 80000ec:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 80000fc:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800010c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800011c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800012c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800013c:	81 2e 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     ....-...-...-...
 800014c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800015c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800016c:	2d 03 00 08 2d 03 00 08 2d 03 00 08 2d 03 00 08     -...-...-...-...
 800017c:	00 00 00 00 2d 03 00 08 2d 03 00 08                 ....-...-...

08000188 <_start>:
_start():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:224
// For the call to work, and for the call to __initialize_hardware_early()
// to work, the reset stack must point to a valid internal RAM area.

void __attribute__ ((section(".after_vectors"),noreturn,weak))
_start (void)
{
 8000188:	b500      	push	{lr}
 800018a:	b083      	sub	sp, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:235
  // enabled and require an early sequence to disable it.
  //
  // Also useful on platform with external RAM, that need to be
  // initialised before filling the BSS section.

  __initialize_hardware_early ();
 800018c:	f001 fff4 	bl	8002178 <__initialize_hardware_early>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:241

  // Use Old Style DATA and BSS section initialisation,
  // that will manage a single BSS sections.

#if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
  __data_begin_guard = DATA_GUARD_BAD_VALUE;
 8000190:	4b38      	ldr	r3, [pc, #224]	; (8000274 <_start+0xec>)
 8000192:	4a39      	ldr	r2, [pc, #228]	; (8000278 <_start+0xf0>)
 8000194:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:242
  __data_end_guard = DATA_GUARD_BAD_VALUE;
 8000196:	4a39      	ldr	r2, [pc, #228]	; (800027c <_start+0xf4>)
 8000198:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:251
  // Copy the DATA segment from Flash to RAM (inlined).
  __initialize_data(&_sidata, &_sdata, &_edata);
#else

  // Copy the data sections from flash to SRAM.
  for (unsigned int* p = &__data_regions_array_start;
 800019a:	4939      	ldr	r1, [pc, #228]	; (8000280 <_start+0xf8>)
 800019c:	e00c      	b.n	80001b8 <_start+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:254
      p < &__data_regions_array_end;)
    {
      unsigned int* from = (unsigned int *) (*p++);
 800019e:	680a      	ldr	r2, [r1, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:255
      unsigned int* region_begin = (unsigned int *) (*p++);
 80001a0:	684b      	ldr	r3, [r1, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:256
      unsigned int* region_end = (unsigned int *) (*p++);
 80001a2:	f101 040c 	add.w	r4, r1, #12
 80001a6:	6888      	ldr	r0, [r1, #8]
 80001a8:	e003      	b.n	80001b2 <_start+0x2a>
__initialize_data():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:124
{
  // Iterate and copy word by word.
  // It is assumed that the pointers are word aligned.
  unsigned int *p = region_begin;
  while (p < region_end)
    *p++ = *from++;
 80001aa:	6811      	ldr	r1, [r2, #0]
 80001ac:	6019      	str	r1, [r3, #0]
 80001ae:	3304      	adds	r3, #4
 80001b0:	3204      	adds	r2, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:123
		   unsigned int* region_end)
{
  // Iterate and copy word by word.
  // It is assumed that the pointers are word aligned.
  unsigned int *p = region_begin;
  while (p < region_end)
 80001b2:	4298      	cmp	r0, r3
 80001b4:	d8f9      	bhi.n	80001aa <_start+0x22>
_start():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:256
  for (unsigned int* p = &__data_regions_array_start;
      p < &__data_regions_array_end;)
    {
      unsigned int* from = (unsigned int *) (*p++);
      unsigned int* region_begin = (unsigned int *) (*p++);
      unsigned int* region_end = (unsigned int *) (*p++);
 80001b6:	4621      	mov	r1, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:251 (discriminator 1)
  // Copy the DATA segment from Flash to RAM (inlined).
  __initialize_data(&_sidata, &_sdata, &_edata);
#else

  // Copy the data sections from flash to SRAM.
  for (unsigned int* p = &__data_regions_array_start;
 80001b8:	4b32      	ldr	r3, [pc, #200]	; (8000284 <_start+0xfc>)
 80001ba:	4299      	cmp	r1, r3
 80001bc:	d3ef      	bcc.n	800019e <_start+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:264
    }

#endif

#if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
  if ((__data_begin_guard != DATA_BEGIN_GUARD_VALUE)
 80001be:	4b2e      	ldr	r3, [pc, #184]	; (8000278 <_start+0xf0>)
 80001c0:	681a      	ldr	r2, [r3, #0]
 80001c2:	4b31      	ldr	r3, [pc, #196]	; (8000288 <_start+0x100>)
 80001c4:	429a      	cmp	r2, r3
 80001c6:	d104      	bne.n	80001d2 <_start+0x4a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:265
      || (__data_end_guard != DATA_END_GUARD_VALUE))
 80001c8:	4b2c      	ldr	r3, [pc, #176]	; (800027c <_start+0xf4>)
 80001ca:	681a      	ldr	r2, [r3, #0]
 80001cc:	4b2f      	ldr	r3, [pc, #188]	; (800028c <_start+0x104>)
 80001ce:	429a      	cmp	r2, r3
 80001d0:	d000      	beq.n	80001d4 <_start+0x4c>
 80001d2:	e7fe      	b.n	80001d2 <_start+0x4a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:273
	;
    }
#endif

#if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
  __bss_begin_guard = BSS_GUARD_BAD_VALUE;
 80001d4:	4b27      	ldr	r3, [pc, #156]	; (8000274 <_start+0xec>)
 80001d6:	4a2e      	ldr	r2, [pc, #184]	; (8000290 <_start+0x108>)
 80001d8:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:274
  __bss_end_guard = BSS_GUARD_BAD_VALUE;
 80001da:	4a2e      	ldr	r2, [pc, #184]	; (8000294 <_start+0x10c>)
 80001dc:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:283
  // Zero fill the BSS section (inlined).
  __initialize_bss(&__bss_start__, &__bss_end__);
#else

  // Zero fill all bss segments
  for (unsigned int *p = &__bss_regions_array_start;
 80001de:	4b2e      	ldr	r3, [pc, #184]	; (8000298 <_start+0x110>)
 80001e0:	e00a      	b.n	80001f8 <_start+0x70>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:286
      p < &__bss_regions_array_end;)
    {
      unsigned int* region_begin = (unsigned int*) (*p++);
 80001e2:	4619      	mov	r1, r3
 80001e4:	f851 2b08 	ldr.w	r2, [r1], #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:287
      unsigned int* region_end = (unsigned int*) (*p++);
 80001e8:	685b      	ldr	r3, [r3, #4]
 80001ea:	e002      	b.n	80001f2 <_start+0x6a>
__initialize_bss():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:135
{
  // Iterate and clear word by word.
  // It is assumed that the pointers are word aligned.
  unsigned int *p = region_begin;
  while (p < region_end)
    *p++ = 0;
 80001ec:	2000      	movs	r0, #0
 80001ee:	6010      	str	r0, [r2, #0]
 80001f0:	3204      	adds	r2, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:134
__initialize_bss (unsigned int* region_begin, unsigned int* region_end)
{
  // Iterate and clear word by word.
  // It is assumed that the pointers are word aligned.
  unsigned int *p = region_begin;
  while (p < region_end)
 80001f2:	429a      	cmp	r2, r3
 80001f4:	d3fa      	bcc.n	80001ec <_start+0x64>
_start():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:287
  // Zero fill all bss segments
  for (unsigned int *p = &__bss_regions_array_start;
      p < &__bss_regions_array_end;)
    {
      unsigned int* region_begin = (unsigned int*) (*p++);
      unsigned int* region_end = (unsigned int*) (*p++);
 80001f6:	460b      	mov	r3, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:283 (discriminator 1)
  // Zero fill the BSS section (inlined).
  __initialize_bss(&__bss_start__, &__bss_end__);
#else

  // Zero fill all bss segments
  for (unsigned int *p = &__bss_regions_array_start;
 80001f8:	4a28      	ldr	r2, [pc, #160]	; (800029c <_start+0x114>)
 80001fa:	4293      	cmp	r3, r2
 80001fc:	d3f1      	bcc.n	80001e2 <_start+0x5a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:293
      __initialize_bss (region_begin, region_end);
    }
#endif

#if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
  if ((__bss_begin_guard != 0) || (__bss_end_guard != 0))
 80001fe:	4b24      	ldr	r3, [pc, #144]	; (8000290 <_start+0x108>)
 8000200:	681b      	ldr	r3, [r3, #0]
 8000202:	b913      	cbnz	r3, 800020a <_start+0x82>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:293 (discriminator 1)
 8000204:	4b23      	ldr	r3, [pc, #140]	; (8000294 <_start+0x10c>)
 8000206:	681b      	ldr	r3, [r3, #0]
 8000208:	b103      	cbz	r3, 800020c <_start+0x84>
 800020a:	e7fe      	b.n	800020a <_start+0x82>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:302
    }
#endif

  // Hook to continue the initialisations. Usually compute and store the
  // clock frequency in the global CMSIS variable, cleared above.
  __initialize_hardware ();
 800020c:	f001 ffc0 	bl	8002190 <__initialize_hardware>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:307

  // Get the argc/argv (useful in semihosting configurations).
  int argc;
  char** argv;
  __initialize_args (&argc, &argv);
 8000210:	4669      	mov	r1, sp
 8000212:	a801      	add	r0, sp, #4
 8000214:	f001 ffa4 	bl	8002160 <__initialize_args>
__run_init_array():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:160
__run_init_array (void)
{
  int count;
  int i;

  count = __preinit_array_end - __preinit_array_start;
 8000218:	4c21      	ldr	r4, [pc, #132]	; (80002a0 <_start+0x118>)
 800021a:	4b22      	ldr	r3, [pc, #136]	; (80002a4 <_start+0x11c>)
 800021c:	1b1c      	subs	r4, r3, r4
 800021e:	10a4      	asrs	r4, r4, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:161
  for (i = 0; i < count; i++)
 8000220:	2500      	movs	r5, #0
 8000222:	e004      	b.n	800022e <_start+0xa6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:162
    __preinit_array_start[i] ();
 8000224:	4b1e      	ldr	r3, [pc, #120]	; (80002a0 <_start+0x118>)
 8000226:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 800022a:	4798      	blx	r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:161
{
  int count;
  int i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
 800022c:	3501      	adds	r5, #1
 800022e:	42ac      	cmp	r4, r5
 8000230:	dcf8      	bgt.n	8000224 <_start+0x9c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:169
  // If you need to run the code in the .init section, please use
  // the startup files, since this requires the code in crti.o and crtn.o
  // to add the function prologue/epilogue.
  //_init(); // DO NOT ENABE THIS!

  count = __init_array_end - __init_array_start;
 8000232:	4c1d      	ldr	r4, [pc, #116]	; (80002a8 <_start+0x120>)
 8000234:	4b1d      	ldr	r3, [pc, #116]	; (80002ac <_start+0x124>)
 8000236:	1b1c      	subs	r4, r3, r4
 8000238:	10a4      	asrs	r4, r4, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:170
  for (i = 0; i < count; i++)
 800023a:	2500      	movs	r5, #0
 800023c:	e004      	b.n	8000248 <_start+0xc0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:171
    __init_array_start[i] ();
 800023e:	4b1a      	ldr	r3, [pc, #104]	; (80002a8 <_start+0x120>)
 8000240:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8000244:	4798      	blx	r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:170
  // the startup files, since this requires the code in crti.o and crtn.o
  // to add the function prologue/epilogue.
  //_init(); // DO NOT ENABE THIS!

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
 8000246:	3501      	adds	r5, #1
 8000248:	42ac      	cmp	r4, r5
 800024a:	dcf8      	bgt.n	800023e <_start+0xb6>
_start():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:314
  // Call the standard library initialisation (mandatory for C++ to
  // execute the constructors for the static objects).
  __run_init_array ();

  // Call the main entry point, and save the exit code.
  int code = main (argc, argv);
 800024c:	9900      	ldr	r1, [sp, #0]
 800024e:	9801      	ldr	r0, [sp, #4]
 8000250:	f002 fd2c 	bl	8002cac <main>
 8000254:	4605      	mov	r5, r0
__run_fini_array():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:182
__run_fini_array (void)
{
  int count;
  int i;

  count = __fini_array_end - __fini_array_start;
 8000256:	4c16      	ldr	r4, [pc, #88]	; (80002b0 <_start+0x128>)
 8000258:	4b16      	ldr	r3, [pc, #88]	; (80002b4 <_start+0x12c>)
 800025a:	1b1c      	subs	r4, r3, r4
 800025c:	10a4      	asrs	r4, r4, #2
 800025e:	e004      	b.n	800026a <_start+0xe2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:184
  for (i = count; i > 0; i--)
    __fini_array_start[i - 1] ();
 8000260:	3c01      	subs	r4, #1
 8000262:	4b13      	ldr	r3, [pc, #76]	; (80002b0 <_start+0x128>)
 8000264:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8000268:	4798      	blx	r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:183
{
  int count;
  int i;

  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
 800026a:	2c00      	cmp	r4, #0
 800026c:	dcf8      	bgt.n	8000260 <_start+0xd8>
_start():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_startup.c:319
  int code = main (argc, argv);

  // Run the C++ static destructors.
  __run_fini_array ();

  _exit (code);
 800026e:	4628      	mov	r0, r5
 8000270:	f001 ff4c 	bl	800210c <_exit>
 8000274:	cadebaba 	.word	0xcadebaba
 8000278:	20000000 	.word	0x20000000
 800027c:	20000140 	.word	0x20000140
 8000280:	08000330 	.word	0x08000330
 8000284:	08000348 	.word	0x08000348
 8000288:	12345678 	.word	0x12345678
 800028c:	98765432 	.word	0x98765432
 8000290:	20000144 	.word	0x20000144
 8000294:	20001e8c 	.word	0x20001e8c
 8000298:	08000348 	.word	0x08000348
 800029c:	08000358 	.word	0x08000358
 80002a0:	08000358 	.word	0x08000358
 80002a4:	08000358 	.word	0x08000358
 80002a8:	08000358 	.word	0x08000358
 80002ac:	08000358 	.word	0x08000358
 80002b0:	08000358 	.word	0x08000358
 80002b4:	08000358 	.word	0x08000358

080002b8 <Reset_Handler>:
Reset_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:41

// The Release version is optimised to a quick branch to _start.
void __attribute__ ((section(".after_vectors"),naked))
Reset_Handler(void)
  {
    asm volatile
 80002b8:	4818      	ldr	r0, [pc, #96]	; (800031c <PendSV_Handler+0x8>)
 80002ba:	4700      	bx	r0

080002bc <NMI_Handler>:
NMI_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:55

#endif

void __attribute__ ((section(".after_vectors"),weak))
NMI_Handler (void)
{
 80002bc:	e7fe      	b.n	80002bc <NMI_Handler>
 80002be:	bf00      	nop

080002c0 <HardFault_Handler>:
HardFault_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:328
// Cortex-M4 Processors, Third Edition, Chap. 12.8, page 402).

void __attribute__ ((section(".after_vectors"),weak,naked))
HardFault_Handler (void)
{
  asm volatile(
 80002c0:	f01e 0f04 	tst.w	lr, #4
 80002c4:	bf0c      	ite	eq
 80002c6:	f3ef 8008 	mrseq	r0, MSP
 80002ca:	f3ef 8009 	mrsne	r0, PSP
 80002ce:	4671      	mov	r1, lr
 80002d0:	4a13      	ldr	r2, [pc, #76]	; (8000320 <PendSV_Handler+0xc>)
 80002d2:	4710      	bx	r2

080002d4 <HardFault_Handler_C>:
HardFault_Handler_C():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:346
}

void __attribute__ ((section(".after_vectors"),weak,used))
HardFault_Handler_C (ExceptionStackFrame* frame __attribute__((unused)),
                     uint32_t lr __attribute__((unused)))
{
 80002d4:	e7fe      	b.n	80002d4 <HardFault_Handler_C>
 80002d6:	bf00      	nop

080002d8 <MemManage_Handler>:
MemManage_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:450

#if defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__)

void __attribute__ ((section(".after_vectors"),weak))
MemManage_Handler (void)
{
 80002d8:	e7fe      	b.n	80002d8 <MemManage_Handler>
 80002da:	bf00      	nop

080002dc <BusFault_Handler>:
BusFault_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:462
}

void __attribute__ ((section(".after_vectors"),weak,naked))
BusFault_Handler (void)
{
  asm volatile(
 80002dc:	f01e 0f04 	tst.w	lr, #4
 80002e0:	bf0c      	ite	eq
 80002e2:	f3ef 8008 	mrseq	r0, MSP
 80002e6:	f3ef 8009 	mrsne	r0, PSP
 80002ea:	4671      	mov	r1, lr
 80002ec:	4a0d      	ldr	r2, [pc, #52]	; (8000324 <PendSV_Handler+0x10>)
 80002ee:	4710      	bx	r2

080002f0 <BusFault_Handler_C>:
BusFault_Handler_C():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:480
}

void __attribute__ ((section(".after_vectors"),weak,used))
BusFault_Handler_C (ExceptionStackFrame* frame __attribute__((unused)),
                    uint32_t lr __attribute__((unused)))
{
 80002f0:	e7fe      	b.n	80002f0 <BusFault_Handler_C>
 80002f2:	bf00      	nop

080002f4 <UsageFault_Handler>:
UsageFault_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:501
}

void __attribute__ ((section(".after_vectors"),weak,naked))
UsageFault_Handler (void)
{
  asm volatile(
 80002f4:	f01e 0f04 	tst.w	lr, #4
 80002f8:	bf0c      	ite	eq
 80002fa:	f3ef 8008 	mrseq	r0, MSP
 80002fe:	f3ef 8009 	mrsne	r0, PSP
 8000302:	4671      	mov	r1, lr
 8000304:	4a08      	ldr	r2, [pc, #32]	; (8000328 <PendSV_Handler+0x14>)
 8000306:	4710      	bx	r2

08000308 <UsageFault_Handler_C>:
UsageFault_Handler_C():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:519
}

void __attribute__ ((section(".after_vectors"),weak,used))
UsageFault_Handler_C (ExceptionStackFrame* frame __attribute__((unused)),
                      uint32_t lr __attribute__((unused)))
{
 8000308:	e7fe      	b.n	8000308 <UsageFault_Handler_C>
 800030a:	bf00      	nop

0800030c <SVC_Handler>:
SVC_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:556

#endif

void __attribute__ ((section(".after_vectors"),weak))
SVC_Handler (void)
{
 800030c:	e7fe      	b.n	800030c <SVC_Handler>
 800030e:	bf00      	nop

08000310 <DebugMon_Handler>:
DebugMon_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:569

#if defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__)

void __attribute__ ((section(".after_vectors"),weak))
DebugMon_Handler (void)
{
 8000310:	e7fe      	b.n	8000310 <DebugMon_Handler>
 8000312:	bf00      	nop

08000314 <PendSV_Handler>:
PendSV_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:582

#endif

void __attribute__ ((section(".after_vectors"),weak))
PendSV_Handler (void)
{
 8000314:	e7fe      	b.n	8000314 <PendSV_Handler>
 8000316:	bf00      	nop
SysTick_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/exception_handlers.c:593
    }
}

void __attribute__ ((section(".after_vectors"),weak))
SysTick_Handler (void)
{
 8000318:	4770      	bx	lr
PendSV_Handler():
 800031a:	0000      	.short	0x0000
 800031c:	08000189 	.word	0x08000189
 8000320:	080002d5 	.word	0x080002d5
 8000324:	080002f1 	.word	0x080002f1
 8000328:	08000309 	.word	0x08000309

0800032c <ADC_IRQHandler>:
Default_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/vectors_stm32f407xx.c:326
// When in DEBUG, trigger a debug exception to clearly notify
// the user of the exception and help identify the cause.

void __attribute__ ((section(".after_vectors")))
Default_Handler(void)
{
 800032c:	e7fe      	b.n	800032c <ADC_IRQHandler>
DMA1_Stream3_IRQHandler():
 800032e:	bf00      	nop

Disassembly of section .text:

08000360 <HAL_InitTick>:
HAL_InitTick():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:264
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000360:	b510      	push	{r4, lr}
 8000362:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:266
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000364:	f001 fb90 	bl	8001a88 <HAL_RCC_GetHCLKFreq>
 8000368:	4b06      	ldr	r3, [pc, #24]	; (8000384 <HAL_InitTick+0x24>)
 800036a:	fba3 3000 	umull	r3, r0, r3, r0
 800036e:	0980      	lsrs	r0, r0, #6
 8000370:	f000 fd16 	bl	8000da0 <HAL_SYSTICK_Config>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:269

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000374:	2200      	movs	r2, #0
 8000376:	4621      	mov	r1, r4
 8000378:	f04f 30ff 	mov.w	r0, #4294967295
 800037c:	f000 fca2 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:273

  /* Return function status */
  return HAL_OK;
}
 8000380:	2000      	movs	r0, #0
 8000382:	bd10      	pop	{r4, pc}
 8000384:	10624dd3 	.word	0x10624dd3

08000388 <HAL_Init>:
HAL_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:168
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000388:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:171
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800038a:	4b0b      	ldr	r3, [pc, #44]	; (80003b8 <HAL_Init+0x30>)
 800038c:	681a      	ldr	r2, [r3, #0]
 800038e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000392:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:175
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8000394:	681a      	ldr	r2, [r3, #0]
 8000396:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800039a:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:179
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800039c:	681a      	ldr	r2, [r3, #0]
 800039e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80003a2:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:183
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80003a4:	2003      	movs	r0, #3
 80003a6:	f000 fc6f 	bl	8000c88 <HAL_NVIC_SetPriorityGrouping>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:186

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80003aa:	2000      	movs	r0, #0
 80003ac:	f7ff ffd8 	bl	8000360 <HAL_InitTick>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:189
  
  /* Init the low level hardware */
  HAL_MspInit();
 80003b0:	f002 fc96 	bl	8002ce0 <HAL_MspInit>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal.c:193
  
  /* Return function status */
  return HAL_OK;
}
 80003b4:	2000      	movs	r0, #0
 80003b6:	bd08      	pop	{r3, pc}
 80003b8:	40023c00 	.word	0x40023c00

080003bc <HAL_CAN_ConfigFilter>:
HAL_CAN_ConfigFilter():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:360
  * @param  sFilterConfig: pointer to a CAN_FilterConfTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef* hcan, CAN_FilterConfTypeDef* sFilterConfig)
{
 80003bc:	b570      	push	{r4, r5, r6, lr}
 80003be:	460c      	mov	r4, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:364
  uint32_t filternbrbitpos = 0;
  
  /* Check the parameters */
  assert_param(IS_CAN_FILTER_NUMBER(sFilterConfig->FilterNumber));
 80003c0:	694b      	ldr	r3, [r1, #20]
 80003c2:	2b1b      	cmp	r3, #27
 80003c4:	d904      	bls.n	80003d0 <HAL_CAN_ConfigFilter+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:364 (discriminator 1)
 80003c6:	f44f 71b6 	mov.w	r1, #364	; 0x16c
 80003ca:	4856      	ldr	r0, [pc, #344]	; (8000524 <HAL_CAN_ConfigFilter+0x168>)
 80003cc:	f001 fed0 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:365
  assert_param(IS_CAN_FILTER_MODE(sFilterConfig->FilterMode));
 80003d0:	69a3      	ldr	r3, [r4, #24]
 80003d2:	2b01      	cmp	r3, #1
 80003d4:	d904      	bls.n	80003e0 <HAL_CAN_ConfigFilter+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:365 (discriminator 1)
 80003d6:	f240 116d 	movw	r1, #365	; 0x16d
 80003da:	4852      	ldr	r0, [pc, #328]	; (8000524 <HAL_CAN_ConfigFilter+0x168>)
 80003dc:	f001 fec8 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:366
  assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
 80003e0:	69e3      	ldr	r3, [r4, #28]
 80003e2:	2b01      	cmp	r3, #1
 80003e4:	d904      	bls.n	80003f0 <HAL_CAN_ConfigFilter+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:366 (discriminator 1)
 80003e6:	f44f 71b7 	mov.w	r1, #366	; 0x16e
 80003ea:	484e      	ldr	r0, [pc, #312]	; (8000524 <HAL_CAN_ConfigFilter+0x168>)
 80003ec:	f001 fec0 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:367
  assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
 80003f0:	6923      	ldr	r3, [r4, #16]
 80003f2:	2b01      	cmp	r3, #1
 80003f4:	d904      	bls.n	8000400 <HAL_CAN_ConfigFilter+0x44>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:367 (discriminator 1)
 80003f6:	f240 116f 	movw	r1, #367	; 0x16f
 80003fa:	484a      	ldr	r0, [pc, #296]	; (8000524 <HAL_CAN_ConfigFilter+0x168>)
 80003fc:	f001 feb8 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:368
  assert_param(IS_FUNCTIONAL_STATE(sFilterConfig->FilterActivation));
 8000400:	6a23      	ldr	r3, [r4, #32]
 8000402:	2b01      	cmp	r3, #1
 8000404:	d904      	bls.n	8000410 <HAL_CAN_ConfigFilter+0x54>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:368 (discriminator 1)
 8000406:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800040a:	4846      	ldr	r0, [pc, #280]	; (8000524 <HAL_CAN_ConfigFilter+0x168>)
 800040c:	f001 feb0 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:369
  assert_param(IS_CAN_BANKNUMBER(sFilterConfig->BankNumber));
 8000410:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000412:	2b1c      	cmp	r3, #28
 8000414:	d904      	bls.n	8000420 <HAL_CAN_ConfigFilter+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:369 (discriminator 1)
 8000416:	f240 1171 	movw	r1, #369	; 0x171
 800041a:	4842      	ldr	r0, [pc, #264]	; (8000524 <HAL_CAN_ConfigFilter+0x168>)
 800041c:	f001 fea8 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:371
  
  filternbrbitpos = ((uint32_t)1) << sFilterConfig->FilterNumber;
 8000420:	6963      	ldr	r3, [r4, #20]
 8000422:	2201      	movs	r2, #1
 8000424:	409a      	lsls	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:374

  /* Initialisation mode for the filter */
  CAN1->FMR |= (uint32_t)CAN_FMR_FINIT;
 8000426:	4b40      	ldr	r3, [pc, #256]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 8000428:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
 800042c:	f041 0101 	orr.w	r1, r1, #1
 8000430:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:377
  
  /* Select the start slave bank */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_CAN2SB);
 8000434:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
 8000438:	f421 517c 	bic.w	r1, r1, #16128	; 0x3f00
 800043c:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:378
  CAN1->FMR |= (uint32_t)(sFilterConfig->BankNumber << 8);
 8000440:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
 8000444:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8000446:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 800044a:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:381
     
  /* Filter Deactivation */
  CAN1->FA1R &= ~(uint32_t)filternbrbitpos;
 800044e:	f8d3 121c 	ldr.w	r1, [r3, #540]	; 0x21c
 8000452:	43d0      	mvns	r0, r2
 8000454:	4001      	ands	r1, r0
 8000456:	f8c3 121c 	str.w	r1, [r3, #540]	; 0x21c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:384

  /* Filter Scale */
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 800045a:	69e3      	ldr	r3, [r4, #28]
 800045c:	b9b3      	cbnz	r3, 800048c <HAL_CAN_ConfigFilter+0xd0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:387
  {
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;
 800045e:	4b32      	ldr	r3, [pc, #200]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 8000460:	f8d3 120c 	ldr.w	r1, [r3, #524]	; 0x20c
 8000464:	4001      	ands	r1, r0
 8000466:	f8c3 120c 	str.w	r1, [r3, #524]	; 0x20c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:391

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 800046a:	6961      	ldr	r1, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:392
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 800046c:	68e6      	ldr	r6, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:393
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 800046e:	88a5      	ldrh	r5, [r4, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:392
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
 8000470:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:391
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filternbrbitpos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 8000474:	3148      	adds	r1, #72	; 0x48
 8000476:	f843 5031 	str.w	r5, [r3, r1, lsl #3]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:397
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 800047a:	6965      	ldr	r5, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:398
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 800047c:	68a6      	ldr	r6, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:399
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
 800047e:	8821      	ldrh	r1, [r4, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:398
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 8000480:	ea41 4106 	orr.w	r1, r1, r6, lsl #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:397
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 8000484:	3548      	adds	r5, #72	; 0x48
 8000486:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 800048a:	6059      	str	r1, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:402
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
  }

  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 800048c:	69e3      	ldr	r3, [r4, #28]
 800048e:	2b01      	cmp	r3, #1
 8000490:	d116      	bne.n	80004c0 <HAL_CAN_ConfigFilter+0x104>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:405
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
 8000492:	4b25      	ldr	r3, [pc, #148]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 8000494:	f8d3 120c 	ldr.w	r1, [r3, #524]	; 0x20c
 8000498:	4311      	orrs	r1, r2
 800049a:	f8c3 120c 	str.w	r1, [r3, #524]	; 0x20c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:407
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 800049e:	6961      	ldr	r1, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:408
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 80004a0:	6826      	ldr	r6, [r4, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:409
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
 80004a2:	88a5      	ldrh	r5, [r4, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:408
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
 80004a4:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:407
  if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filternbrbitpos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
 80004a8:	3148      	adds	r1, #72	; 0x48
 80004aa:	f843 5031 	str.w	r5, [r3, r1, lsl #3]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:411
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 80004ae:	6965      	ldr	r5, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:412
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 80004b0:	68a6      	ldr	r6, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:413
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
 80004b2:	89a1      	ldrh	r1, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:412
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
 80004b4:	ea41 4106 	orr.w	r1, r1, r6, lsl #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:411
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
 80004b8:	3548      	adds	r5, #72	; 0x48
 80004ba:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 80004be:	6059      	str	r1, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:417
       ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
  }

  /* Filter Mode */
  if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 80004c0:	69a3      	ldr	r3, [r4, #24]
 80004c2:	b933      	cbnz	r3, 80004d2 <HAL_CAN_ConfigFilter+0x116>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:420
  {
    /*Id/Mask mode for the filter*/
    CAN1->FM1R &= ~(uint32_t)filternbrbitpos;
 80004c4:	4918      	ldr	r1, [pc, #96]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 80004c6:	f8d1 3204 	ldr.w	r3, [r1, #516]	; 0x204
 80004ca:	4003      	ands	r3, r0
 80004cc:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
 80004d0:	e005      	b.n	80004de <HAL_CAN_ConfigFilter+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:425
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN1->FM1R |= (uint32_t)filternbrbitpos;
 80004d2:	4915      	ldr	r1, [pc, #84]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 80004d4:	f8d1 3204 	ldr.w	r3, [r1, #516]	; 0x204
 80004d8:	4313      	orrs	r3, r2
 80004da:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:429
  }

  /* Filter FIFO assignment */
  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 80004de:	6923      	ldr	r3, [r4, #16]
 80004e0:	b92b      	cbnz	r3, 80004ee <HAL_CAN_ConfigFilter+0x132>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:432
  {
    /* FIFO 0 assignation for the filter */
    CAN1->FFA1R &= ~(uint32_t)filternbrbitpos;
 80004e2:	4911      	ldr	r1, [pc, #68]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 80004e4:	f8d1 3214 	ldr.w	r3, [r1, #532]	; 0x214
 80004e8:	4018      	ands	r0, r3
 80004ea:	f8c1 0214 	str.w	r0, [r1, #532]	; 0x214
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:435
  }

  if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO1)
 80004ee:	6923      	ldr	r3, [r4, #16]
 80004f0:	2b01      	cmp	r3, #1
 80004f2:	d105      	bne.n	8000500 <HAL_CAN_ConfigFilter+0x144>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:438
  {
    /* FIFO 1 assignation for the filter */
    CAN1->FFA1R |= (uint32_t)filternbrbitpos;
 80004f4:	490c      	ldr	r1, [pc, #48]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 80004f6:	f8d1 3214 	ldr.w	r3, [r1, #532]	; 0x214
 80004fa:	4313      	orrs	r3, r2
 80004fc:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:442
  }
  
  /* Filter activation */
  if (sFilterConfig->FilterActivation == ENABLE)
 8000500:	6a23      	ldr	r3, [r4, #32]
 8000502:	2b01      	cmp	r3, #1
 8000504:	d105      	bne.n	8000512 <HAL_CAN_ConfigFilter+0x156>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:444
  {
    CAN1->FA1R |= filternbrbitpos;
 8000506:	4908      	ldr	r1, [pc, #32]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 8000508:	f8d1 321c 	ldr.w	r3, [r1, #540]	; 0x21c
 800050c:	431a      	orrs	r2, r3
 800050e:	f8c1 221c 	str.w	r2, [r1, #540]	; 0x21c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:448
  }

  /* Leave the initialisation mode for the filter */
  CAN1->FMR &= ~((uint32_t)CAN_FMR_FINIT);
 8000512:	4a05      	ldr	r2, [pc, #20]	; (8000528 <HAL_CAN_ConfigFilter+0x16c>)
 8000514:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 8000518:	f023 0301 	bic.w	r3, r3, #1
 800051c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:452
  
  /* Return function status */
  return HAL_OK;
}
 8000520:	2000      	movs	r0, #0
 8000522:	bd70      	pop	{r4, r5, r6, pc}
 8000524:	0800665c 	.word	0x0800665c
 8000528:	40006400 	.word	0x40006400

0800052c <HAL_CAN_Init>:
HAL_CAN_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:174
{
  uint32_t InitStatus = 3;
  uint32_t tickstart = 0;
  
  /* Check CAN handle */
  if(hcan == NULL)
 800052c:	2800      	cmp	r0, #0
 800052e:	f000 812d 	beq.w	800078c <HAL_CAN_Init+0x260>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:169
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef* hcan)
{
 8000532:	b538      	push	{r3, r4, r5, lr}
 8000534:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:180
  {
     return HAL_ERROR;
  }
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
 8000536:	6803      	ldr	r3, [r0, #0]
 8000538:	4a95      	ldr	r2, [pc, #596]	; (8000790 <HAL_CAN_Init+0x264>)
 800053a:	4293      	cmp	r3, r2
 800053c:	d007      	beq.n	800054e <HAL_CAN_Init+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:180 (discriminator 1)
 800053e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000542:	4293      	cmp	r3, r2
 8000544:	d003      	beq.n	800054e <HAL_CAN_Init+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:180 (discriminator 2)
 8000546:	21b4      	movs	r1, #180	; 0xb4
 8000548:	4892      	ldr	r0, [pc, #584]	; (8000794 <HAL_CAN_Init+0x268>)
 800054a:	f001 fe11 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:181
  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TTCM));
 800054e:	69a3      	ldr	r3, [r4, #24]
 8000550:	2b01      	cmp	r3, #1
 8000552:	d903      	bls.n	800055c <HAL_CAN_Init+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:181 (discriminator 1)
 8000554:	21b5      	movs	r1, #181	; 0xb5
 8000556:	488f      	ldr	r0, [pc, #572]	; (8000794 <HAL_CAN_Init+0x268>)
 8000558:	f001 fe0a 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:182
  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.ABOM));
 800055c:	69e3      	ldr	r3, [r4, #28]
 800055e:	2b01      	cmp	r3, #1
 8000560:	d903      	bls.n	800056a <HAL_CAN_Init+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:182 (discriminator 1)
 8000562:	21b6      	movs	r1, #182	; 0xb6
 8000564:	488b      	ldr	r0, [pc, #556]	; (8000794 <HAL_CAN_Init+0x268>)
 8000566:	f001 fe03 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:183
  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AWUM));
 800056a:	6a23      	ldr	r3, [r4, #32]
 800056c:	2b01      	cmp	r3, #1
 800056e:	d903      	bls.n	8000578 <HAL_CAN_Init+0x4c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:183 (discriminator 1)
 8000570:	21b7      	movs	r1, #183	; 0xb7
 8000572:	4888      	ldr	r0, [pc, #544]	; (8000794 <HAL_CAN_Init+0x268>)
 8000574:	f001 fdfc 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:184
  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.NART));
 8000578:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800057a:	2b01      	cmp	r3, #1
 800057c:	d903      	bls.n	8000586 <HAL_CAN_Init+0x5a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:184 (discriminator 1)
 800057e:	21b8      	movs	r1, #184	; 0xb8
 8000580:	4884      	ldr	r0, [pc, #528]	; (8000794 <HAL_CAN_Init+0x268>)
 8000582:	f001 fdf5 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:185
  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.RFLM));
 8000586:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000588:	2b01      	cmp	r3, #1
 800058a:	d903      	bls.n	8000594 <HAL_CAN_Init+0x68>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:185 (discriminator 1)
 800058c:	21b9      	movs	r1, #185	; 0xb9
 800058e:	4881      	ldr	r0, [pc, #516]	; (8000794 <HAL_CAN_Init+0x268>)
 8000590:	f001 fdee 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:186
  assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TXFP));
 8000594:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000596:	2b01      	cmp	r3, #1
 8000598:	d903      	bls.n	80005a2 <HAL_CAN_Init+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:186 (discriminator 1)
 800059a:	21ba      	movs	r1, #186	; 0xba
 800059c:	487d      	ldr	r0, [pc, #500]	; (8000794 <HAL_CAN_Init+0x268>)
 800059e:	f001 fde7 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:187
  assert_param(IS_CAN_MODE(hcan->Init.Mode));
 80005a2:	68a3      	ldr	r3, [r4, #8]
 80005a4:	b163      	cbz	r3, 80005c0 <HAL_CAN_Init+0x94>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:187 (discriminator 1)
 80005a6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80005aa:	d009      	beq.n	80005c0 <HAL_CAN_Init+0x94>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:187 (discriminator 2)
 80005ac:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80005b0:	d006      	beq.n	80005c0 <HAL_CAN_Init+0x94>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:187 (discriminator 3)
 80005b2:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 80005b6:	d003      	beq.n	80005c0 <HAL_CAN_Init+0x94>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:187 (discriminator 4)
 80005b8:	21bb      	movs	r1, #187	; 0xbb
 80005ba:	4876      	ldr	r0, [pc, #472]	; (8000794 <HAL_CAN_Init+0x268>)
 80005bc:	f001 fdd8 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:188
  assert_param(IS_CAN_SJW(hcan->Init.SJW));
 80005c0:	68e3      	ldr	r3, [r4, #12]
 80005c2:	b163      	cbz	r3, 80005de <HAL_CAN_Init+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:188 (discriminator 1)
 80005c4:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80005c8:	d009      	beq.n	80005de <HAL_CAN_Init+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:188 (discriminator 2)
 80005ca:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80005ce:	d006      	beq.n	80005de <HAL_CAN_Init+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:188 (discriminator 3)
 80005d0:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 80005d4:	d003      	beq.n	80005de <HAL_CAN_Init+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:188 (discriminator 4)
 80005d6:	21bc      	movs	r1, #188	; 0xbc
 80005d8:	486e      	ldr	r0, [pc, #440]	; (8000794 <HAL_CAN_Init+0x268>)
 80005da:	f001 fdc9 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:189
  assert_param(IS_CAN_BS1(hcan->Init.BS1));
 80005de:	6923      	ldr	r3, [r4, #16]
 80005e0:	f5b3 2f70 	cmp.w	r3, #983040	; 0xf0000
 80005e4:	d903      	bls.n	80005ee <HAL_CAN_Init+0xc2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:189 (discriminator 1)
 80005e6:	21bd      	movs	r1, #189	; 0xbd
 80005e8:	486a      	ldr	r0, [pc, #424]	; (8000794 <HAL_CAN_Init+0x268>)
 80005ea:	f001 fdc1 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:190
  assert_param(IS_CAN_BS2(hcan->Init.BS2));
 80005ee:	6963      	ldr	r3, [r4, #20]
 80005f0:	f5b3 0fe0 	cmp.w	r3, #7340032	; 0x700000
 80005f4:	d903      	bls.n	80005fe <HAL_CAN_Init+0xd2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:190 (discriminator 1)
 80005f6:	21be      	movs	r1, #190	; 0xbe
 80005f8:	4866      	ldr	r0, [pc, #408]	; (8000794 <HAL_CAN_Init+0x268>)
 80005fa:	f001 fdb9 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:191
  assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
 80005fe:	6863      	ldr	r3, [r4, #4]
 8000600:	3b01      	subs	r3, #1
 8000602:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000606:	d303      	bcc.n	8000610 <HAL_CAN_Init+0xe4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:191 (discriminator 1)
 8000608:	21bf      	movs	r1, #191	; 0xbf
 800060a:	4862      	ldr	r0, [pc, #392]	; (8000794 <HAL_CAN_Init+0x268>)
 800060c:	f001 fdb0 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:194
  

  if(hcan->State == HAL_CAN_STATE_RESET)
 8000610:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8000614:	f013 0fff 	tst.w	r3, #255	; 0xff
 8000618:	d105      	bne.n	8000626 <HAL_CAN_Init+0xfa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:197
  {    
    /* Allocate lock resource and initialize it */
    hcan->Lock = HAL_UNLOCKED;
 800061a:	2300      	movs	r3, #0
 800061c:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:199
    /* Init the low level hardware */
    HAL_CAN_MspInit(hcan);
 8000620:	4620      	mov	r0, r4
 8000622:	f002 fb69 	bl	8002cf8 <HAL_CAN_MspInit>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:203
  }
  
  /* Initialize the CAN state*/
  hcan->State = HAL_CAN_STATE_BUSY;
 8000626:	2302      	movs	r3, #2
 8000628:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:206
  
  /* Exit from sleep mode */
  hcan->Instance->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
 800062c:	6822      	ldr	r2, [r4, #0]
 800062e:	6813      	ldr	r3, [r2, #0]
 8000630:	f023 0302 	bic.w	r3, r3, #2
 8000634:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:209

  /* Request initialisation */
  hcan->Instance->MCR |= CAN_MCR_INRQ ;
 8000636:	6822      	ldr	r2, [r4, #0]
 8000638:	6813      	ldr	r3, [r2, #0]
 800063a:	f043 0301 	orr.w	r3, r3, #1
 800063e:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:212
  
  /* Get tick */
  tickstart = HAL_GetTick();
 8000640:	f005 f8d2 	bl	80057e8 <HAL_GetTick>
 8000644:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:215

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 8000646:	e00b      	b.n	8000660 <HAL_CAN_Init+0x134>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:217
  {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 8000648:	f005 f8ce 	bl	80057e8 <HAL_GetTick>
 800064c:	1b40      	subs	r0, r0, r5
 800064e:	280a      	cmp	r0, #10
 8000650:	d906      	bls.n	8000660 <HAL_CAN_Init+0x134>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:219
    {
      hcan->State= HAL_CAN_STATE_TIMEOUT;
 8000652:	2003      	movs	r0, #3
 8000654:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:221
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 8000658:	2300      	movs	r3, #0
 800065a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:222
      return HAL_TIMEOUT;
 800065e:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:215
  
  /* Get tick */
  tickstart = HAL_GetTick();

  /* Wait the acknowledge */
  while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 8000660:	6823      	ldr	r3, [r4, #0]
 8000662:	685a      	ldr	r2, [r3, #4]
 8000664:	f012 0f01 	tst.w	r2, #1
 8000668:	d0ee      	beq.n	8000648 <HAL_CAN_Init+0x11c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:227
      return HAL_TIMEOUT;
    }
  }

  /* Check acknowledge */
  if ((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 800066a:	685a      	ldr	r2, [r3, #4]
 800066c:	f012 0f01 	tst.w	r2, #1
 8000670:	d07d      	beq.n	800076e <HAL_CAN_Init+0x242>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:234
    InitStatus = CAN_INITSTATUS_FAILED;
  }
  else 
  {
    /* Set the time triggered communication mode */
    if (hcan->Init.TTCM == ENABLE)
 8000672:	69a2      	ldr	r2, [r4, #24]
 8000674:	2a01      	cmp	r2, #1
 8000676:	d104      	bne.n	8000682 <HAL_CAN_Init+0x156>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:236
    {
      hcan->Instance->MCR |= CAN_MCR_TTCM;
 8000678:	681a      	ldr	r2, [r3, #0]
 800067a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800067e:	601a      	str	r2, [r3, #0]
 8000680:	e003      	b.n	800068a <HAL_CAN_Init+0x15e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:240
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 8000682:	681a      	ldr	r2, [r3, #0]
 8000684:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000688:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:244
    }

    /* Set the automatic bus-off management */
    if (hcan->Init.ABOM == ENABLE)
 800068a:	69e3      	ldr	r3, [r4, #28]
 800068c:	2b01      	cmp	r3, #1
 800068e:	d105      	bne.n	800069c <HAL_CAN_Init+0x170>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:246
    {
      hcan->Instance->MCR |= CAN_MCR_ABOM;
 8000690:	6822      	ldr	r2, [r4, #0]
 8000692:	6813      	ldr	r3, [r2, #0]
 8000694:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000698:	6013      	str	r3, [r2, #0]
 800069a:	e004      	b.n	80006a6 <HAL_CAN_Init+0x17a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:250
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 800069c:	6822      	ldr	r2, [r4, #0]
 800069e:	6813      	ldr	r3, [r2, #0]
 80006a0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80006a4:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:254
    }

    /* Set the automatic wake-up mode */
    if (hcan->Init.AWUM == ENABLE)
 80006a6:	6a23      	ldr	r3, [r4, #32]
 80006a8:	2b01      	cmp	r3, #1
 80006aa:	d105      	bne.n	80006b8 <HAL_CAN_Init+0x18c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:256
    {
      hcan->Instance->MCR |= CAN_MCR_AWUM;
 80006ac:	6822      	ldr	r2, [r4, #0]
 80006ae:	6813      	ldr	r3, [r2, #0]
 80006b0:	f043 0320 	orr.w	r3, r3, #32
 80006b4:	6013      	str	r3, [r2, #0]
 80006b6:	e004      	b.n	80006c2 <HAL_CAN_Init+0x196>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:260
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 80006b8:	6822      	ldr	r2, [r4, #0]
 80006ba:	6813      	ldr	r3, [r2, #0]
 80006bc:	f023 0320 	bic.w	r3, r3, #32
 80006c0:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:264
    }

    /* Set the no automatic retransmission */
    if (hcan->Init.NART == ENABLE)
 80006c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80006c4:	2b01      	cmp	r3, #1
 80006c6:	d105      	bne.n	80006d4 <HAL_CAN_Init+0x1a8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:266
    {
      hcan->Instance->MCR |= CAN_MCR_NART;
 80006c8:	6822      	ldr	r2, [r4, #0]
 80006ca:	6813      	ldr	r3, [r2, #0]
 80006cc:	f043 0310 	orr.w	r3, r3, #16
 80006d0:	6013      	str	r3, [r2, #0]
 80006d2:	e004      	b.n	80006de <HAL_CAN_Init+0x1b2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:270
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_NART;
 80006d4:	6822      	ldr	r2, [r4, #0]
 80006d6:	6813      	ldr	r3, [r2, #0]
 80006d8:	f023 0310 	bic.w	r3, r3, #16
 80006dc:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:274
    }

    /* Set the receive FIFO locked mode */
    if (hcan->Init.RFLM == ENABLE)
 80006de:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80006e0:	2b01      	cmp	r3, #1
 80006e2:	d105      	bne.n	80006f0 <HAL_CAN_Init+0x1c4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:276
    {
      hcan->Instance->MCR |= CAN_MCR_RFLM;
 80006e4:	6822      	ldr	r2, [r4, #0]
 80006e6:	6813      	ldr	r3, [r2, #0]
 80006e8:	f043 0308 	orr.w	r3, r3, #8
 80006ec:	6013      	str	r3, [r2, #0]
 80006ee:	e004      	b.n	80006fa <HAL_CAN_Init+0x1ce>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:280
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 80006f0:	6822      	ldr	r2, [r4, #0]
 80006f2:	6813      	ldr	r3, [r2, #0]
 80006f4:	f023 0308 	bic.w	r3, r3, #8
 80006f8:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:284
    }

    /* Set the transmit FIFO priority */
    if (hcan->Init.TXFP == ENABLE)
 80006fa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80006fc:	2b01      	cmp	r3, #1
 80006fe:	d105      	bne.n	800070c <HAL_CAN_Init+0x1e0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:286
    {
      hcan->Instance->MCR |= CAN_MCR_TXFP;
 8000700:	6822      	ldr	r2, [r4, #0]
 8000702:	6813      	ldr	r3, [r2, #0]
 8000704:	f043 0304 	orr.w	r3, r3, #4
 8000708:	6013      	str	r3, [r2, #0]
 800070a:	e004      	b.n	8000716 <HAL_CAN_Init+0x1ea>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:290
    }
    else
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 800070c:	6822      	ldr	r2, [r4, #0]
 800070e:	6813      	ldr	r3, [r2, #0]
 8000710:	f023 0304 	bic.w	r3, r3, #4
 8000714:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:294
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 8000716:	6821      	ldr	r1, [r4, #0]
 8000718:	68a2      	ldr	r2, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:295
                ((uint32_t)hcan->Init.SJW) | \
 800071a:	68e3      	ldr	r3, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:294
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 800071c:	431a      	orrs	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:296
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 800071e:	6923      	ldr	r3, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:295
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
 8000720:	431a      	orrs	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:297
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 8000722:	6963      	ldr	r3, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:296
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
 8000724:	431a      	orrs	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:298
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);
 8000726:	6863      	ldr	r3, [r4, #4]
 8000728:	3b01      	subs	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:297

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
                ((uint32_t)hcan->Init.SJW) | \
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
 800072a:	4313      	orrs	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:294
    {
      hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
 800072c:	61cb      	str	r3, [r1, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:301
                ((uint32_t)hcan->Init.BS1) | \
                ((uint32_t)hcan->Init.BS2) | \
               ((uint32_t)hcan->Init.Prescaler - 1);

    /* Request leave initialisation */
    hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 800072e:	6822      	ldr	r2, [r4, #0]
 8000730:	6813      	ldr	r3, [r2, #0]
 8000732:	f023 0301 	bic.w	r3, r3, #1
 8000736:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:304

  /* Get tick */
  tickstart = HAL_GetTick();
 8000738:	f005 f856 	bl	80057e8 <HAL_GetTick>
 800073c:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:307

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 800073e:	e00b      	b.n	8000758 <HAL_CAN_Init+0x22c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:309
   {
    if((HAL_GetTick() - tickstart ) > CAN_TIMEOUT_VALUE)
 8000740:	f005 f852 	bl	80057e8 <HAL_GetTick>
 8000744:	1b40      	subs	r0, r0, r5
 8000746:	280a      	cmp	r0, #10
 8000748:	d906      	bls.n	8000758 <HAL_CAN_Init+0x22c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:311
     {
       hcan->State= HAL_CAN_STATE_TIMEOUT;
 800074a:	2003      	movs	r0, #3
 800074c:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:313
       /* Process unlocked */
       __HAL_UNLOCK(hcan);
 8000750:	2300      	movs	r3, #0
 8000752:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:314
       return HAL_TIMEOUT;
 8000756:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:307

  /* Get tick */
  tickstart = HAL_GetTick();

   /* Wait the acknowledge */
   while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 8000758:	6823      	ldr	r3, [r4, #0]
 800075a:	685a      	ldr	r2, [r3, #4]
 800075c:	f012 0f01 	tst.w	r2, #1
 8000760:	d1ee      	bne.n	8000740 <HAL_CAN_Init+0x214>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:319
       return HAL_TIMEOUT;
     }
   }

    /* Check acknowledged */
    if ((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 8000762:	685b      	ldr	r3, [r3, #4]
 8000764:	f013 0f01 	tst.w	r3, #1
 8000768:	d003      	beq.n	8000772 <HAL_CAN_Init+0x246>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:321
    {
      InitStatus = CAN_INITSTATUS_FAILED;
 800076a:	2300      	movs	r3, #0
 800076c:	e002      	b.n	8000774 <HAL_CAN_Init+0x248>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:229
  }

  /* Check acknowledge */
  if ((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
  {
    InitStatus = CAN_INITSTATUS_FAILED;
 800076e:	2300      	movs	r3, #0
 8000770:	e000      	b.n	8000774 <HAL_CAN_Init+0x248>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:325
    {
      InitStatus = CAN_INITSTATUS_FAILED;
    }
    else
    {
      InitStatus = CAN_INITSTATUS_SUCCESS;
 8000772:	2301      	movs	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:329
    }
  }
 
  if(InitStatus == CAN_INITSTATUS_SUCCESS)
 8000774:	b12b      	cbz	r3, 8000782 <HAL_CAN_Init+0x256>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:332
  {
    /* Set CAN error code to none */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000776:	2000      	movs	r0, #0
 8000778:	63e0      	str	r0, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:335
    
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 800077a:	2301      	movs	r3, #1
 800077c:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:338
  
    /* Return function status */
    return HAL_OK;
 8000780:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:343
  }
  else
  {
    /* Initialize the CAN state */
    hcan->State = HAL_CAN_STATE_ERROR;
 8000782:	2304      	movs	r3, #4
 8000784:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:346
    
    /* Return function status */
    return HAL_ERROR;
 8000788:	2001      	movs	r0, #1
 800078a:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:176
  uint32_t tickstart = 0;
  
  /* Check CAN handle */
  if(hcan == NULL)
  {
     return HAL_ERROR;
 800078c:	2001      	movs	r0, #1
 800078e:	4770      	bx	lr
 8000790:	40006400 	.word	0x40006400
 8000794:	0800665c 	.word	0x0800665c

08000798 <HAL_CAN_Receive_IT>:
HAL_CAN_Receive_IT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:904
  *         the configuration information for the specified CAN.  
  * @param  FIFONumber: Specify the FIFO number    
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Receive_IT(CAN_HandleTypeDef* hcan, uint8_t FIFONumber)
{
 8000798:	b538      	push	{r3, r4, r5, lr}
 800079a:	4604      	mov	r4, r0
 800079c:	460d      	mov	r5, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:908
  uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));
 800079e:	2901      	cmp	r1, #1
 80007a0:	d904      	bls.n	80007ac <HAL_CAN_Receive_IT+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:908 (discriminator 1)
 80007a2:	f44f 7163 	mov.w	r1, #908	; 0x38c
 80007a6:	4826      	ldr	r0, [pc, #152]	; (8000840 <HAL_CAN_Receive_IT+0xa8>)
 80007a8:	f001 fce2 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:910
  
  tmp = hcan->State;
 80007ac:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 80007b0:	b2db      	uxtb	r3, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:911
  if((tmp == HAL_CAN_STATE_READY) || (tmp == HAL_CAN_STATE_BUSY_TX))
 80007b2:	2b01      	cmp	r3, #1
 80007b4:	d001      	beq.n	80007ba <HAL_CAN_Receive_IT+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:911 (discriminator 1)
 80007b6:	2b12      	cmp	r3, #18
 80007b8:	d13e      	bne.n	8000838 <HAL_CAN_Receive_IT+0xa0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:914
  {
    /* Process locked */
    __HAL_LOCK(hcan);
 80007ba:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 80007be:	2b01      	cmp	r3, #1
 80007c0:	d03c      	beq.n	800083c <HAL_CAN_Receive_IT+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:914 (discriminator 2)
 80007c2:	2301      	movs	r3, #1
 80007c4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:916 (discriminator 2)
  
    if(hcan->State == HAL_CAN_STATE_BUSY_TX) 
 80007c8:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 80007cc:	b2db      	uxtb	r3, r3
 80007ce:	2b12      	cmp	r3, #18
 80007d0:	d103      	bne.n	80007da <HAL_CAN_Receive_IT+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:919
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
 80007d2:	2332      	movs	r3, #50	; 0x32
 80007d4:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
 80007d8:	e002      	b.n	80007e0 <HAL_CAN_Receive_IT+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:924
    }
    else
    {
      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_BUSY_RX;
 80007da:	2322      	movs	r3, #34	; 0x22
 80007dc:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:928
    }
    
    /* Set CAN error code to none */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 80007e0:	2200      	movs	r2, #0
 80007e2:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:931
    
    /* Enable Error warning Interrupt */
    __HAL_CAN_ENABLE_IT(hcan, CAN_IT_EWG);
 80007e4:	6821      	ldr	r1, [r4, #0]
 80007e6:	694b      	ldr	r3, [r1, #20]
 80007e8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80007ec:	614b      	str	r3, [r1, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:934
      
    /* Enable Error passive Interrupt */
    __HAL_CAN_ENABLE_IT(hcan, CAN_IT_EPV);
 80007ee:	6821      	ldr	r1, [r4, #0]
 80007f0:	694b      	ldr	r3, [r1, #20]
 80007f2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80007f6:	614b      	str	r3, [r1, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:937
      
    /* Enable Bus-off Interrupt */
    __HAL_CAN_ENABLE_IT(hcan, CAN_IT_BOF);
 80007f8:	6821      	ldr	r1, [r4, #0]
 80007fa:	694b      	ldr	r3, [r1, #20]
 80007fc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000800:	614b      	str	r3, [r1, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:940
      
    /* Enable Last error code Interrupt */
    __HAL_CAN_ENABLE_IT(hcan, CAN_IT_LEC);
 8000802:	6821      	ldr	r1, [r4, #0]
 8000804:	694b      	ldr	r3, [r1, #20]
 8000806:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800080a:	614b      	str	r3, [r1, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:943
      
    /* Enable Error Interrupt */
    __HAL_CAN_ENABLE_IT(hcan, CAN_IT_ERR);
 800080c:	6821      	ldr	r1, [r4, #0]
 800080e:	694b      	ldr	r3, [r1, #20]
 8000810:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000814:	614b      	str	r3, [r1, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:946

    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8000816:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:948

    if(FIFONumber == CAN_FIFO0)
 800081a:	b935      	cbnz	r5, 800082a <HAL_CAN_Receive_IT+0x92>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:951
    {
      /* Enable FIFO 0 message pending Interrupt */
      __HAL_CAN_ENABLE_IT(hcan, CAN_IT_FMP0);
 800081c:	6822      	ldr	r2, [r4, #0]
 800081e:	6953      	ldr	r3, [r2, #20]
 8000820:	f043 0302 	orr.w	r3, r3, #2
 8000824:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:966
  {
    return HAL_BUSY;
  }
  
  /* Return function status */
  return HAL_OK;
 8000826:	2000      	movs	r0, #0
 8000828:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:956
      __HAL_CAN_ENABLE_IT(hcan, CAN_IT_FMP0);
    }
    else
    {
      /* Enable FIFO 1 message pending Interrupt */
      __HAL_CAN_ENABLE_IT(hcan, CAN_IT_FMP1);
 800082a:	6822      	ldr	r2, [r4, #0]
 800082c:	6953      	ldr	r3, [r2, #20]
 800082e:	f043 0310 	orr.w	r3, r3, #16
 8000832:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:966
  {
    return HAL_BUSY;
  }
  
  /* Return function status */
  return HAL_OK;
 8000834:	2000      	movs	r0, #0
 8000836:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:962
    }
    
  }
  else
  {
    return HAL_BUSY;
 8000838:	2002      	movs	r0, #2
 800083a:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:914
  
  tmp = hcan->State;
  if((tmp == HAL_CAN_STATE_READY) || (tmp == HAL_CAN_STATE_BUSY_TX))
  {
    /* Process locked */
    __HAL_LOCK(hcan);
 800083c:	2002      	movs	r0, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:967
    return HAL_BUSY;
  }
  
  /* Return function status */
  return HAL_OK;
}
 800083e:	bd38      	pop	{r3, r4, r5, pc}
 8000840:	0800665c 	.word	0x0800665c

08000844 <HAL_CAN_Sleep>:
HAL_CAN_Sleep():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:976
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_CAN_Sleep(CAN_HandleTypeDef* hcan)
{
 8000844:	b538      	push	{r3, r4, r5, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:980
  uint32_t tickstart = 0;
   
  /* Process locked */
  __HAL_LOCK(hcan);
 8000846:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 800084a:	2b01      	cmp	r3, #1
 800084c:	d035      	beq.n	80008ba <HAL_CAN_Sleep+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:980 (discriminator 2)
 800084e:	2301      	movs	r3, #1
 8000850:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:983 (discriminator 2)
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_BUSY; 
 8000854:	2302      	movs	r3, #2
 8000856:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:986 (discriminator 2)
    
  /* Request Sleep mode */
   hcan->Instance->MCR = (((hcan->Instance->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 800085a:	6802      	ldr	r2, [r0, #0]
 800085c:	6813      	ldr	r3, [r2, #0]
 800085e:	f023 0303 	bic.w	r3, r3, #3
 8000862:	f043 0302 	orr.w	r3, r3, #2
 8000866:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:989 (discriminator 2)
   
  /* Sleep mode status */
  if ((hcan->Instance->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) != CAN_MSR_SLAK)
 8000868:	6803      	ldr	r3, [r0, #0]
 800086a:	685b      	ldr	r3, [r3, #4]
 800086c:	f003 0303 	and.w	r3, r3, #3
 8000870:	2b02      	cmp	r3, #2
 8000872:	d004      	beq.n	800087e <HAL_CAN_Sleep+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:992
  {
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8000874:	2300      	movs	r3, #0
 8000876:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:995

    /* Return function status */
    return HAL_ERROR;
 800087a:	2001      	movs	r0, #1
 800087c:	bd38      	pop	{r3, r4, r5, pc}
 800087e:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:999
  }
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
 8000880:	f004 ffb2 	bl	80057e8 <HAL_GetTick>
 8000884:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1002
  
  /* Wait the acknowledge */
  while((hcan->Instance->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) != CAN_MSR_SLAK)
 8000886:	e00b      	b.n	80008a0 <HAL_CAN_Sleep+0x5c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1004
  {
    if((HAL_GetTick()  - tickstart) > CAN_TIMEOUT_VALUE)
 8000888:	f004 ffae 	bl	80057e8 <HAL_GetTick>
 800088c:	1b40      	subs	r0, r0, r5
 800088e:	280a      	cmp	r0, #10
 8000890:	d906      	bls.n	80008a0 <HAL_CAN_Sleep+0x5c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1006
    {
      hcan->State = HAL_CAN_STATE_TIMEOUT;
 8000892:	2003      	movs	r0, #3
 8000894:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1008
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 8000898:	2300      	movs	r3, #0
 800089a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1009
      return HAL_TIMEOUT;
 800089e:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1002
  
  /* Get tick */ 
  tickstart = HAL_GetTick();
  
  /* Wait the acknowledge */
  while((hcan->Instance->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) != CAN_MSR_SLAK)
 80008a0:	6823      	ldr	r3, [r4, #0]
 80008a2:	685b      	ldr	r3, [r3, #4]
 80008a4:	f003 0303 	and.w	r3, r3, #3
 80008a8:	2b02      	cmp	r3, #2
 80008aa:	d1ed      	bne.n	8000888 <HAL_CAN_Sleep+0x44>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1014
      return HAL_TIMEOUT;
    }
  }
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_READY;
 80008ac:	2301      	movs	r3, #1
 80008ae:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1017
  
  /* Process unlocked */
  __HAL_UNLOCK(hcan);
 80008b2:	2000      	movs	r0, #0
 80008b4:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1020
  
  /* Return function status */
  return HAL_OK;
 80008b8:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:980
HAL_StatusTypeDef HAL_CAN_Sleep(CAN_HandleTypeDef* hcan)
{
  uint32_t tickstart = 0;
   
  /* Process locked */
  __HAL_LOCK(hcan);
 80008ba:	2002      	movs	r0, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1021
  /* Process unlocked */
  __HAL_UNLOCK(hcan);
  
  /* Return function status */
  return HAL_OK;
}
 80008bc:	bd38      	pop	{r3, r4, r5, pc}
 80008be:	bf00      	nop

080008c0 <HAL_CAN_WakeUp>:
HAL_CAN_WakeUp():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1031
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef* hcan)
{
 80008c0:	b538      	push	{r3, r4, r5, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1035
  uint32_t tickstart = 0;
    
  /* Process locked */
  __HAL_LOCK(hcan);
 80008c2:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80008c6:	2b01      	cmp	r3, #1
 80008c8:	d030      	beq.n	800092c <HAL_CAN_WakeUp+0x6c>
 80008ca:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1035 (discriminator 2)
 80008cc:	2301      	movs	r3, #1
 80008ce:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1038 (discriminator 2)
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_BUSY;  
 80008d2:	2302      	movs	r3, #2
 80008d4:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1041 (discriminator 2)
 
  /* Wake up request */
  hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
 80008d8:	6802      	ldr	r2, [r0, #0]
 80008da:	6813      	ldr	r3, [r2, #0]
 80008dc:	f023 0302 	bic.w	r3, r3, #2
 80008e0:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1044 (discriminator 2)

  /* Get tick */ 
  tickstart = HAL_GetTick();
 80008e2:	f004 ff81 	bl	80057e8 <HAL_GetTick>
 80008e6:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1047 (discriminator 2)

  /* Sleep mode status */
  while((hcan->Instance->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)
 80008e8:	e00b      	b.n	8000902 <HAL_CAN_WakeUp+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1049
  {
    if((HAL_GetTick()  - tickstart) > CAN_TIMEOUT_VALUE)
 80008ea:	f004 ff7d 	bl	80057e8 <HAL_GetTick>
 80008ee:	1b40      	subs	r0, r0, r5
 80008f0:	280a      	cmp	r0, #10
 80008f2:	d906      	bls.n	8000902 <HAL_CAN_WakeUp+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1051
    {
      hcan->State= HAL_CAN_STATE_TIMEOUT;
 80008f4:	2003      	movs	r0, #3
 80008f6:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1053
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
 80008fa:	2300      	movs	r3, #0
 80008fc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1054
      return HAL_TIMEOUT;
 8000900:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1047

  /* Get tick */ 
  tickstart = HAL_GetTick();

  /* Sleep mode status */
  while((hcan->Instance->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)
 8000902:	6823      	ldr	r3, [r4, #0]
 8000904:	685a      	ldr	r2, [r3, #4]
 8000906:	f012 0f02 	tst.w	r2, #2
 800090a:	d1ee      	bne.n	80008ea <HAL_CAN_WakeUp+0x2a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1057
      /* Process unlocked */
      __HAL_UNLOCK(hcan);
      return HAL_TIMEOUT;
    }
  }
  if((hcan->Instance->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)
 800090c:	685b      	ldr	r3, [r3, #4]
 800090e:	f013 0f02 	tst.w	r3, #2
 8000912:	d004      	beq.n	800091e <HAL_CAN_WakeUp+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1060
  {
    /* Process unlocked */
    __HAL_UNLOCK(hcan);
 8000914:	2300      	movs	r3, #0
 8000916:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1063
 
    /* Return function status */
    return HAL_ERROR;
 800091a:	2001      	movs	r0, #1
 800091c:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1067
  }
  
  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_READY; 
 800091e:	2301      	movs	r3, #1
 8000920:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1070
  
  /* Process unlocked */
  __HAL_UNLOCK(hcan);
 8000924:	2000      	movs	r0, #0
 8000926:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1073
  
  /* Return function status */
  return HAL_OK;
 800092a:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1035
HAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef* hcan)
{
  uint32_t tickstart = 0;
    
  /* Process locked */
  __HAL_LOCK(hcan);
 800092c:	2002      	movs	r0, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1074
  /* Process unlocked */
  __HAL_UNLOCK(hcan);
  
  /* Return function status */
  return HAL_OK;
}
 800092e:	bd38      	pop	{r3, r4, r5, pc}

08000930 <HAL_CAN_TxCpltCallback>:
HAL_CAN_TxCpltCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1211
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxCpltCallback(CAN_HandleTypeDef* hcan)
{
 8000930:	4770      	bx	lr
 8000932:	bf00      	nop

08000934 <CAN_Transmit_IT>:
CAN_Transmit_IT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1296
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.  
  * @retval HAL status
  */
static HAL_StatusTypeDef CAN_Transmit_IT(CAN_HandleTypeDef* hcan)
{
 8000934:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1298
  /* Disable Transmit mailbox empty Interrupt */
  __HAL_CAN_DISABLE_IT(hcan, CAN_IT_TME);
 8000936:	6802      	ldr	r2, [r0, #0]
 8000938:	6953      	ldr	r3, [r2, #20]
 800093a:	f023 0301 	bic.w	r3, r3, #1
 800093e:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1300
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX)
 8000940:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8000944:	b2db      	uxtb	r3, r3
 8000946:	2b12      	cmp	r3, #18
 8000948:	d118      	bne.n	800097c <CAN_Transmit_IT+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1303
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 800094a:	6802      	ldr	r2, [r0, #0]
 800094c:	6953      	ldr	r3, [r2, #20]
 800094e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000952:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1306
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 8000954:	6802      	ldr	r2, [r0, #0]
 8000956:	6953      	ldr	r3, [r2, #20]
 8000958:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800095c:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1309
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 800095e:	6802      	ldr	r2, [r0, #0]
 8000960:	6953      	ldr	r3, [r2, #20]
 8000962:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000966:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1312
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 8000968:	6802      	ldr	r2, [r0, #0]
 800096a:	6953      	ldr	r3, [r2, #20]
 800096c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000970:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1315
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 8000972:	6802      	ldr	r2, [r0, #0]
 8000974:	6953      	ldr	r3, [r2, #20]
 8000976:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800097a:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1318
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 800097c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8000980:	b2db      	uxtb	r3, r3
 8000982:	2b32      	cmp	r3, #50	; 0x32
 8000984:	d103      	bne.n	800098e <CAN_Transmit_IT+0x5a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1321
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_RX;
 8000986:	2322      	movs	r3, #34	; 0x22
 8000988:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
 800098c:	e002      	b.n	8000994 <CAN_Transmit_IT+0x60>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1326
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 800098e:	2301      	movs	r3, #1
 8000990:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1330
  }
  
  /* Transmission complete callback */ 
  HAL_CAN_TxCpltCallback(hcan);
 8000994:	f7ff ffcc 	bl	8000930 <HAL_CAN_TxCpltCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1333
  
  return HAL_OK;
}
 8000998:	2000      	movs	r0, #0
 800099a:	bd08      	pop	{r3, pc}

0800099c <CAN_Receive_IT>:
CAN_Receive_IT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1344
  * @param  FIFONumber: Specify the FIFO number    
  * @retval HAL status
  * @retval None
  */
static HAL_StatusTypeDef CAN_Receive_IT(CAN_HandleTypeDef* hcan, uint8_t FIFONumber)
{
 800099c:	b510      	push	{r4, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1346
  /* Get the Id */
  hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 800099e:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80009a0:	6804      	ldr	r4, [r0, #0]
 80009a2:	f101 031b 	add.w	r3, r1, #27
 80009a6:	011b      	lsls	r3, r3, #4
 80009a8:	58e3      	ldr	r3, [r4, r3]
 80009aa:	f003 0304 	and.w	r3, r3, #4
 80009ae:	6093      	str	r3, [r2, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1347
  if (hcan->pRxMsg->IDE == CAN_ID_STD)
 80009b0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80009b2:	689a      	ldr	r2, [r3, #8]
 80009b4:	b93a      	cbnz	r2, 80009c6 <CAN_Receive_IT+0x2a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1349
  {
    hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
 80009b6:	6804      	ldr	r4, [r0, #0]
 80009b8:	f101 021b 	add.w	r2, r1, #27
 80009bc:	0112      	lsls	r2, r2, #4
 80009be:	58a2      	ldr	r2, [r4, r2]
 80009c0:	0d52      	lsrs	r2, r2, #21
 80009c2:	601a      	str	r2, [r3, #0]
 80009c4:	e006      	b.n	80009d4 <CAN_Receive_IT+0x38>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1353
  }
  else
  {
    hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
 80009c6:	6804      	ldr	r4, [r0, #0]
 80009c8:	f101 021b 	add.w	r2, r1, #27
 80009cc:	0112      	lsls	r2, r2, #4
 80009ce:	58a2      	ldr	r2, [r4, r2]
 80009d0:	08d2      	lsrs	r2, r2, #3
 80009d2:	605a      	str	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1356
  }
  
  hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
 80009d4:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80009d6:	6802      	ldr	r2, [r0, #0]
 80009d8:	f101 031b 	add.w	r3, r1, #27
 80009dc:	011b      	lsls	r3, r3, #4
 80009de:	58d2      	ldr	r2, [r2, r3]
 80009e0:	f002 0202 	and.w	r2, r2, #2
 80009e4:	60e2      	str	r2, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1358
  /* Get the DLC */
  hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
 80009e6:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80009e8:	6802      	ldr	r2, [r0, #0]
 80009ea:	441a      	add	r2, r3
 80009ec:	6852      	ldr	r2, [r2, #4]
 80009ee:	f002 020f 	and.w	r2, r2, #15
 80009f2:	6122      	str	r2, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1360
  /* Get the FMI */
  hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
 80009f4:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80009f6:	6804      	ldr	r4, [r0, #0]
 80009f8:	4423      	add	r3, r4
 80009fa:	685b      	ldr	r3, [r3, #4]
 80009fc:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8000a00:	61d3      	str	r3, [r2, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1362
  /* Get the data field */
  hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
 8000a02:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8000a04:	6802      	ldr	r2, [r0, #0]
 8000a06:	010b      	lsls	r3, r1, #4
 8000a08:	441a      	add	r2, r3
 8000a0a:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000a0e:	7522      	strb	r2, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1363
  hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8000a10:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8000a12:	6802      	ldr	r2, [r0, #0]
 8000a14:	441a      	add	r2, r3
 8000a16:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000a1a:	0a12      	lsrs	r2, r2, #8
 8000a1c:	7562      	strb	r2, [r4, #21]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1364
  hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
 8000a1e:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8000a20:	6802      	ldr	r2, [r0, #0]
 8000a22:	441a      	add	r2, r3
 8000a24:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000a28:	0c12      	lsrs	r2, r2, #16
 8000a2a:	75a2      	strb	r2, [r4, #22]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1365
  hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8000a2c:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8000a2e:	6802      	ldr	r2, [r0, #0]
 8000a30:	441a      	add	r2, r3
 8000a32:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000a36:	0e12      	lsrs	r2, r2, #24
 8000a38:	75e2      	strb	r2, [r4, #23]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1366
  hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
 8000a3a:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8000a3c:	6802      	ldr	r2, [r0, #0]
 8000a3e:	441a      	add	r2, r3
 8000a40:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 8000a44:	7622      	strb	r2, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1367
  hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
 8000a46:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8000a48:	6802      	ldr	r2, [r0, #0]
 8000a4a:	441a      	add	r2, r3
 8000a4c:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 8000a50:	0a12      	lsrs	r2, r2, #8
 8000a52:	7662      	strb	r2, [r4, #25]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1368
  hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8000a54:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8000a56:	6802      	ldr	r2, [r0, #0]
 8000a58:	441a      	add	r2, r3
 8000a5a:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 8000a5e:	0c12      	lsrs	r2, r2, #16
 8000a60:	76a2      	strb	r2, [r4, #26]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1369
  hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
 8000a62:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8000a64:	6804      	ldr	r4, [r0, #0]
 8000a66:	4423      	add	r3, r4
 8000a68:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 8000a6c:	0e1b      	lsrs	r3, r3, #24
 8000a6e:	76d3      	strb	r3, [r2, #27]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1372
  /* Release the FIFO */
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 8000a70:	b951      	cbnz	r1, 8000a88 <CAN_Receive_IT+0xec>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1374
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
 8000a72:	6802      	ldr	r2, [r0, #0]
 8000a74:	68d3      	ldr	r3, [r2, #12]
 8000a76:	f043 0320 	orr.w	r3, r3, #32
 8000a7a:	60d3      	str	r3, [r2, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1377
    
    /* Disable FIFO 0 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP0);
 8000a7c:	6802      	ldr	r2, [r0, #0]
 8000a7e:	6953      	ldr	r3, [r2, #20]
 8000a80:	f023 0302 	bic.w	r3, r3, #2
 8000a84:	6153      	str	r3, [r2, #20]
 8000a86:	e009      	b.n	8000a9c <CAN_Receive_IT+0x100>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1382
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
 8000a88:	6802      	ldr	r2, [r0, #0]
 8000a8a:	6913      	ldr	r3, [r2, #16]
 8000a8c:	f043 0320 	orr.w	r3, r3, #32
 8000a90:	6113      	str	r3, [r2, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1385
    
    /* Disable FIFO 1 message pending Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP1);
 8000a92:	6802      	ldr	r2, [r0, #0]
 8000a94:	6953      	ldr	r3, [r2, #20]
 8000a96:	f023 0310 	bic.w	r3, r3, #16
 8000a9a:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1388
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_RX)
 8000a9c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8000aa0:	b2db      	uxtb	r3, r3
 8000aa2:	2b22      	cmp	r3, #34	; 0x22
 8000aa4:	d118      	bne.n	8000ad8 <CAN_Receive_IT+0x13c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1391
  {   
    /* Disable Error warning Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
 8000aa6:	6802      	ldr	r2, [r0, #0]
 8000aa8:	6953      	ldr	r3, [r2, #20]
 8000aaa:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000aae:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1394
    
    /* Disable Error passive Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
 8000ab0:	6802      	ldr	r2, [r0, #0]
 8000ab2:	6953      	ldr	r3, [r2, #20]
 8000ab4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000ab8:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1397
    
    /* Disable Bus-off Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
 8000aba:	6802      	ldr	r2, [r0, #0]
 8000abc:	6953      	ldr	r3, [r2, #20]
 8000abe:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000ac2:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1400
    
    /* Disable Last error code Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
 8000ac4:	6802      	ldr	r2, [r0, #0]
 8000ac6:	6953      	ldr	r3, [r2, #20]
 8000ac8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000acc:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1403
    
    /* Disable Error Interrupt */
    __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
 8000ace:	6802      	ldr	r2, [r0, #0]
 8000ad0:	6953      	ldr	r3, [r2, #20]
 8000ad2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000ad6:	6153      	str	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1406
  }
  
  if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
 8000ad8:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8000adc:	b2db      	uxtb	r3, r3
 8000ade:	2b32      	cmp	r3, #50	; 0x32
 8000ae0:	d103      	bne.n	8000aea <CAN_Receive_IT+0x14e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1409
  {
    /* Disable CAN state */
    hcan->State = HAL_CAN_STATE_BUSY_TX;
 8000ae2:	2312      	movs	r3, #18
 8000ae4:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
 8000ae8:	e002      	b.n	8000af0 <CAN_Receive_IT+0x154>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1414
  }
  else
  {
    /* Change CAN state */
    hcan->State = HAL_CAN_STATE_READY;
 8000aea:	2301      	movs	r3, #1
 8000aec:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1418
  }

  /* Receive complete callback */ 
  HAL_CAN_RxCpltCallback(hcan);
 8000af0:	f001 fc18 	bl	8002324 <HAL_CAN_RxCpltCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1422

  /* Return function status */
  return HAL_OK;
}
 8000af4:	2000      	movs	r0, #0
 8000af6:	bd10      	pop	{r4, pc}

08000af8 <HAL_CAN_ErrorCallback>:
HAL_CAN_ErrorCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1237
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
{
 8000af8:	4770      	bx	lr
 8000afa:	bf00      	nop

08000afc <HAL_CAN_IRQHandler>:
HAL_CAN_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1083
  * @param  hcan: pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
void HAL_CAN_IRQHandler(CAN_HandleTypeDef* hcan)
{
 8000afc:	b510      	push	{r4, lr}
 8000afe:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1087
  uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
  
  /* Check End of transmission flag */
  if(__HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_TME))
 8000b00:	6803      	ldr	r3, [r0, #0]
 8000b02:	695a      	ldr	r2, [r3, #20]
 8000b04:	f012 0f01 	tst.w	r2, #1
 8000b08:	d016      	beq.n	8000b38 <HAL_CAN_IRQHandler+0x3c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1089
  {
    tmp1 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_0);
 8000b0a:	6898      	ldr	r0, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1090
    tmp2 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_1);
 8000b0c:	6899      	ldr	r1, [r3, #8]
 8000b0e:	4a5b      	ldr	r2, [pc, #364]	; (8000c7c <HAL_CAN_IRQHandler+0x180>)
 8000b10:	400a      	ands	r2, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1091
    tmp3 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_2);
 8000b12:	689b      	ldr	r3, [r3, #8]
 8000b14:	f023 436f 	bic.w	r3, r3, #4009754624	; 0xef000000
 8000b18:	f423 037c 	bic.w	r3, r3, #16515072	; 0xfc0000
 8000b1c:	0c1b      	lsrs	r3, r3, #16
 8000b1e:	041b      	lsls	r3, r3, #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1092
    if(tmp1 || tmp2 || tmp3)  
 8000b20:	4957      	ldr	r1, [pc, #348]	; (8000c80 <HAL_CAN_IRQHandler+0x184>)
 8000b22:	4381      	bics	r1, r0
 8000b24:	d005      	beq.n	8000b32 <HAL_CAN_IRQHandler+0x36>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1092 (discriminator 1)
 8000b26:	4955      	ldr	r1, [pc, #340]	; (8000c7c <HAL_CAN_IRQHandler+0x180>)
 8000b28:	428a      	cmp	r2, r1
 8000b2a:	d002      	beq.n	8000b32 <HAL_CAN_IRQHandler+0x36>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1092 (discriminator 2)
 8000b2c:	4a55      	ldr	r2, [pc, #340]	; (8000c84 <HAL_CAN_IRQHandler+0x188>)
 8000b2e:	4293      	cmp	r3, r2
 8000b30:	d102      	bne.n	8000b38 <HAL_CAN_IRQHandler+0x3c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1095
    {
      /* Call transmit function */
      CAN_Transmit_IT(hcan);
 8000b32:	4620      	mov	r0, r4
 8000b34:	f7ff fefe 	bl	8000934 <CAN_Transmit_IT>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1099
    }
  }
  
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO0);
 8000b38:	6823      	ldr	r3, [r4, #0]
 8000b3a:	68da      	ldr	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1100
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP0);
 8000b3c:	695b      	ldr	r3, [r3, #20]
 8000b3e:	f003 0302 	and.w	r3, r3, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1102
  /* Check End of reception flag for FIFO0 */
  if((tmp1 != 0) && tmp2)
 8000b42:	f012 0f03 	tst.w	r2, #3
 8000b46:	d004      	beq.n	8000b52 <HAL_CAN_IRQHandler+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1102 (discriminator 1)
 8000b48:	b11b      	cbz	r3, 8000b52 <HAL_CAN_IRQHandler+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1105
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO0);
 8000b4a:	2100      	movs	r1, #0
 8000b4c:	4620      	mov	r0, r4
 8000b4e:	f7ff ff25 	bl	800099c <CAN_Receive_IT>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1108
  }
  
  tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO1);
 8000b52:	6823      	ldr	r3, [r4, #0]
 8000b54:	691a      	ldr	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1109
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP1);
 8000b56:	695b      	ldr	r3, [r3, #20]
 8000b58:	f003 0310 	and.w	r3, r3, #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1111
  /* Check End of reception flag for FIFO1 */
  if((tmp1 != 0) && tmp2)
 8000b5c:	f012 0f03 	tst.w	r2, #3
 8000b60:	d004      	beq.n	8000b6c <HAL_CAN_IRQHandler+0x70>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1111 (discriminator 1)
 8000b62:	b11b      	cbz	r3, 8000b6c <HAL_CAN_IRQHandler+0x70>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1114
  {
    /* Call receive function */
    CAN_Receive_IT(hcan, CAN_FIFO1);
 8000b64:	2101      	movs	r1, #1
 8000b66:	4620      	mov	r0, r4
 8000b68:	f7ff ff18 	bl	800099c <CAN_Receive_IT>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1117
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EWG);
 8000b6c:	6823      	ldr	r3, [r4, #0]
 8000b6e:	6998      	ldr	r0, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1118
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EWG);
 8000b70:	695a      	ldr	r2, [r3, #20]
 8000b72:	f402 7280 	and.w	r2, r2, #256	; 0x100
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1119
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 8000b76:	6959      	ldr	r1, [r3, #20]
 8000b78:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1121
  /* Check Error Warning Flag */
  if(tmp1 && tmp2 && tmp3)
 8000b7c:	f010 0f01 	tst.w	r0, #1
 8000b80:	d008      	beq.n	8000b94 <HAL_CAN_IRQHandler+0x98>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1121 (discriminator 1)
 8000b82:	b13a      	cbz	r2, 8000b94 <HAL_CAN_IRQHandler+0x98>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1121 (discriminator 2)
 8000b84:	b131      	cbz	r1, 8000b94 <HAL_CAN_IRQHandler+0x98>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1124
  {
    /* Set CAN error code to EWG error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EWG;
 8000b86:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000b88:	f042 0201 	orr.w	r2, r2, #1
 8000b8c:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1126
    /* Clear Error Warning Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EWG);
 8000b8e:	f06f 0201 	mvn.w	r2, #1
 8000b92:	619a      	str	r2, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1129
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EPV);
 8000b94:	6823      	ldr	r3, [r4, #0]
 8000b96:	6998      	ldr	r0, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1130
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EPV);
 8000b98:	695a      	ldr	r2, [r3, #20]
 8000b9a:	f402 7200 	and.w	r2, r2, #512	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1131
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR); 
 8000b9e:	6959      	ldr	r1, [r3, #20]
 8000ba0:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1133
  /* Check Error Passive Flag */
  if(tmp1 && tmp2 && tmp3)
 8000ba4:	f010 0f02 	tst.w	r0, #2
 8000ba8:	d008      	beq.n	8000bbc <HAL_CAN_IRQHandler+0xc0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1133 (discriminator 1)
 8000baa:	b13a      	cbz	r2, 8000bbc <HAL_CAN_IRQHandler+0xc0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1133 (discriminator 2)
 8000bac:	b131      	cbz	r1, 8000bbc <HAL_CAN_IRQHandler+0xc0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1136
  {
    /* Set CAN error code to EPV error */
    hcan->ErrorCode |= HAL_CAN_ERROR_EPV;
 8000bae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000bb0:	f042 0202 	orr.w	r2, r2, #2
 8000bb4:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1138
    /* Clear Error Passive Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EPV);
 8000bb6:	f06f 0202 	mvn.w	r2, #2
 8000bba:	619a      	str	r2, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1141
  }
  
  tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_BOF);
 8000bbc:	6823      	ldr	r3, [r4, #0]
 8000bbe:	6998      	ldr	r0, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1142
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_BOF);
 8000bc0:	695a      	ldr	r2, [r3, #20]
 8000bc2:	f402 6280 	and.w	r2, r2, #1024	; 0x400
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1143
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);  
 8000bc6:	6959      	ldr	r1, [r3, #20]
 8000bc8:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1145
  /* Check Bus-Off Flag */
  if(tmp1 && tmp2 && tmp3)
 8000bcc:	f010 0f04 	tst.w	r0, #4
 8000bd0:	d008      	beq.n	8000be4 <HAL_CAN_IRQHandler+0xe8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1145 (discriminator 1)
 8000bd2:	b13a      	cbz	r2, 8000be4 <HAL_CAN_IRQHandler+0xe8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1145 (discriminator 2)
 8000bd4:	b131      	cbz	r1, 8000be4 <HAL_CAN_IRQHandler+0xe8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1148
  {
    /* Set CAN error code to BOF error */
    hcan->ErrorCode |= HAL_CAN_ERROR_BOF;
 8000bd6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000bd8:	f042 0204 	orr.w	r2, r2, #4
 8000bdc:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1150
    /* Clear Bus-Off Flag */ 
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_BOF);
 8000bde:	f06f 0204 	mvn.w	r2, #4
 8000be2:	619a      	str	r2, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1153
  }
  
  tmp1 = HAL_IS_BIT_CLR(hcan->Instance->ESR, CAN_ESR_LEC);
 8000be4:	6823      	ldr	r3, [r4, #0]
 8000be6:	6998      	ldr	r0, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1154
  tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_LEC);
 8000be8:	695a      	ldr	r2, [r3, #20]
 8000bea:	f402 6200 	and.w	r2, r2, #2048	; 0x800
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1155
  tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
 8000bee:	6959      	ldr	r1, [r3, #20]
 8000bf0:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1157
  /* Check Last error code Flag */
  if((!tmp1) && tmp2 && tmp3)
 8000bf4:	f010 0f70 	tst.w	r0, #112	; 0x70
 8000bf8:	d036      	beq.n	8000c68 <HAL_CAN_IRQHandler+0x16c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1157 (discriminator 1)
 8000bfa:	2a00      	cmp	r2, #0
 8000bfc:	d034      	beq.n	8000c68 <HAL_CAN_IRQHandler+0x16c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1157 (discriminator 2)
 8000bfe:	2900      	cmp	r1, #0
 8000c00:	d032      	beq.n	8000c68 <HAL_CAN_IRQHandler+0x16c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1159
  {
    tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
 8000c02:	699a      	ldr	r2, [r3, #24]
 8000c04:	f002 0270 	and.w	r2, r2, #112	; 0x70
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1160
    switch(tmp1)
 8000c08:	2a30      	cmp	r2, #48	; 0x30
 8000c0a:	d016      	beq.n	8000c3a <HAL_CAN_IRQHandler+0x13e>
 8000c0c:	d804      	bhi.n	8000c18 <HAL_CAN_IRQHandler+0x11c>
 8000c0e:	2a10      	cmp	r2, #16
 8000c10:	d009      	beq.n	8000c26 <HAL_CAN_IRQHandler+0x12a>
 8000c12:	2a20      	cmp	r2, #32
 8000c14:	d00c      	beq.n	8000c30 <HAL_CAN_IRQHandler+0x134>
 8000c16:	e023      	b.n	8000c60 <HAL_CAN_IRQHandler+0x164>
 8000c18:	2a50      	cmp	r2, #80	; 0x50
 8000c1a:	d018      	beq.n	8000c4e <HAL_CAN_IRQHandler+0x152>
 8000c1c:	2a60      	cmp	r2, #96	; 0x60
 8000c1e:	d01b      	beq.n	8000c58 <HAL_CAN_IRQHandler+0x15c>
 8000c20:	2a40      	cmp	r2, #64	; 0x40
 8000c22:	d11d      	bne.n	8000c60 <HAL_CAN_IRQHandler+0x164>
 8000c24:	e00e      	b.n	8000c44 <HAL_CAN_IRQHandler+0x148>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1164
    {
      case(CAN_ESR_LEC_0):
          /* Set CAN error code to STF error */
          hcan->ErrorCode |= HAL_CAN_ERROR_STF;
 8000c26:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000c28:	f042 0208 	orr.w	r2, r2, #8
 8000c2c:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1165
          break;
 8000c2e:	e017      	b.n	8000c60 <HAL_CAN_IRQHandler+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1168
      case(CAN_ESR_LEC_1):
          /* Set CAN error code to FOR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_FOR;
 8000c30:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000c32:	f042 0210 	orr.w	r2, r2, #16
 8000c36:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1169
          break;
 8000c38:	e012      	b.n	8000c60 <HAL_CAN_IRQHandler+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1172
      case(CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
          /* Set CAN error code to ACK error */
          hcan->ErrorCode |= HAL_CAN_ERROR_ACK;
 8000c3a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000c3c:	f042 0220 	orr.w	r2, r2, #32
 8000c40:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1173
          break;
 8000c42:	e00d      	b.n	8000c60 <HAL_CAN_IRQHandler+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1176
      case(CAN_ESR_LEC_2):
          /* Set CAN error code to BR error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BR;
 8000c44:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000c46:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000c4a:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1177
          break;
 8000c4c:	e008      	b.n	8000c60 <HAL_CAN_IRQHandler+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1180
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
          /* Set CAN error code to BD error */
          hcan->ErrorCode |= HAL_CAN_ERROR_BD;
 8000c4e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000c50:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000c54:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1181
          break;
 8000c56:	e003      	b.n	8000c60 <HAL_CAN_IRQHandler+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1184
      case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
          /* Set CAN error code to CRC error */
          hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
 8000c58:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000c5a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000c5e:	63e2      	str	r2, [r4, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1191
      default:
          break;
    }

    /* Clear Last error code Flag */ 
    hcan->Instance->ESR &= ~(CAN_ESR_LEC);
 8000c60:	699a      	ldr	r2, [r3, #24]
 8000c62:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8000c66:	619a      	str	r2, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1195
  }
  
  /* Call the Error call Back in case of Errors */
  if(hcan->ErrorCode != HAL_CAN_ERROR_NONE)
 8000c68:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000c6a:	b12b      	cbz	r3, 8000c78 <HAL_CAN_IRQHandler+0x17c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1198
  {
    /* Set the CAN state ready to be able to start again the process */
    hcan->State = HAL_CAN_STATE_READY;
 8000c6c:	2301      	movs	r3, #1
 8000c6e:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_can.c:1200
    /* Call Error callback function */
    HAL_CAN_ErrorCallback(hcan);
 8000c72:	4620      	mov	r0, r4
 8000c74:	f7ff ff40 	bl	8000af8 <HAL_CAN_ErrorCallback>
 8000c78:	bd10      	pop	{r4, pc}
 8000c7a:	bf00      	nop
 8000c7c:	08000300 	.word	0x08000300
 8000c80:	04000003 	.word	0x04000003
 8000c84:	10030000 	.word	0x10030000

08000c88 <HAL_NVIC_SetPriorityGrouping>:
HAL_NVIC_SetPriorityGrouping():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:162
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000c88:	b510      	push	{r4, lr}
 8000c8a:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:164
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 8000c8c:	1ec3      	subs	r3, r0, #3
 8000c8e:	2b04      	cmp	r3, #4
 8000c90:	d903      	bls.n	8000c9a <HAL_NVIC_SetPriorityGrouping+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:164 (discriminator 1)
 8000c92:	21a4      	movs	r1, #164	; 0xa4
 8000c94:	4809      	ldr	r0, [pc, #36]	; (8000cbc <HAL_NVIC_SetPriorityGrouping+0x34>)
 8000c96:	f001 fa6b 	bl	8002170 <assert_failed>
NVIC_SetPriorityGrouping():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1607
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000c9a:	f004 0007 	and.w	r0, r4, #7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1609

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000c9e:	4a08      	ldr	r2, [pc, #32]	; (8000cc0 <HAL_NVIC_SetPriorityGrouping+0x38>)
 8000ca0:	68d3      	ldr	r3, [r2, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1610
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000ca2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000ca6:	041b      	lsls	r3, r3, #16
 8000ca8:	0c1b      	lsrs	r3, r3, #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1612
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000caa:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1611
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000cae:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000cb2:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1614
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000cb6:	60d0      	str	r0, [r2, #12]
 8000cb8:	bd10      	pop	{r4, pc}
 8000cba:	bf00      	nop
 8000cbc:	0800668c 	.word	0x0800668c
 8000cc0:	e000ed00 	.word	0xe000ed00

08000cc4 <HAL_NVIC_SetPriority>:
HAL_NVIC_SetPriority():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:184
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000cc4:	b570      	push	{r4, r5, r6, lr}
 8000cc6:	4604      	mov	r4, r0
 8000cc8:	460e      	mov	r6, r1
 8000cca:	4615      	mov	r5, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:188
  uint32_t prioritygroup = 0x00;
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 8000ccc:	2a0f      	cmp	r2, #15
 8000cce:	d903      	bls.n	8000cd8 <HAL_NVIC_SetPriority+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:188 (discriminator 1)
 8000cd0:	21bc      	movs	r1, #188	; 0xbc
 8000cd2:	481a      	ldr	r0, [pc, #104]	; (8000d3c <HAL_NVIC_SetPriority+0x78>)
 8000cd4:	f001 fa4c 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:189
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8000cd8:	2e0f      	cmp	r6, #15
 8000cda:	d903      	bls.n	8000ce4 <HAL_NVIC_SetPriority+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:189 (discriminator 1)
 8000cdc:	21bd      	movs	r1, #189	; 0xbd
 8000cde:	4817      	ldr	r0, [pc, #92]	; (8000d3c <HAL_NVIC_SetPriority+0x78>)
 8000ce0:	f001 fa46 	bl	8002170 <assert_failed>
NVIC_GetPriorityGrouping():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1625
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000ce4:	4b16      	ldr	r3, [pc, #88]	; (8000d40 <HAL_NVIC_SetPriority+0x7c>)
 8000ce6:	68da      	ldr	r2, [r3, #12]
NVIC_EncodePriority():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1755
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000ce8:	f3c2 2202 	ubfx	r2, r2, #8, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1759
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000cec:	f1c2 0107 	rsb	r1, r2, #7
 8000cf0:	2904      	cmp	r1, #4
 8000cf2:	bf28      	it	cs
 8000cf4:	2104      	movcs	r1, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1760
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000cf6:	1d13      	adds	r3, r2, #4
 8000cf8:	2b06      	cmp	r3, #6
 8000cfa:	d901      	bls.n	8000d00 <HAL_NVIC_SetPriority+0x3c>
 8000cfc:	3a03      	subs	r2, #3
 8000cfe:	e000      	b.n	8000d02 <HAL_NVIC_SetPriority+0x3e>
 8000d00:	2200      	movs	r2, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1763

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000d02:	2301      	movs	r3, #1
 8000d04:	fa03 f101 	lsl.w	r1, r3, r1
 8000d08:	3901      	subs	r1, #1
 8000d0a:	4031      	ands	r1, r6
 8000d0c:	4091      	lsls	r1, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1764
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000d0e:	fa03 f202 	lsl.w	r2, r3, r2
 8000d12:	3a01      	subs	r2, #1
 8000d14:	402a      	ands	r2, r5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1762
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000d16:	430a      	orrs	r2, r1
NVIC_SetPriority():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1708
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000d18:	2c00      	cmp	r4, #0
 8000d1a:	da06      	bge.n	8000d2a <HAL_NVIC_SetPriority+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1710
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d1c:	f004 040f 	and.w	r4, r4, #15
 8000d20:	0112      	lsls	r2, r2, #4
 8000d22:	b2d2      	uxtb	r2, r2
 8000d24:	4b07      	ldr	r3, [pc, #28]	; (8000d44 <HAL_NVIC_SetPriority+0x80>)
 8000d26:	551a      	strb	r2, [r3, r4]
 8000d28:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1714
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d2a:	0112      	lsls	r2, r2, #4
 8000d2c:	b2d2      	uxtb	r2, r2
 8000d2e:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 8000d32:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8000d36:	f884 2300 	strb.w	r2, [r4, #768]	; 0x300
 8000d3a:	bd70      	pop	{r4, r5, r6, pc}
 8000d3c:	0800668c 	.word	0x0800668c
 8000d40:	e000ed00 	.word	0xe000ed00
 8000d44:	e000ed14 	.word	0xe000ed14

08000d48 <HAL_NVIC_EnableIRQ>:
HAL_NVIC_EnableIRQ():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:206
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8000d48:	b510      	push	{r4, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:208
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8000d4a:	1e04      	subs	r4, r0, #0
 8000d4c:	da03      	bge.n	8000d56 <HAL_NVIC_EnableIRQ+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:208 (discriminator 1)
 8000d4e:	21d0      	movs	r1, #208	; 0xd0
 8000d50:	4806      	ldr	r0, [pc, #24]	; (8000d6c <HAL_NVIC_EnableIRQ+0x24>)
 8000d52:	f001 fa0d 	bl	8002170 <assert_failed>
NVIC_EnableIRQ():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1636
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000d56:	0962      	lsrs	r2, r4, #5
 8000d58:	f004 041f 	and.w	r4, r4, #31
 8000d5c:	2301      	movs	r3, #1
 8000d5e:	fa03 f404 	lsl.w	r4, r3, r4
 8000d62:	4b03      	ldr	r3, [pc, #12]	; (8000d70 <HAL_NVIC_EnableIRQ+0x28>)
 8000d64:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 8000d68:	bd10      	pop	{r4, pc}
 8000d6a:	bf00      	nop
 8000d6c:	0800668c 	.word	0x0800668c
 8000d70:	e000e100 	.word	0xe000e100

08000d74 <HAL_NVIC_DisableIRQ>:
HAL_NVIC_DisableIRQ():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:222
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8000d74:	b510      	push	{r4, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:224
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8000d76:	1e04      	subs	r4, r0, #0
 8000d78:	da03      	bge.n	8000d82 <HAL_NVIC_DisableIRQ+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:224 (discriminator 1)
 8000d7a:	21e0      	movs	r1, #224	; 0xe0
 8000d7c:	4806      	ldr	r0, [pc, #24]	; (8000d98 <HAL_NVIC_DisableIRQ+0x24>)
 8000d7e:	f001 f9f7 	bl	8002170 <assert_failed>
NVIC_DisableIRQ():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1647
  \details Disables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000d82:	0963      	lsrs	r3, r4, #5
 8000d84:	f004 041f 	and.w	r4, r4, #31
 8000d88:	2201      	movs	r2, #1
 8000d8a:	fa02 f404 	lsl.w	r4, r2, r4
 8000d8e:	3320      	adds	r3, #32
 8000d90:	4a02      	ldr	r2, [pc, #8]	; (8000d9c <HAL_NVIC_DisableIRQ+0x28>)
 8000d92:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
 8000d96:	bd10      	pop	{r4, pc}
 8000d98:	0800668c 	.word	0x0800668c
 8000d9c:	e000e100 	.word	0xe000e100

08000da0 <HAL_SYSTICK_Config>:
SysTick_Config():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1840
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000da0:	3801      	subs	r0, #1
 8000da2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000da6:	d20a      	bcs.n	8000dbe <HAL_SYSTICK_Config+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1845
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000da8:	4b06      	ldr	r3, [pc, #24]	; (8000dc4 <HAL_SYSTICK_Config+0x24>)
 8000daa:	6058      	str	r0, [r3, #4]
NVIC_SetPriority():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1710
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000dac:	21f0      	movs	r1, #240	; 0xf0
 8000dae:	4a06      	ldr	r2, [pc, #24]	; (8000dc8 <HAL_SYSTICK_Config+0x28>)
 8000db0:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
SysTick_Config():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1847
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000db4:	2000      	movs	r0, #0
 8000db6:	6098      	str	r0, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1848
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000db8:	2207      	movs	r2, #7
 8000dba:	601a      	str	r2, [r3, #0]
 8000dbc:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1842
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8000dbe:	2001      	movs	r0, #1
HAL_SYSTICK_Config():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:250
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000dc0:	4770      	bx	lr
 8000dc2:	bf00      	nop
 8000dc4:	e000e010 	.word	0xe000e010
 8000dc8:	e000ed00 	.word	0xe000ed00

08000dcc <HAL_NVIC_ClearPendingIRQ>:
HAL_NVIC_ClearPendingIRQ():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:399
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 8000dcc:	b510      	push	{r4, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:401
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8000dce:	1e04      	subs	r4, r0, #0
 8000dd0:	da04      	bge.n	8000ddc <HAL_NVIC_ClearPendingIRQ+0x10>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:401 (discriminator 1)
 8000dd2:	f240 1191 	movw	r1, #401	; 0x191
 8000dd6:	4807      	ldr	r0, [pc, #28]	; (8000df4 <HAL_NVIC_ClearPendingIRQ+0x28>)
 8000dd8:	f001 f9ca 	bl	8002170 <assert_failed>
NVIC_ClearPendingIRQ():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1682
  \details Clears the pending bit of an external interrupt.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000ddc:	0963      	lsrs	r3, r4, #5
 8000dde:	f004 041f 	and.w	r4, r4, #31
 8000de2:	2201      	movs	r2, #1
 8000de4:	fa02 f404 	lsl.w	r4, r2, r4
 8000de8:	3360      	adds	r3, #96	; 0x60
 8000dea:	4a03      	ldr	r2, [pc, #12]	; (8000df8 <HAL_NVIC_ClearPendingIRQ+0x2c>)
 8000dec:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
 8000df0:	bd10      	pop	{r4, pc}
 8000df2:	bf00      	nop
 8000df4:	0800668c 	.word	0x0800668c
 8000df8:	e000e100 	.word	0xe000e100

08000dfc <HAL_SYSTICK_CLKSourceConfig>:
HAL_SYSTICK_CLKSourceConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:433
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000dfc:	b510      	push	{r4, lr}
 8000dfe:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:435
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
 8000e00:	2804      	cmp	r0, #4
 8000e02:	d005      	beq.n	8000e10 <HAL_SYSTICK_CLKSourceConfig+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:435 (discriminator 1)
 8000e04:	b120      	cbz	r0, 8000e10 <HAL_SYSTICK_CLKSourceConfig+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:435 (discriminator 2)
 8000e06:	f240 11b3 	movw	r1, #435	; 0x1b3
 8000e0a:	4808      	ldr	r0, [pc, #32]	; (8000e2c <HAL_SYSTICK_CLKSourceConfig+0x30>)
 8000e0c:	f001 f9b0 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:436
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000e10:	2c04      	cmp	r4, #4
 8000e12:	d105      	bne.n	8000e20 <HAL_SYSTICK_CLKSourceConfig+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:438
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000e14:	4a06      	ldr	r2, [pc, #24]	; (8000e30 <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8000e16:	6813      	ldr	r3, [r2, #0]
 8000e18:	f043 0304 	orr.w	r3, r3, #4
 8000e1c:	6013      	str	r3, [r2, #0]
 8000e1e:	bd10      	pop	{r4, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:442
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000e20:	4a03      	ldr	r2, [pc, #12]	; (8000e30 <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8000e22:	6813      	ldr	r3, [r2, #0]
 8000e24:	f023 0304 	bic.w	r3, r3, #4
 8000e28:	6013      	str	r3, [r2, #0]
 8000e2a:	bd10      	pop	{r4, pc}
 8000e2c:	0800668c 	.word	0x0800668c
 8000e30:	e000e010 	.word	0xe000e010

08000e34 <HAL_SYSTICK_Callback>:
HAL_SYSTICK_Callback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:460
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000e34:	4770      	bx	lr
 8000e36:	bf00      	nop

08000e38 <HAL_SYSTICK_IRQHandler>:
HAL_SYSTICK_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:451
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000e38:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_cortex.c:452
  HAL_SYSTICK_Callback();
 8000e3a:	f7ff fffb 	bl	8000e34 <HAL_SYSTICK_Callback>
 8000e3e:	bd08      	pop	{r3, pc}

08000e40 <HAL_GPIO_Init>:
HAL_GPIO_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:190
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000e40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000e44:	b082      	sub	sp, #8
 8000e46:	4680      	mov	r8, r0
 8000e48:	460f      	mov	r7, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197
  uint32_t ioposition = 0x00;
  uint32_t iocurrent = 0x00;
  uint32_t temp = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8000e4a:	4ba3      	ldr	r3, [pc, #652]	; (80010d8 <HAL_GPIO_Init+0x298>)
 8000e4c:	4298      	cmp	r0, r3
 8000e4e:	d023      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 1)
 8000e50:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e54:	4298      	cmp	r0, r3
 8000e56:	d01f      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 2)
 8000e58:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e5c:	4298      	cmp	r0, r3
 8000e5e:	d01b      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 3)
 8000e60:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e64:	4298      	cmp	r0, r3
 8000e66:	d017      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 4)
 8000e68:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e6c:	4298      	cmp	r0, r3
 8000e6e:	d013      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 5)
 8000e70:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e74:	4298      	cmp	r0, r3
 8000e76:	d00f      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 6)
 8000e78:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e7c:	4298      	cmp	r0, r3
 8000e7e:	d00b      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 7)
 8000e80:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e84:	4298      	cmp	r0, r3
 8000e86:	d007      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 8)
 8000e88:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000e8c:	4298      	cmp	r0, r3
 8000e8e:	d003      	beq.n	8000e98 <HAL_GPIO_Init+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:197 (discriminator 9)
 8000e90:	21c5      	movs	r1, #197	; 0xc5
 8000e92:	4892      	ldr	r0, [pc, #584]	; (80010dc <HAL_GPIO_Init+0x29c>)
 8000e94:	f001 f96c 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:198
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 8000e98:	883b      	ldrh	r3, [r7, #0]
 8000e9a:	b91b      	cbnz	r3, 8000ea4 <HAL_GPIO_Init+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:198 (discriminator 1)
 8000e9c:	21c6      	movs	r1, #198	; 0xc6
 8000e9e:	488f      	ldr	r0, [pc, #572]	; (80010dc <HAL_GPIO_Init+0x29c>)
 8000ea0:	f001 f966 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 8000ea4:	687b      	ldr	r3, [r7, #4]
 8000ea6:	2b01      	cmp	r3, #1
 8000ea8:	d922      	bls.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 1)
 8000eaa:	2b11      	cmp	r3, #17
 8000eac:	d020      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 2)
 8000eae:	2b02      	cmp	r3, #2
 8000eb0:	d01e      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 3)
 8000eb2:	2b12      	cmp	r3, #18
 8000eb4:	d01c      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 4)
 8000eb6:	4a8a      	ldr	r2, [pc, #552]	; (80010e0 <HAL_GPIO_Init+0x2a0>)
 8000eb8:	4293      	cmp	r3, r2
 8000eba:	d019      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 5)
 8000ebc:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 8000ec0:	4293      	cmp	r3, r2
 8000ec2:	d015      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 6)
 8000ec4:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 8000ec8:	4293      	cmp	r3, r2
 8000eca:	d011      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 7)
 8000ecc:	f5a2 12f8 	sub.w	r2, r2, #2031616	; 0x1f0000
 8000ed0:	4293      	cmp	r3, r2
 8000ed2:	d00d      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 8)
 8000ed4:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 8000ed8:	4293      	cmp	r3, r2
 8000eda:	d009      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 9)
 8000edc:	f502 1280 	add.w	r2, r2, #1048576	; 0x100000
 8000ee0:	4293      	cmp	r3, r2
 8000ee2:	d005      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 10)
 8000ee4:	2b03      	cmp	r3, #3
 8000ee6:	d003      	beq.n	8000ef0 <HAL_GPIO_Init+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:199 (discriminator 11)
 8000ee8:	21c7      	movs	r1, #199	; 0xc7
 8000eea:	487c      	ldr	r0, [pc, #496]	; (80010dc <HAL_GPIO_Init+0x29c>)
 8000eec:	f001 f940 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:200
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8000ef0:	68bb      	ldr	r3, [r7, #8]
 8000ef2:	2b02      	cmp	r3, #2
 8000ef4:	d903      	bls.n	8000efe <HAL_GPIO_Init+0xbe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:200 (discriminator 1)
 8000ef6:	21c8      	movs	r1, #200	; 0xc8
 8000ef8:	4878      	ldr	r0, [pc, #480]	; (80010dc <HAL_GPIO_Init+0x29c>)
 8000efa:	f001 f939 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 1)
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000efe:	2500      	movs	r5, #0
 8000f00:	e12a      	b.n	8001158 <HAL_GPIO_Init+0x318>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:206

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8000f02:	2401      	movs	r4, #1
 8000f04:	40ac      	lsls	r4, r5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:208
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000f06:	683e      	ldr	r6, [r7, #0]
 8000f08:	4026      	ands	r6, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:210

    if(iocurrent == ioposition)
 8000f0a:	42b4      	cmp	r4, r6
 8000f0c:	f040 8123 	bne.w	8001156 <HAL_GPIO_Init+0x316>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:214
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000f10:	687b      	ldr	r3, [r7, #4]
 8000f12:	2b02      	cmp	r3, #2
 8000f14:	d001      	beq.n	8000f1a <HAL_GPIO_Init+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:214 (discriminator 1)
 8000f16:	2b12      	cmp	r3, #18
 8000f18:	d14a      	bne.n	8000fb0 <HAL_GPIO_Init+0x170>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 8000f1a:	693b      	ldr	r3, [r7, #16]
 8000f1c:	b3c3      	cbz	r3, 8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 1)
 8000f1e:	2b09      	cmp	r3, #9
 8000f20:	d036      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 2)
 8000f22:	b3ab      	cbz	r3, 8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 3)
 8000f24:	b3a3      	cbz	r3, 8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 4)
 8000f26:	b39b      	cbz	r3, 8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 5)
 8000f28:	b393      	cbz	r3, 8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 6)
 8000f2a:	2b01      	cmp	r3, #1
 8000f2c:	d030      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 7)
 8000f2e:	d02f      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 8)
 8000f30:	2b02      	cmp	r3, #2
 8000f32:	d02d      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 9)
 8000f34:	d02c      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 10)
 8000f36:	d02b      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 11)
 8000f38:	2b03      	cmp	r3, #3
 8000f3a:	d029      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 12)
 8000f3c:	2b04      	cmp	r3, #4
 8000f3e:	d027      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 13)
 8000f40:	d026      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 14)
 8000f42:	d025      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 15)
 8000f44:	2b05      	cmp	r3, #5
 8000f46:	d023      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 16)
 8000f48:	d022      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 17)
 8000f4a:	2b09      	cmp	r3, #9
 8000f4c:	d020      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 18)
 8000f4e:	2b06      	cmp	r3, #6
 8000f50:	d01e      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 19)
 8000f52:	2b09      	cmp	r3, #9
 8000f54:	d01c      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 20)
 8000f56:	2b07      	cmp	r3, #7
 8000f58:	d01a      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 21)
 8000f5a:	d019      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 22)
 8000f5c:	d018      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 23)
 8000f5e:	2b08      	cmp	r3, #8
 8000f60:	d016      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 24)
 8000f62:	d015      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 25)
 8000f64:	d014      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 26)
 8000f66:	2b09      	cmp	r3, #9
 8000f68:	d012      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 27)
 8000f6a:	d011      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 28)
 8000f6c:	2b0a      	cmp	r3, #10
 8000f6e:	d00f      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 29)
 8000f70:	d00e      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 30)
 8000f72:	2b0b      	cmp	r3, #11
 8000f74:	d00c      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 31)
 8000f76:	2b0c      	cmp	r3, #12
 8000f78:	d00a      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 32)
 8000f7a:	d009      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 33)
 8000f7c:	2b0d      	cmp	r3, #13
 8000f7e:	d007      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 34)
 8000f80:	2b0c      	cmp	r3, #12
 8000f82:	d005      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 35)
 8000f84:	2b0f      	cmp	r3, #15
 8000f86:	d003      	beq.n	8000f90 <HAL_GPIO_Init+0x150>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:217 (discriminator 36)
 8000f88:	21d9      	movs	r1, #217	; 0xd9
 8000f8a:	4854      	ldr	r0, [pc, #336]	; (80010dc <HAL_GPIO_Init+0x29c>)
 8000f8c:	f001 f8f0 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:219
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8000f90:	08ea      	lsrs	r2, r5, #3
 8000f92:	3208      	adds	r2, #8
 8000f94:	f858 0022 	ldr.w	r0, [r8, r2, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:220
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000f98:	f005 0307 	and.w	r3, r5, #7
 8000f9c:	0099      	lsls	r1, r3, #2
 8000f9e:	230f      	movs	r3, #15
 8000fa0:	408b      	lsls	r3, r1
 8000fa2:	ea20 0003 	bic.w	r0, r0, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:221
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000fa6:	693b      	ldr	r3, [r7, #16]
 8000fa8:	408b      	lsls	r3, r1
 8000faa:	4303      	orrs	r3, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:222
        GPIOx->AFR[position >> 3] = temp;
 8000fac:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:226
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000fb0:	f8d8 3000 	ldr.w	r3, [r8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:227
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000fb4:	ea4f 0a45 	mov.w	sl, r5, lsl #1
 8000fb8:	f04f 0903 	mov.w	r9, #3
 8000fbc:	fa09 f90a 	lsl.w	r9, r9, sl
 8000fc0:	ea6f 0909 	mvn.w	r9, r9
 8000fc4:	ea03 0209 	and.w	r2, r3, r9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:228
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000fc8:	687b      	ldr	r3, [r7, #4]
 8000fca:	f003 0303 	and.w	r3, r3, #3
 8000fce:	fa03 f30a 	lsl.w	r3, r3, sl
 8000fd2:	4313      	orrs	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:229
      GPIOx->MODER = temp;
 8000fd4:	f8c8 3000 	str.w	r3, [r8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:232

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000fd8:	687b      	ldr	r3, [r7, #4]
 8000fda:	1e5a      	subs	r2, r3, #1
 8000fdc:	2a01      	cmp	r2, #1
 8000fde:	d903      	bls.n	8000fe8 <HAL_GPIO_Init+0x1a8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:232 (discriminator 1)
 8000fe0:	2b11      	cmp	r3, #17
 8000fe2:	d001      	beq.n	8000fe8 <HAL_GPIO_Init+0x1a8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:233
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000fe4:	2b12      	cmp	r3, #18
 8000fe6:	d11b      	bne.n	8001020 <HAL_GPIO_Init+0x1e0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:236
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8000fe8:	68fb      	ldr	r3, [r7, #12]
 8000fea:	2b03      	cmp	r3, #3
 8000fec:	d903      	bls.n	8000ff6 <HAL_GPIO_Init+0x1b6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:236 (discriminator 1)
 8000fee:	21ec      	movs	r1, #236	; 0xec
 8000ff0:	483a      	ldr	r0, [pc, #232]	; (80010dc <HAL_GPIO_Init+0x29c>)
 8000ff2:	f001 f8bd 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:238
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000ff6:	f8d8 3008 	ldr.w	r3, [r8, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:239
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000ffa:	ea09 0203 	and.w	r2, r9, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:240
        temp |= (GPIO_Init->Speed << (position * 2));
 8000ffe:	68fb      	ldr	r3, [r7, #12]
 8001000:	fa03 f30a 	lsl.w	r3, r3, sl
 8001004:	4313      	orrs	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:241
        GPIOx->OSPEEDR = temp;
 8001006:	f8c8 3008 	str.w	r3, [r8, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:244

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800100a:	f8d8 3004 	ldr.w	r3, [r8, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:245
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800100e:	ea23 0404 	bic.w	r4, r3, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:246
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001012:	687b      	ldr	r3, [r7, #4]
 8001014:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8001018:	40ab      	lsls	r3, r5
 800101a:	431c      	orrs	r4, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:247
        GPIOx->OTYPER = temp;
 800101c:	f8c8 4004 	str.w	r4, [r8, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:251
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001020:	f8d8 300c 	ldr.w	r3, [r8, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:252
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8001024:	ea09 0903 	and.w	r9, r9, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:253
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001028:	68bb      	ldr	r3, [r7, #8]
 800102a:	fa03 f30a 	lsl.w	r3, r3, sl
 800102e:	ea49 0303 	orr.w	r3, r9, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:254
      GPIOx->PUPDR = temp;
 8001032:	f8c8 300c 	str.w	r3, [r8, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:258

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001036:	687b      	ldr	r3, [r7, #4]
 8001038:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 800103c:	f000 808b 	beq.w	8001156 <HAL_GPIO_Init+0x316>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:261
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001040:	4b28      	ldr	r3, [pc, #160]	; (80010e4 <HAL_GPIO_Init+0x2a4>)
 8001042:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001044:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001048:	645a      	str	r2, [r3, #68]	; 0x44
 800104a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800104c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001050:	9301      	str	r3, [sp, #4]
 8001052:	9b01      	ldr	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:263

        temp = SYSCFG->EXTICR[position >> 2];
 8001054:	08a9      	lsrs	r1, r5, #2
 8001056:	1c8a      	adds	r2, r1, #2
 8001058:	4b23      	ldr	r3, [pc, #140]	; (80010e8 <HAL_GPIO_Init+0x2a8>)
 800105a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:264
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800105e:	f005 0303 	and.w	r3, r5, #3
 8001062:	009b      	lsls	r3, r3, #2
 8001064:	220f      	movs	r2, #15
 8001066:	409a      	lsls	r2, r3
 8001068:	ea20 0002 	bic.w	r0, r0, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800106c:	4a1a      	ldr	r2, [pc, #104]	; (80010d8 <HAL_GPIO_Init+0x298>)
 800106e:	4590      	cmp	r8, r2
 8001070:	d021      	beq.n	80010b6 <HAL_GPIO_Init+0x276>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 1)
 8001072:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001076:	4590      	cmp	r8, r2
 8001078:	d01f      	beq.n	80010ba <HAL_GPIO_Init+0x27a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 3)
 800107a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800107e:	4590      	cmp	r8, r2
 8001080:	d01d      	beq.n	80010be <HAL_GPIO_Init+0x27e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 5)
 8001082:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001086:	4590      	cmp	r8, r2
 8001088:	d01b      	beq.n	80010c2 <HAL_GPIO_Init+0x282>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 7)
 800108a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800108e:	4590      	cmp	r8, r2
 8001090:	d019      	beq.n	80010c6 <HAL_GPIO_Init+0x286>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 9)
 8001092:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001096:	4590      	cmp	r8, r2
 8001098:	d017      	beq.n	80010ca <HAL_GPIO_Init+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 11)
 800109a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800109e:	4590      	cmp	r8, r2
 80010a0:	d015      	beq.n	80010ce <HAL_GPIO_Init+0x28e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 13)
 80010a2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80010a6:	4590      	cmp	r8, r2
 80010a8:	d013      	beq.n	80010d2 <HAL_GPIO_Init+0x292>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 15)
 80010aa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80010ae:	4590      	cmp	r8, r2
 80010b0:	d11c      	bne.n	80010ec <HAL_GPIO_Init+0x2ac>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265
 80010b2:	2208      	movs	r2, #8
 80010b4:	e01b      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010b6:	2200      	movs	r2, #0
 80010b8:	e019      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010ba:	2201      	movs	r2, #1
 80010bc:	e017      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010be:	2202      	movs	r2, #2
 80010c0:	e015      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010c2:	2203      	movs	r2, #3
 80010c4:	e013      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010c6:	2204      	movs	r2, #4
 80010c8:	e011      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010ca:	2205      	movs	r2, #5
 80010cc:	e00f      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010ce:	2206      	movs	r2, #6
 80010d0:	e00d      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010d2:	2207      	movs	r2, #7
 80010d4:	e00b      	b.n	80010ee <HAL_GPIO_Init+0x2ae>
 80010d6:	bf00      	nop
 80010d8:	40020000 	.word	0x40020000
 80010dc:	080066c0 	.word	0x080066c0
 80010e0:	10110000 	.word	0x10110000
 80010e4:	40023800 	.word	0x40023800
 80010e8:	40013800 	.word	0x40013800
 80010ec:	2209      	movs	r2, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:265 (discriminator 36)
 80010ee:	fa02 f303 	lsl.w	r3, r2, r3
 80010f2:	4303      	orrs	r3, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:266 (discriminator 36)
        SYSCFG->EXTICR[position >> 2] = temp;
 80010f4:	3102      	adds	r1, #2
 80010f6:	4a1b      	ldr	r2, [pc, #108]	; (8001164 <HAL_GPIO_Init+0x324>)
 80010f8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:269 (discriminator 36)

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80010fc:	4b1a      	ldr	r3, [pc, #104]	; (8001168 <HAL_GPIO_Init+0x328>)
 80010fe:	681a      	ldr	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:270 (discriminator 36)
        temp &= ~((uint32_t)iocurrent);
 8001100:	43f3      	mvns	r3, r6
 8001102:	ea02 0103 	and.w	r1, r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:271 (discriminator 36)
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001106:	6878      	ldr	r0, [r7, #4]
 8001108:	f410 3f80 	tst.w	r0, #65536	; 0x10000
 800110c:	d001      	beq.n	8001112 <HAL_GPIO_Init+0x2d2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:273
        {
          temp |= iocurrent;
 800110e:	ea46 0102 	orr.w	r1, r6, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:275
        }
        EXTI->IMR = temp;
 8001112:	4a15      	ldr	r2, [pc, #84]	; (8001168 <HAL_GPIO_Init+0x328>)
 8001114:	6011      	str	r1, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:277

        temp = EXTI->EMR;
 8001116:	6852      	ldr	r2, [r2, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:278
        temp &= ~((uint32_t)iocurrent);
 8001118:	ea03 0102 	and.w	r1, r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:279
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800111c:	6878      	ldr	r0, [r7, #4]
 800111e:	f410 3f00 	tst.w	r0, #131072	; 0x20000
 8001122:	d001      	beq.n	8001128 <HAL_GPIO_Init+0x2e8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:281
        {
          temp |= iocurrent;
 8001124:	ea46 0102 	orr.w	r1, r6, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:283
        }
        EXTI->EMR = temp;
 8001128:	4a0f      	ldr	r2, [pc, #60]	; (8001168 <HAL_GPIO_Init+0x328>)
 800112a:	6051      	str	r1, [r2, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:286

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800112c:	6892      	ldr	r2, [r2, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:287
        temp &= ~((uint32_t)iocurrent);
 800112e:	ea03 0102 	and.w	r1, r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:288
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001132:	6878      	ldr	r0, [r7, #4]
 8001134:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8001138:	d001      	beq.n	800113e <HAL_GPIO_Init+0x2fe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:290
        {
          temp |= iocurrent;
 800113a:	ea46 0102 	orr.w	r1, r6, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:292
        }
        EXTI->RTSR = temp;
 800113e:	4a0a      	ldr	r2, [pc, #40]	; (8001168 <HAL_GPIO_Init+0x328>)
 8001140:	6091      	str	r1, [r2, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:294

        temp = EXTI->FTSR;
 8001142:	68d2      	ldr	r2, [r2, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:295
        temp &= ~((uint32_t)iocurrent);
 8001144:	4013      	ands	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:296
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001146:	6879      	ldr	r1, [r7, #4]
 8001148:	f411 1f00 	tst.w	r1, #2097152	; 0x200000
 800114c:	d001      	beq.n	8001152 <HAL_GPIO_Init+0x312>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:298
        {
          temp |= iocurrent;
 800114e:	ea46 0302 	orr.w	r3, r6, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:300
        }
        EXTI->FTSR = temp;
 8001152:	4a05      	ldr	r2, [pc, #20]	; (8001168 <HAL_GPIO_Init+0x328>)
 8001154:	60d3      	str	r3, [r2, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:203 (discriminator 2)
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8001156:	3501      	adds	r5, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:203 (discriminator 1)
 8001158:	2d0f      	cmp	r5, #15
 800115a:	f67f aed2 	bls.w	8000f02 <HAL_GPIO_Init+0xc2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:304
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 800115e:	b002      	add	sp, #8
 8001160:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001164:	40013800 	.word	0x40013800
 8001168:	40013c00 	.word	0x40013c00

0800116c <HAL_GPIO_WritePin>:
HAL_GPIO_WritePin():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:431
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800116c:	b570      	push	{r4, r5, r6, lr}
 800116e:	4606      	mov	r6, r0
 8001170:	4615      	mov	r5, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:433
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8001172:	460c      	mov	r4, r1
 8001174:	b921      	cbnz	r1, 8001180 <HAL_GPIO_WritePin+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:433 (discriminator 1)
 8001176:	f240 11b1 	movw	r1, #433	; 0x1b1
 800117a:	4808      	ldr	r0, [pc, #32]	; (800119c <HAL_GPIO_WritePin+0x30>)
 800117c:	f000 fff8 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:434
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 8001180:	2d01      	cmp	r5, #1
 8001182:	d904      	bls.n	800118e <HAL_GPIO_WritePin+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:434 (discriminator 1)
 8001184:	f44f 71d9 	mov.w	r1, #434	; 0x1b2
 8001188:	4804      	ldr	r0, [pc, #16]	; (800119c <HAL_GPIO_WritePin+0x30>)
 800118a:	f000 fff1 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:436

  if(PinState != GPIO_PIN_RESET)
 800118e:	b10d      	cbz	r5, 8001194 <HAL_GPIO_WritePin+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:438
  {
    GPIOx->BSRR = GPIO_Pin;
 8001190:	61b4      	str	r4, [r6, #24]
 8001192:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:442
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8001194:	0424      	lsls	r4, r4, #16
 8001196:	61b4      	str	r4, [r6, #24]
 8001198:	bd70      	pop	{r4, r5, r6, pc}
 800119a:	bf00      	nop
 800119c:	080066c0 	.word	0x080066c0

080011a0 <HAL_GPIO_TogglePin>:
HAL_GPIO_TogglePin():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:454
  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80011a0:	b538      	push	{r3, r4, r5, lr}
 80011a2:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:456
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 80011a4:	460d      	mov	r5, r1
 80011a6:	b921      	cbnz	r1, 80011b2 <HAL_GPIO_TogglePin+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:456 (discriminator 1)
 80011a8:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 80011ac:	4803      	ldr	r0, [pc, #12]	; (80011bc <HAL_GPIO_TogglePin+0x1c>)
 80011ae:	f000 ffdf 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:458

  GPIOx->ODR ^= GPIO_Pin;
 80011b2:	6961      	ldr	r1, [r4, #20]
 80011b4:	4069      	eors	r1, r5
 80011b6:	6161      	str	r1, [r4, #20]
 80011b8:	bd38      	pop	{r3, r4, r5, pc}
 80011ba:	bf00      	nop
 80011bc:	080066c0 	.word	0x080066c0

080011c0 <HAL_GPIO_EXTI_IRQHandler>:
HAL_GPIO_EXTI_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:506
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 80011c0:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:508
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 80011c2:	4b04      	ldr	r3, [pc, #16]	; (80011d4 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 80011c4:	695b      	ldr	r3, [r3, #20]
 80011c6:	4203      	tst	r3, r0
 80011c8:	d003      	beq.n	80011d2 <HAL_GPIO_EXTI_IRQHandler+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:510
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80011ca:	4b02      	ldr	r3, [pc, #8]	; (80011d4 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 80011cc:	6158      	str	r0, [r3, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_gpio.c:511
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80011ce:	f001 fc9b 	bl	8002b08 <HAL_GPIO_EXTI_Callback>
 80011d2:	bd08      	pop	{r3, pc}
 80011d4:	40013c00 	.word	0x40013c00

080011d8 <HAL_RCC_OscConfig>:
HAL_RCC_OscConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:252
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80011d8:	b530      	push	{r4, r5, lr}
 80011da:	b083      	sub	sp, #12
 80011dc:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:256
 uint32_t tickstart = 0;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 80011de:	6803      	ldr	r3, [r0, #0]
 80011e0:	2b0f      	cmp	r3, #15
 80011e2:	d904      	bls.n	80011ee <HAL_RCC_OscConfig+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:256 (discriminator 1)
 80011e4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80011e8:	48b1      	ldr	r0, [pc, #708]	; (80014b0 <HAL_RCC_OscConfig+0x2d8>)
 80011ea:	f000 ffc1 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:258
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80011ee:	6823      	ldr	r3, [r4, #0]
 80011f0:	f013 0f01 	tst.w	r3, #1
 80011f4:	d05f      	beq.n	80012b6 <HAL_RCC_OscConfig+0xde>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:261
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 80011f6:	6863      	ldr	r3, [r4, #4]
 80011f8:	2b01      	cmp	r3, #1
 80011fa:	d906      	bls.n	800120a <HAL_RCC_OscConfig+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:261 (discriminator 1)
 80011fc:	2b05      	cmp	r3, #5
 80011fe:	d004      	beq.n	800120a <HAL_RCC_OscConfig+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:261 (discriminator 2)
 8001200:	f240 1105 	movw	r1, #261	; 0x105
 8001204:	48aa      	ldr	r0, [pc, #680]	; (80014b0 <HAL_RCC_OscConfig+0x2d8>)
 8001206:	f000 ffb3 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:263
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 800120a:	4baa      	ldr	r3, [pc, #680]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 800120c:	689b      	ldr	r3, [r3, #8]
 800120e:	f003 030c 	and.w	r3, r3, #12
 8001212:	2b04      	cmp	r3, #4
 8001214:	d00a      	beq.n	800122c <HAL_RCC_OscConfig+0x54>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:264 (discriminator 1)
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001216:	4ba7      	ldr	r3, [pc, #668]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 8001218:	689b      	ldr	r3, [r3, #8]
 800121a:	f003 030c 	and.w	r3, r3, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:263 (discriminator 1)
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 800121e:	2b08      	cmp	r3, #8
 8001220:	d10d      	bne.n	800123e <HAL_RCC_OscConfig+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:264
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001222:	4ba4      	ldr	r3, [pc, #656]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 8001224:	685b      	ldr	r3, [r3, #4]
 8001226:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800122a:	d008      	beq.n	800123e <HAL_RCC_OscConfig+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:266
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800122c:	4ba1      	ldr	r3, [pc, #644]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 800122e:	681b      	ldr	r3, [r3, #0]
 8001230:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001234:	d03f      	beq.n	80012b6 <HAL_RCC_OscConfig+0xde>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:266 (discriminator 1)
 8001236:	6863      	ldr	r3, [r4, #4]
 8001238:	2b00      	cmp	r3, #0
 800123a:	d13c      	bne.n	80012b6 <HAL_RCC_OscConfig+0xde>
 800123c:	e1f4      	b.n	8001628 <HAL_RCC_OscConfig+0x450>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:274
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 800123e:	2200      	movs	r2, #0
 8001240:	4b9d      	ldr	r3, [pc, #628]	; (80014b8 <HAL_RCC_OscConfig+0x2e0>)
 8001242:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:277
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001244:	f004 fad0 	bl	80057e8 <HAL_GetTick>
 8001248:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:280
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800124a:	e007      	b.n	800125c <HAL_RCC_OscConfig+0x84>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:282
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800124c:	f004 facc 	bl	80057e8 <HAL_GetTick>
 8001250:	1b40      	subs	r0, r0, r5
 8001252:	f241 3388 	movw	r3, #5000	; 0x1388
 8001256:	4298      	cmp	r0, r3
 8001258:	f200 81e8 	bhi.w	800162c <HAL_RCC_OscConfig+0x454>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:280
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800125c:	4b95      	ldr	r3, [pc, #596]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 800125e:	681b      	ldr	r3, [r3, #0]
 8001260:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001264:	d1f2      	bne.n	800124c <HAL_RCC_OscConfig+0x74>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:289
          return HAL_TIMEOUT;
        }       
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001266:	7922      	ldrb	r2, [r4, #4]
 8001268:	4b93      	ldr	r3, [pc, #588]	; (80014b8 <HAL_RCC_OscConfig+0x2e0>)
 800126a:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:292
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800126c:	6863      	ldr	r3, [r4, #4]
 800126e:	b18b      	cbz	r3, 8001294 <HAL_RCC_OscConfig+0xbc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:295
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001270:	f004 faba 	bl	80057e8 <HAL_GetTick>
 8001274:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:298
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001276:	e007      	b.n	8001288 <HAL_RCC_OscConfig+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:300
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001278:	f004 fab6 	bl	80057e8 <HAL_GetTick>
 800127c:	1b40      	subs	r0, r0, r5
 800127e:	f241 3388 	movw	r3, #5000	; 0x1388
 8001282:	4298      	cmp	r0, r3
 8001284:	f200 81d4 	bhi.w	8001630 <HAL_RCC_OscConfig+0x458>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:298
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001288:	4b8a      	ldr	r3, [pc, #552]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 800128a:	681b      	ldr	r3, [r3, #0]
 800128c:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001290:	d0f2      	beq.n	8001278 <HAL_RCC_OscConfig+0xa0>
 8001292:	e010      	b.n	80012b6 <HAL_RCC_OscConfig+0xde>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:309
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001294:	f004 faa8 	bl	80057e8 <HAL_GetTick>
 8001298:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:312

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800129a:	e007      	b.n	80012ac <HAL_RCC_OscConfig+0xd4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:314
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800129c:	f004 faa4 	bl	80057e8 <HAL_GetTick>
 80012a0:	1b40      	subs	r0, r0, r5
 80012a2:	f241 3388 	movw	r3, #5000	; 0x1388
 80012a6:	4298      	cmp	r0, r3
 80012a8:	f200 81c4 	bhi.w	8001634 <HAL_RCC_OscConfig+0x45c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:312
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80012ac:	4b81      	ldr	r3, [pc, #516]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 80012ae:	681b      	ldr	r3, [r3, #0]
 80012b0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80012b4:	d1f2      	bne.n	800129c <HAL_RCC_OscConfig+0xc4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:323
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80012b6:	6823      	ldr	r3, [r4, #0]
 80012b8:	f013 0f02 	tst.w	r3, #2
 80012bc:	d06a      	beq.n	8001394 <HAL_RCC_OscConfig+0x1bc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:326
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 80012be:	68e3      	ldr	r3, [r4, #12]
 80012c0:	2b01      	cmp	r3, #1
 80012c2:	d904      	bls.n	80012ce <HAL_RCC_OscConfig+0xf6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:326 (discriminator 1)
 80012c4:	f44f 71a3 	mov.w	r1, #326	; 0x146
 80012c8:	4879      	ldr	r0, [pc, #484]	; (80014b0 <HAL_RCC_OscConfig+0x2d8>)
 80012ca:	f000 ff51 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:327
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 80012ce:	6923      	ldr	r3, [r4, #16]
 80012d0:	2b1f      	cmp	r3, #31
 80012d2:	d904      	bls.n	80012de <HAL_RCC_OscConfig+0x106>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:327 (discriminator 1)
 80012d4:	f240 1147 	movw	r1, #327	; 0x147
 80012d8:	4875      	ldr	r0, [pc, #468]	; (80014b0 <HAL_RCC_OscConfig+0x2d8>)
 80012da:	f000 ff49 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:330
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 80012de:	4b75      	ldr	r3, [pc, #468]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 80012e0:	689b      	ldr	r3, [r3, #8]
 80012e2:	f013 0f0c 	tst.w	r3, #12
 80012e6:	d00a      	beq.n	80012fe <HAL_RCC_OscConfig+0x126>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:331 (discriminator 1)
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80012e8:	4b72      	ldr	r3, [pc, #456]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 80012ea:	689b      	ldr	r3, [r3, #8]
 80012ec:	f003 030c 	and.w	r3, r3, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:330 (discriminator 1)
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 80012f0:	2b08      	cmp	r3, #8
 80012f2:	d11b      	bne.n	800132c <HAL_RCC_OscConfig+0x154>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:331
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80012f4:	4b6f      	ldr	r3, [pc, #444]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 80012f6:	685b      	ldr	r3, [r3, #4]
 80012f8:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80012fc:	d116      	bne.n	800132c <HAL_RCC_OscConfig+0x154>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:334
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80012fe:	4b6d      	ldr	r3, [pc, #436]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 8001300:	681b      	ldr	r3, [r3, #0]
 8001302:	f013 0f02 	tst.w	r3, #2
 8001306:	d003      	beq.n	8001310 <HAL_RCC_OscConfig+0x138>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:334 (discriminator 1)
 8001308:	68e3      	ldr	r3, [r4, #12]
 800130a:	2b01      	cmp	r3, #1
 800130c:	f040 8194 	bne.w	8001638 <HAL_RCC_OscConfig+0x460>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:342
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001310:	4868      	ldr	r0, [pc, #416]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 8001312:	6803      	ldr	r3, [r0, #0]
 8001314:	f023 01f8 	bic.w	r1, r3, #248	; 0xf8
 8001318:	6923      	ldr	r3, [r4, #16]
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800131a:	22f8      	movs	r2, #248	; 0xf8
 800131c:	fa92 f2a2 	rbit	r2, r2
HAL_RCC_OscConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:342
 8001320:	fab2 f282 	clz	r2, r2
 8001324:	4093      	lsls	r3, r2
 8001326:	430b      	orrs	r3, r1
 8001328:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:334
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800132a:	e033      	b.n	8001394 <HAL_RCC_OscConfig+0x1bc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:348
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800132c:	68e3      	ldr	r3, [r4, #12]
 800132e:	b1fb      	cbz	r3, 8001370 <HAL_RCC_OscConfig+0x198>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:351
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001330:	2201      	movs	r2, #1
 8001332:	4b62      	ldr	r3, [pc, #392]	; (80014bc <HAL_RCC_OscConfig+0x2e4>)
 8001334:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:354

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001336:	f004 fa57 	bl	80057e8 <HAL_GetTick>
 800133a:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:357

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800133c:	e005      	b.n	800134a <HAL_RCC_OscConfig+0x172>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:359
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800133e:	f004 fa53 	bl	80057e8 <HAL_GetTick>
 8001342:	1b40      	subs	r0, r0, r5
 8001344:	2864      	cmp	r0, #100	; 0x64
 8001346:	f200 8179 	bhi.w	800163c <HAL_RCC_OscConfig+0x464>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:357

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800134a:	4b5a      	ldr	r3, [pc, #360]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 800134c:	681b      	ldr	r3, [r3, #0]
 800134e:	f013 0f02 	tst.w	r3, #2
 8001352:	d0f4      	beq.n	800133e <HAL_RCC_OscConfig+0x166>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:366
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001354:	4857      	ldr	r0, [pc, #348]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 8001356:	6803      	ldr	r3, [r0, #0]
 8001358:	f023 01f8 	bic.w	r1, r3, #248	; 0xf8
 800135c:	6923      	ldr	r3, [r4, #16]
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 800135e:	22f8      	movs	r2, #248	; 0xf8
 8001360:	fa92 f2a2 	rbit	r2, r2
HAL_RCC_OscConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:366
 8001364:	fab2 f282 	clz	r2, r2
 8001368:	4093      	lsls	r3, r2
 800136a:	430b      	orrs	r3, r1
 800136c:	6003      	str	r3, [r0, #0]
 800136e:	e011      	b.n	8001394 <HAL_RCC_OscConfig+0x1bc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:371
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001370:	2200      	movs	r2, #0
 8001372:	4b52      	ldr	r3, [pc, #328]	; (80014bc <HAL_RCC_OscConfig+0x2e4>)
 8001374:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:374

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001376:	f004 fa37 	bl	80057e8 <HAL_GetTick>
 800137a:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:377
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800137c:	e005      	b.n	800138a <HAL_RCC_OscConfig+0x1b2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:379
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800137e:	f004 fa33 	bl	80057e8 <HAL_GetTick>
 8001382:	1b40      	subs	r0, r0, r5
 8001384:	2864      	cmp	r0, #100	; 0x64
 8001386:	f200 815b 	bhi.w	8001640 <HAL_RCC_OscConfig+0x468>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:377

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800138a:	4b4a      	ldr	r3, [pc, #296]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 800138c:	681b      	ldr	r3, [r3, #0]
 800138e:	f013 0f02 	tst.w	r3, #2
 8001392:	d1f4      	bne.n	800137e <HAL_RCC_OscConfig+0x1a6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:388
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001394:	6823      	ldr	r3, [r4, #0]
 8001396:	f013 0f08 	tst.w	r3, #8
 800139a:	d02e      	beq.n	80013fa <HAL_RCC_OscConfig+0x222>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:391
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 800139c:	6963      	ldr	r3, [r4, #20]
 800139e:	2b01      	cmp	r3, #1
 80013a0:	d904      	bls.n	80013ac <HAL_RCC_OscConfig+0x1d4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:391 (discriminator 1)
 80013a2:	f240 1187 	movw	r1, #391	; 0x187
 80013a6:	4842      	ldr	r0, [pc, #264]	; (80014b0 <HAL_RCC_OscConfig+0x2d8>)
 80013a8:	f000 fee2 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:394

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80013ac:	6963      	ldr	r3, [r4, #20]
 80013ae:	b193      	cbz	r3, 80013d6 <HAL_RCC_OscConfig+0x1fe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:397
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80013b0:	2201      	movs	r2, #1
 80013b2:	4b43      	ldr	r3, [pc, #268]	; (80014c0 <HAL_RCC_OscConfig+0x2e8>)
 80013b4:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:400
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80013b6:	f004 fa17 	bl	80057e8 <HAL_GetTick>
 80013ba:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:403
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80013bc:	e005      	b.n	80013ca <HAL_RCC_OscConfig+0x1f2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:405
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80013be:	f004 fa13 	bl	80057e8 <HAL_GetTick>
 80013c2:	1b40      	subs	r0, r0, r5
 80013c4:	2864      	cmp	r0, #100	; 0x64
 80013c6:	f200 813d 	bhi.w	8001644 <HAL_RCC_OscConfig+0x46c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:403
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80013ca:	4b3a      	ldr	r3, [pc, #232]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 80013cc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80013ce:	f013 0f02 	tst.w	r3, #2
 80013d2:	d0f4      	beq.n	80013be <HAL_RCC_OscConfig+0x1e6>
 80013d4:	e011      	b.n	80013fa <HAL_RCC_OscConfig+0x222>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:414
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80013d6:	2200      	movs	r2, #0
 80013d8:	4b39      	ldr	r3, [pc, #228]	; (80014c0 <HAL_RCC_OscConfig+0x2e8>)
 80013da:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:417
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80013dc:	f004 fa04 	bl	80057e8 <HAL_GetTick>
 80013e0:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:420
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80013e2:	e005      	b.n	80013f0 <HAL_RCC_OscConfig+0x218>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:422
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80013e4:	f004 fa00 	bl	80057e8 <HAL_GetTick>
 80013e8:	1b40      	subs	r0, r0, r5
 80013ea:	2864      	cmp	r0, #100	; 0x64
 80013ec:	f200 812c 	bhi.w	8001648 <HAL_RCC_OscConfig+0x470>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:420
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80013f0:	4b30      	ldr	r3, [pc, #192]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 80013f2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80013f4:	f013 0f02 	tst.w	r3, #2
 80013f8:	d1f4      	bne.n	80013e4 <HAL_RCC_OscConfig+0x20c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:430
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80013fa:	6823      	ldr	r3, [r4, #0]
 80013fc:	f013 0f04 	tst.w	r3, #4
 8001400:	d071      	beq.n	80014e6 <HAL_RCC_OscConfig+0x30e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:433
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8001402:	68a3      	ldr	r3, [r4, #8]
 8001404:	2b01      	cmp	r3, #1
 8001406:	d906      	bls.n	8001416 <HAL_RCC_OscConfig+0x23e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:433 (discriminator 1)
 8001408:	2b05      	cmp	r3, #5
 800140a:	d004      	beq.n	8001416 <HAL_RCC_OscConfig+0x23e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:433 (discriminator 2)
 800140c:	f240 11b1 	movw	r1, #433	; 0x1b1
 8001410:	4827      	ldr	r0, [pc, #156]	; (80014b0 <HAL_RCC_OscConfig+0x2d8>)
 8001412:	f000 fead 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:436
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001416:	4b27      	ldr	r3, [pc, #156]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 8001418:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800141a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800141e:	641a      	str	r2, [r3, #64]	; 0x40
 8001420:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001422:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001426:	9301      	str	r3, [sp, #4]
 8001428:	9b01      	ldr	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:439
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 800142a:	4a26      	ldr	r2, [pc, #152]	; (80014c4 <HAL_RCC_OscConfig+0x2ec>)
 800142c:	6813      	ldr	r3, [r2, #0]
 800142e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001432:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:442
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8001434:	f004 f9d8 	bl	80057e8 <HAL_GetTick>
 8001438:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:444
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800143a:	e005      	b.n	8001448 <HAL_RCC_OscConfig+0x270>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:446
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800143c:	f004 f9d4 	bl	80057e8 <HAL_GetTick>
 8001440:	1b40      	subs	r0, r0, r5
 8001442:	2864      	cmp	r0, #100	; 0x64
 8001444:	f200 8102 	bhi.w	800164c <HAL_RCC_OscConfig+0x474>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:444
    PWR->CR |= PWR_CR_DBP;
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001448:	4b1e      	ldr	r3, [pc, #120]	; (80014c4 <HAL_RCC_OscConfig+0x2ec>)
 800144a:	681b      	ldr	r3, [r3, #0]
 800144c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001450:	d0f4      	beq.n	800143c <HAL_RCC_OscConfig+0x264>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:453
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8001452:	2200      	movs	r2, #0
 8001454:	4b1c      	ldr	r3, [pc, #112]	; (80014c8 <HAL_RCC_OscConfig+0x2f0>)
 8001456:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:456
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001458:	f004 f9c6 	bl	80057e8 <HAL_GetTick>
 800145c:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:459
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800145e:	e007      	b.n	8001470 <HAL_RCC_OscConfig+0x298>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:461
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001460:	f004 f9c2 	bl	80057e8 <HAL_GetTick>
 8001464:	1b40      	subs	r0, r0, r5
 8001466:	f241 3388 	movw	r3, #5000	; 0x1388
 800146a:	4298      	cmp	r0, r3
 800146c:	f200 80f0 	bhi.w	8001650 <HAL_RCC_OscConfig+0x478>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:459
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001470:	4b10      	ldr	r3, [pc, #64]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 8001472:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001474:	f013 0f02 	tst.w	r3, #2
 8001478:	d1f2      	bne.n	8001460 <HAL_RCC_OscConfig+0x288>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:468
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800147a:	7a22      	ldrb	r2, [r4, #8]
 800147c:	4b12      	ldr	r3, [pc, #72]	; (80014c8 <HAL_RCC_OscConfig+0x2f0>)
 800147e:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:470
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8001480:	68a3      	ldr	r3, [r4, #8]
 8001482:	b18b      	cbz	r3, 80014a8 <HAL_RCC_OscConfig+0x2d0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:473
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001484:	f004 f9b0 	bl	80057e8 <HAL_GetTick>
 8001488:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:476
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800148a:	e007      	b.n	800149c <HAL_RCC_OscConfig+0x2c4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:478
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800148c:	f004 f9ac 	bl	80057e8 <HAL_GetTick>
 8001490:	1b40      	subs	r0, r0, r5
 8001492:	f241 3388 	movw	r3, #5000	; 0x1388
 8001496:	4298      	cmp	r0, r3
 8001498:	f200 80dc 	bhi.w	8001654 <HAL_RCC_OscConfig+0x47c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:476
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800149c:	4b05      	ldr	r3, [pc, #20]	; (80014b4 <HAL_RCC_OscConfig+0x2dc>)
 800149e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80014a0:	f013 0f02 	tst.w	r3, #2
 80014a4:	d0f2      	beq.n	800148c <HAL_RCC_OscConfig+0x2b4>
 80014a6:	e01e      	b.n	80014e6 <HAL_RCC_OscConfig+0x30e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:487
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80014a8:	f004 f99e 	bl	80057e8 <HAL_GetTick>
 80014ac:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:490
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80014ae:	e015      	b.n	80014dc <HAL_RCC_OscConfig+0x304>
 80014b0:	08006700 	.word	0x08006700
 80014b4:	40023800 	.word	0x40023800
 80014b8:	40023802 	.word	0x40023802
 80014bc:	42470000 	.word	0x42470000
 80014c0:	42470e80 	.word	0x42470e80
 80014c4:	40007000 	.word	0x40007000
 80014c8:	40023870 	.word	0x40023870
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:492
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80014cc:	f004 f98c 	bl	80057e8 <HAL_GetTick>
 80014d0:	1b40      	subs	r0, r0, r5
 80014d2:	f241 3388 	movw	r3, #5000	; 0x1388
 80014d6:	4298      	cmp	r0, r3
 80014d8:	f200 80be 	bhi.w	8001658 <HAL_RCC_OscConfig+0x480>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:490
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80014dc:	4b65      	ldr	r3, [pc, #404]	; (8001674 <HAL_RCC_OscConfig+0x49c>)
 80014de:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80014e0:	f013 0f02 	tst.w	r3, #2
 80014e4:	d1f2      	bne.n	80014cc <HAL_RCC_OscConfig+0x2f4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:501
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 80014e6:	69a3      	ldr	r3, [r4, #24]
 80014e8:	2b02      	cmp	r3, #2
 80014ea:	d904      	bls.n	80014f6 <HAL_RCC_OscConfig+0x31e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:501 (discriminator 1)
 80014ec:	f240 11f5 	movw	r1, #501	; 0x1f5
 80014f0:	4861      	ldr	r0, [pc, #388]	; (8001678 <HAL_RCC_OscConfig+0x4a0>)
 80014f2:	f000 fe3d 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:502
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80014f6:	69a3      	ldr	r3, [r4, #24]
 80014f8:	2b00      	cmp	r3, #0
 80014fa:	f000 80af 	beq.w	800165c <HAL_RCC_OscConfig+0x484>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:505
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80014fe:	4a5d      	ldr	r2, [pc, #372]	; (8001674 <HAL_RCC_OscConfig+0x49c>)
 8001500:	6892      	ldr	r2, [r2, #8]
 8001502:	f002 020c 	and.w	r2, r2, #12
 8001506:	2a08      	cmp	r2, #8
 8001508:	f000 80aa 	beq.w	8001660 <HAL_RCC_OscConfig+0x488>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:507
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800150c:	2b02      	cmp	r3, #2
 800150e:	d178      	bne.n	8001602 <HAL_RCC_OscConfig+0x42a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:510
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 8001510:	69e3      	ldr	r3, [r4, #28]
 8001512:	b13b      	cbz	r3, 8001524 <HAL_RCC_OscConfig+0x34c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:510 (discriminator 1)
 8001514:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8001518:	d004      	beq.n	8001524 <HAL_RCC_OscConfig+0x34c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:510 (discriminator 2)
 800151a:	f44f 71ff 	mov.w	r1, #510	; 0x1fe
 800151e:	4856      	ldr	r0, [pc, #344]	; (8001678 <HAL_RCC_OscConfig+0x4a0>)
 8001520:	f000 fe26 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:511
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 8001524:	6a23      	ldr	r3, [r4, #32]
 8001526:	2b3f      	cmp	r3, #63	; 0x3f
 8001528:	d904      	bls.n	8001534 <HAL_RCC_OscConfig+0x35c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:511 (discriminator 1)
 800152a:	f240 11ff 	movw	r1, #511	; 0x1ff
 800152e:	4852      	ldr	r0, [pc, #328]	; (8001678 <HAL_RCC_OscConfig+0x4a0>)
 8001530:	f000 fe1e 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:512
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 8001534:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001536:	3bc0      	subs	r3, #192	; 0xc0
 8001538:	2bf0      	cmp	r3, #240	; 0xf0
 800153a:	d904      	bls.n	8001546 <HAL_RCC_OscConfig+0x36e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:512 (discriminator 1)
 800153c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001540:	484d      	ldr	r0, [pc, #308]	; (8001678 <HAL_RCC_OscConfig+0x4a0>)
 8001542:	f000 fe15 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:513
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 8001546:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001548:	2b02      	cmp	r3, #2
 800154a:	d00a      	beq.n	8001562 <HAL_RCC_OscConfig+0x38a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:513 (discriminator 1)
 800154c:	2b04      	cmp	r3, #4
 800154e:	d008      	beq.n	8001562 <HAL_RCC_OscConfig+0x38a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:513 (discriminator 2)
 8001550:	2b06      	cmp	r3, #6
 8001552:	d006      	beq.n	8001562 <HAL_RCC_OscConfig+0x38a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:513 (discriminator 3)
 8001554:	2b08      	cmp	r3, #8
 8001556:	d004      	beq.n	8001562 <HAL_RCC_OscConfig+0x38a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:513 (discriminator 4)
 8001558:	f240 2101 	movw	r1, #513	; 0x201
 800155c:	4846      	ldr	r0, [pc, #280]	; (8001678 <HAL_RCC_OscConfig+0x4a0>)
 800155e:	f000 fe07 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:514
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 8001562:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001564:	3b04      	subs	r3, #4
 8001566:	2b0b      	cmp	r3, #11
 8001568:	d904      	bls.n	8001574 <HAL_RCC_OscConfig+0x39c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:514 (discriminator 1)
 800156a:	f240 2102 	movw	r1, #514	; 0x202
 800156e:	4842      	ldr	r0, [pc, #264]	; (8001678 <HAL_RCC_OscConfig+0x4a0>)
 8001570:	f000 fdfe 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:517
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001574:	2200      	movs	r2, #0
 8001576:	4b41      	ldr	r3, [pc, #260]	; (800167c <HAL_RCC_OscConfig+0x4a4>)
 8001578:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:520
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800157a:	f004 f935 	bl	80057e8 <HAL_GetTick>
 800157e:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:523
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001580:	e004      	b.n	800158c <HAL_RCC_OscConfig+0x3b4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:525
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001582:	f004 f931 	bl	80057e8 <HAL_GetTick>
 8001586:	1b40      	subs	r0, r0, r5
 8001588:	2864      	cmp	r0, #100	; 0x64
 800158a:	d86b      	bhi.n	8001664 <HAL_RCC_OscConfig+0x48c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:523
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800158c:	4b39      	ldr	r3, [pc, #228]	; (8001674 <HAL_RCC_OscConfig+0x49c>)
 800158e:	681b      	ldr	r3, [r3, #0]
 8001590:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001594:	d1f5      	bne.n	8001582 <HAL_RCC_OscConfig+0x3aa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:532
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001596:	69e1      	ldr	r1, [r4, #28]
 8001598:	6a23      	ldr	r3, [r4, #32]
 800159a:	4319      	orrs	r1, r3
 800159c:	6a63      	ldr	r3, [r4, #36]	; 0x24
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 800159e:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80015a2:	fa92 f2a2 	rbit	r2, r2
HAL_RCC_OscConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:532
 80015a6:	fab2 f282 	clz	r2, r2
 80015aa:	4093      	lsls	r3, r2
 80015ac:	4319      	orrs	r1, r3
 80015ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80015b0:	085b      	lsrs	r3, r3, #1
 80015b2:	1e5a      	subs	r2, r3, #1
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 80015b4:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80015b8:	fa93 f3a3 	rbit	r3, r3
HAL_RCC_OscConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:532
 80015bc:	fab3 f383 	clz	r3, r3
 80015c0:	fa02 f303 	lsl.w	r3, r2, r3
 80015c4:	430b      	orrs	r3, r1
 80015c6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 80015c8:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 80015cc:	fa91 f1a1 	rbit	r1, r1
HAL_RCC_OscConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:532
 80015d0:	fab1 f181 	clz	r1, r1
 80015d4:	408a      	lsls	r2, r1
 80015d6:	4313      	orrs	r3, r2
 80015d8:	4a26      	ldr	r2, [pc, #152]	; (8001674 <HAL_RCC_OscConfig+0x49c>)
 80015da:	6053      	str	r3, [r2, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:538
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1) -1) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80015dc:	2201      	movs	r2, #1
 80015de:	4b27      	ldr	r3, [pc, #156]	; (800167c <HAL_RCC_OscConfig+0x4a4>)
 80015e0:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:541

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80015e2:	f004 f901 	bl	80057e8 <HAL_GetTick>
 80015e6:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:544
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80015e8:	e004      	b.n	80015f4 <HAL_RCC_OscConfig+0x41c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:546
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80015ea:	f004 f8fd 	bl	80057e8 <HAL_GetTick>
 80015ee:	1b00      	subs	r0, r0, r4
 80015f0:	2864      	cmp	r0, #100	; 0x64
 80015f2:	d839      	bhi.n	8001668 <HAL_RCC_OscConfig+0x490>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:544

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80015f4:	4b1f      	ldr	r3, [pc, #124]	; (8001674 <HAL_RCC_OscConfig+0x49c>)
 80015f6:	681b      	ldr	r3, [r3, #0]
 80015f8:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80015fc:	d0f5      	beq.n	80015ea <HAL_RCC_OscConfig+0x412>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:575
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80015fe:	2000      	movs	r0, #0
 8001600:	e035      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:555
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001602:	2200      	movs	r2, #0
 8001604:	4b1d      	ldr	r3, [pc, #116]	; (800167c <HAL_RCC_OscConfig+0x4a4>)
 8001606:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:558
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001608:	f004 f8ee 	bl	80057e8 <HAL_GetTick>
 800160c:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:561
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800160e:	e004      	b.n	800161a <HAL_RCC_OscConfig+0x442>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:563
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001610:	f004 f8ea 	bl	80057e8 <HAL_GetTick>
 8001614:	1b00      	subs	r0, r0, r4
 8001616:	2864      	cmp	r0, #100	; 0x64
 8001618:	d828      	bhi.n	800166c <HAL_RCC_OscConfig+0x494>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:561
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800161a:	4b16      	ldr	r3, [pc, #88]	; (8001674 <HAL_RCC_OscConfig+0x49c>)
 800161c:	681b      	ldr	r3, [r3, #0]
 800161e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001622:	d1f5      	bne.n	8001610 <HAL_RCC_OscConfig+0x438>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:575
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001624:	2000      	movs	r0, #0
 8001626:	e022      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:268
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
      {
        return HAL_ERROR;
 8001628:	2001      	movs	r0, #1
 800162a:	e020      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:284
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
        {
          return HAL_TIMEOUT;
 800162c:	2003      	movs	r0, #3
 800162e:	e01e      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:302
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001630:	2003      	movs	r0, #3
 8001632:	e01c      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:316
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001634:	2003      	movs	r0, #3
 8001636:	e01a      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:336
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
      {
        return HAL_ERROR;
 8001638:	2001      	movs	r0, #1
 800163a:	e018      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:361
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 800163c:	2003      	movs	r0, #3
 800163e:	e016      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:381
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001640:	2003      	movs	r0, #3
 8001642:	e014      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:407
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
        {
          return HAL_TIMEOUT;
 8001644:	2003      	movs	r0, #3
 8001646:	e012      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:424
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
        {
          return HAL_TIMEOUT;
 8001648:	2003      	movs	r0, #3
 800164a:	e010      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:448
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
      {
        return HAL_TIMEOUT;
 800164c:	2003      	movs	r0, #3
 800164e:	e00e      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:463
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
      {
        return HAL_TIMEOUT;
 8001650:	2003      	movs	r0, #3
 8001652:	e00c      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:480
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
        {
          return HAL_TIMEOUT;
 8001654:	2003      	movs	r0, #3
 8001656:	e00a      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:494
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
        {
          return HAL_TIMEOUT;
 8001658:	2003      	movs	r0, #3
 800165a:	e008      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:575
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 800165c:	2000      	movs	r0, #0
 800165e:	e006      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:572
        }
      }
    }
    else
    {
      return HAL_ERROR;
 8001660:	2001      	movs	r0, #1
 8001662:	e004      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:527
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001664:	2003      	movs	r0, #3
 8001666:	e002      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:548
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001668:	2003      	movs	r0, #3
 800166a:	e000      	b.n	800166e <HAL_RCC_OscConfig+0x496>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:565
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 800166c:	2003      	movs	r0, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:576
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 800166e:	b003      	add	sp, #12
 8001670:	bd30      	pop	{r4, r5, pc}
 8001672:	bf00      	nop
 8001674:	40023800 	.word	0x40023800
 8001678:	08006700 	.word	0x08006700
 800167c:	42470060 	.word	0x42470060

08001680 <HAL_RCC_ClockConfig>:
HAL_RCC_ClockConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:604
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001680:	b570      	push	{r4, r5, r6, lr}
 8001682:	4604      	mov	r4, r0
 8001684:	460d      	mov	r5, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:608
  uint32_t tickstart = 0;   
 
  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8001686:	6803      	ldr	r3, [r0, #0]
 8001688:	3b01      	subs	r3, #1
 800168a:	2b0e      	cmp	r3, #14
 800168c:	d904      	bls.n	8001698 <HAL_RCC_ClockConfig+0x18>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:608 (discriminator 1)
 800168e:	f44f 7118 	mov.w	r1, #608	; 0x260
 8001692:	4894      	ldr	r0, [pc, #592]	; (80018e4 <HAL_RCC_ClockConfig+0x264>)
 8001694:	f000 fd6c 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:609
  assert_param(IS_FLASH_LATENCY(FLatency));
 8001698:	2d07      	cmp	r5, #7
 800169a:	d904      	bls.n	80016a6 <HAL_RCC_ClockConfig+0x26>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:609 (discriminator 1)
 800169c:	f240 2161 	movw	r1, #609	; 0x261
 80016a0:	4890      	ldr	r0, [pc, #576]	; (80018e4 <HAL_RCC_ClockConfig+0x264>)
 80016a2:	f000 fd65 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:616
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80016a6:	4b90      	ldr	r3, [pc, #576]	; (80018e8 <HAL_RCC_ClockConfig+0x268>)
 80016a8:	681b      	ldr	r3, [r3, #0]
 80016aa:	f003 030f 	and.w	r3, r3, #15
 80016ae:	429d      	cmp	r5, r3
 80016b0:	f240 8098 	bls.w	80017e4 <HAL_RCC_ClockConfig+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:619
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80016b4:	b2ea      	uxtb	r2, r5
 80016b6:	4b8c      	ldr	r3, [pc, #560]	; (80018e8 <HAL_RCC_ClockConfig+0x268>)
 80016b8:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:623
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80016ba:	681b      	ldr	r3, [r3, #0]
 80016bc:	f003 030f 	and.w	r3, r3, #15
 80016c0:	429d      	cmp	r5, r3
 80016c2:	f040 816b 	bne.w	800199c <HAL_RCC_ClockConfig+0x31c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:629
    {
      return HAL_ERROR;
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80016c6:	6823      	ldr	r3, [r4, #0]
 80016c8:	f013 0f02 	tst.w	r3, #2
 80016cc:	d01d      	beq.n	800170a <HAL_RCC_ClockConfig+0x8a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 80016ce:	68a3      	ldr	r3, [r4, #8]
 80016d0:	b1a3      	cbz	r3, 80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 1)
 80016d2:	2b80      	cmp	r3, #128	; 0x80
 80016d4:	d012      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 2)
 80016d6:	2b90      	cmp	r3, #144	; 0x90
 80016d8:	d010      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 3)
 80016da:	2ba0      	cmp	r3, #160	; 0xa0
 80016dc:	d00e      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 4)
 80016de:	2bb0      	cmp	r3, #176	; 0xb0
 80016e0:	d00c      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 5)
 80016e2:	2bc0      	cmp	r3, #192	; 0xc0
 80016e4:	d00a      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 6)
 80016e6:	2bd0      	cmp	r3, #208	; 0xd0
 80016e8:	d008      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 7)
 80016ea:	2be0      	cmp	r3, #224	; 0xe0
 80016ec:	d006      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 8)
 80016ee:	2bf0      	cmp	r3, #240	; 0xf0
 80016f0:	d004      	beq.n	80016fc <HAL_RCC_ClockConfig+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:631 (discriminator 9)
 80016f2:	f240 2177 	movw	r1, #631	; 0x277
 80016f6:	487b      	ldr	r0, [pc, #492]	; (80018e4 <HAL_RCC_ClockConfig+0x264>)
 80016f8:	f000 fd3a 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:632
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80016fc:	497b      	ldr	r1, [pc, #492]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 80016fe:	688b      	ldr	r3, [r1, #8]
 8001700:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001704:	68a3      	ldr	r3, [r4, #8]
 8001706:	4313      	orrs	r3, r2
 8001708:	608b      	str	r3, [r1, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:636
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800170a:	6823      	ldr	r3, [r4, #0]
 800170c:	f013 0f01 	tst.w	r3, #1
 8001710:	f000 8102 	beq.w	8001918 <HAL_RCC_ClockConfig+0x298>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:638
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8001714:	6863      	ldr	r3, [r4, #4]
 8001716:	2b03      	cmp	r3, #3
 8001718:	d904      	bls.n	8001724 <HAL_RCC_ClockConfig+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:638 (discriminator 1)
 800171a:	f240 217e 	movw	r1, #638	; 0x27e
 800171e:	4871      	ldr	r0, [pc, #452]	; (80018e4 <HAL_RCC_ClockConfig+0x264>)
 8001720:	f000 fd26 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:641
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001724:	6862      	ldr	r2, [r4, #4]
 8001726:	2a01      	cmp	r2, #1
 8001728:	d105      	bne.n	8001736 <HAL_RCC_ClockConfig+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:644
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800172a:	4b70      	ldr	r3, [pc, #448]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 800172c:	681b      	ldr	r3, [r3, #0]
 800172e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001732:	d10f      	bne.n	8001754 <HAL_RCC_ClockConfig+0xd4>
 8001734:	e134      	b.n	80019a0 <HAL_RCC_ClockConfig+0x320>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:650
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001736:	1e93      	subs	r3, r2, #2
 8001738:	2b01      	cmp	r3, #1
 800173a:	d805      	bhi.n	8001748 <HAL_RCC_ClockConfig+0xc8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:654
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800173c:	4b6b      	ldr	r3, [pc, #428]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 800173e:	681b      	ldr	r3, [r3, #0]
 8001740:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001744:	d106      	bne.n	8001754 <HAL_RCC_ClockConfig+0xd4>
 8001746:	e12d      	b.n	80019a4 <HAL_RCC_ClockConfig+0x324>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:663
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001748:	4b68      	ldr	r3, [pc, #416]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 800174a:	681b      	ldr	r3, [r3, #0]
 800174c:	f013 0f02 	tst.w	r3, #2
 8001750:	f000 812a 	beq.w	80019a8 <HAL_RCC_ClockConfig+0x328>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:669
        {
          return HAL_ERROR;
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001754:	4965      	ldr	r1, [pc, #404]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 8001756:	688b      	ldr	r3, [r1, #8]
 8001758:	f023 0303 	bic.w	r3, r3, #3
 800175c:	4313      	orrs	r3, r2
 800175e:	608b      	str	r3, [r1, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:671
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001760:	f004 f842 	bl	80057e8 <HAL_GetTick>
 8001764:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:673
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001766:	6863      	ldr	r3, [r4, #4]
 8001768:	2b01      	cmp	r3, #1
 800176a:	d10f      	bne.n	800178c <HAL_RCC_ClockConfig+0x10c>
 800176c:	e007      	b.n	800177e <HAL_RCC_ClockConfig+0xfe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:677
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800176e:	f004 f83b 	bl	80057e8 <HAL_GetTick>
 8001772:	1b40      	subs	r0, r0, r5
 8001774:	f241 3388 	movw	r3, #5000	; 0x1388
 8001778:	4298      	cmp	r0, r3
 800177a:	f200 8117 	bhi.w	80019ac <HAL_RCC_ClockConfig+0x32c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:675
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800177e:	4b5b      	ldr	r3, [pc, #364]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 8001780:	689b      	ldr	r3, [r3, #8]
 8001782:	f003 030c 	and.w	r3, r3, #12
 8001786:	2b04      	cmp	r3, #4
 8001788:	d1f1      	bne.n	800176e <HAL_RCC_ClockConfig+0xee>
 800178a:	e0c5      	b.n	8001918 <HAL_RCC_ClockConfig+0x298>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:683
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800178c:	2b02      	cmp	r3, #2
 800178e:	d10f      	bne.n	80017b0 <HAL_RCC_ClockConfig+0x130>
 8001790:	e007      	b.n	80017a2 <HAL_RCC_ClockConfig+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:687
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001792:	f004 f829 	bl	80057e8 <HAL_GetTick>
 8001796:	1b40      	subs	r0, r0, r5
 8001798:	f241 3388 	movw	r3, #5000	; 0x1388
 800179c:	4298      	cmp	r0, r3
 800179e:	f200 8107 	bhi.w	80019b0 <HAL_RCC_ClockConfig+0x330>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:685
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80017a2:	4b52      	ldr	r3, [pc, #328]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 80017a4:	689b      	ldr	r3, [r3, #8]
 80017a6:	f003 030c 	and.w	r3, r3, #12
 80017aa:	2b08      	cmp	r3, #8
 80017ac:	d1f1      	bne.n	8001792 <HAL_RCC_ClockConfig+0x112>
 80017ae:	e0b3      	b.n	8001918 <HAL_RCC_ClockConfig+0x298>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:693
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 80017b0:	2b03      	cmp	r3, #3
 80017b2:	d111      	bne.n	80017d8 <HAL_RCC_ClockConfig+0x158>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:695
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 80017b4:	4b4d      	ldr	r3, [pc, #308]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 80017b6:	689b      	ldr	r3, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:697
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80017b8:	f004 f816 	bl	80057e8 <HAL_GetTick>
 80017bc:	1b40      	subs	r0, r0, r5
 80017be:	f241 3388 	movw	r3, #5000	; 0x1388
 80017c2:	4298      	cmp	r0, r3
 80017c4:	d9f6      	bls.n	80017b4 <HAL_RCC_ClockConfig+0x134>
 80017c6:	e0f5      	b.n	80019b4 <HAL_RCC_ClockConfig+0x334>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:707
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80017c8:	f004 f80e 	bl	80057e8 <HAL_GetTick>
 80017cc:	1b40      	subs	r0, r0, r5
 80017ce:	f241 3388 	movw	r3, #5000	; 0x1388
 80017d2:	4298      	cmp	r0, r3
 80017d4:	f200 80f0 	bhi.w	80019b8 <HAL_RCC_ClockConfig+0x338>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:705
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80017d8:	4b44      	ldr	r3, [pc, #272]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 80017da:	689b      	ldr	r3, [r3, #8]
 80017dc:	f013 0f0c 	tst.w	r3, #12
 80017e0:	d1f2      	bne.n	80017c8 <HAL_RCC_ClockConfig+0x148>
 80017e2:	e099      	b.n	8001918 <HAL_RCC_ClockConfig+0x298>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:719
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80017e4:	6823      	ldr	r3, [r4, #0]
 80017e6:	f013 0f02 	tst.w	r3, #2
 80017ea:	d01d      	beq.n	8001828 <HAL_RCC_ClockConfig+0x1a8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 80017ec:	68a3      	ldr	r3, [r4, #8]
 80017ee:	b1a3      	cbz	r3, 800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 1)
 80017f0:	2b80      	cmp	r3, #128	; 0x80
 80017f2:	d012      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 2)
 80017f4:	2b90      	cmp	r3, #144	; 0x90
 80017f6:	d010      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 3)
 80017f8:	2ba0      	cmp	r3, #160	; 0xa0
 80017fa:	d00e      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 4)
 80017fc:	2bb0      	cmp	r3, #176	; 0xb0
 80017fe:	d00c      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 5)
 8001800:	2bc0      	cmp	r3, #192	; 0xc0
 8001802:	d00a      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 6)
 8001804:	2bd0      	cmp	r3, #208	; 0xd0
 8001806:	d008      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 7)
 8001808:	2be0      	cmp	r3, #224	; 0xe0
 800180a:	d006      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 8)
 800180c:	2bf0      	cmp	r3, #240	; 0xf0
 800180e:	d004      	beq.n	800181a <HAL_RCC_ClockConfig+0x19a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:721 (discriminator 9)
 8001810:	f240 21d1 	movw	r1, #721	; 0x2d1
 8001814:	4833      	ldr	r0, [pc, #204]	; (80018e4 <HAL_RCC_ClockConfig+0x264>)
 8001816:	f000 fcab 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:722
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800181a:	4934      	ldr	r1, [pc, #208]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 800181c:	688b      	ldr	r3, [r1, #8]
 800181e:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001822:	68a3      	ldr	r3, [r4, #8]
 8001824:	4313      	orrs	r3, r2
 8001826:	608b      	str	r3, [r1, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:726
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001828:	6823      	ldr	r3, [r4, #0]
 800182a:	f013 0f01 	tst.w	r3, #1
 800182e:	d06b      	beq.n	8001908 <HAL_RCC_ClockConfig+0x288>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:728
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8001830:	6863      	ldr	r3, [r4, #4]
 8001832:	2b03      	cmp	r3, #3
 8001834:	d904      	bls.n	8001840 <HAL_RCC_ClockConfig+0x1c0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:728 (discriminator 1)
 8001836:	f44f 7136 	mov.w	r1, #728	; 0x2d8
 800183a:	482a      	ldr	r0, [pc, #168]	; (80018e4 <HAL_RCC_ClockConfig+0x264>)
 800183c:	f000 fc98 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:731
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001840:	6862      	ldr	r2, [r4, #4]
 8001842:	2a01      	cmp	r2, #1
 8001844:	d105      	bne.n	8001852 <HAL_RCC_ClockConfig+0x1d2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:734
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001846:	4b29      	ldr	r3, [pc, #164]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 8001848:	681b      	ldr	r3, [r3, #0]
 800184a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800184e:	d10f      	bne.n	8001870 <HAL_RCC_ClockConfig+0x1f0>
 8001850:	e0b4      	b.n	80019bc <HAL_RCC_ClockConfig+0x33c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:740
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) || 
 8001852:	1e93      	subs	r3, r2, #2
 8001854:	2b01      	cmp	r3, #1
 8001856:	d805      	bhi.n	8001864 <HAL_RCC_ClockConfig+0x1e4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:744
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001858:	4b24      	ldr	r3, [pc, #144]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 800185a:	681b      	ldr	r3, [r3, #0]
 800185c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001860:	d106      	bne.n	8001870 <HAL_RCC_ClockConfig+0x1f0>
 8001862:	e0ad      	b.n	80019c0 <HAL_RCC_ClockConfig+0x340>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:753
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001864:	4b21      	ldr	r3, [pc, #132]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 8001866:	681b      	ldr	r3, [r3, #0]
 8001868:	f013 0f02 	tst.w	r3, #2
 800186c:	f000 80aa 	beq.w	80019c4 <HAL_RCC_ClockConfig+0x344>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:758
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001870:	491e      	ldr	r1, [pc, #120]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 8001872:	688b      	ldr	r3, [r1, #8]
 8001874:	f023 0303 	bic.w	r3, r3, #3
 8001878:	4313      	orrs	r3, r2
 800187a:	608b      	str	r3, [r1, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:760
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800187c:	f003 ffb4 	bl	80057e8 <HAL_GetTick>
 8001880:	4606      	mov	r6, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:762
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001882:	6863      	ldr	r3, [r4, #4]
 8001884:	2b01      	cmp	r3, #1
 8001886:	d10f      	bne.n	80018a8 <HAL_RCC_ClockConfig+0x228>
 8001888:	e007      	b.n	800189a <HAL_RCC_ClockConfig+0x21a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:766
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800188a:	f003 ffad 	bl	80057e8 <HAL_GetTick>
 800188e:	1b80      	subs	r0, r0, r6
 8001890:	f241 3388 	movw	r3, #5000	; 0x1388
 8001894:	4298      	cmp	r0, r3
 8001896:	f200 8097 	bhi.w	80019c8 <HAL_RCC_ClockConfig+0x348>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:764
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800189a:	4b14      	ldr	r3, [pc, #80]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 800189c:	689b      	ldr	r3, [r3, #8]
 800189e:	f003 030c 	and.w	r3, r3, #12
 80018a2:	2b04      	cmp	r3, #4
 80018a4:	d1f1      	bne.n	800188a <HAL_RCC_ClockConfig+0x20a>
 80018a6:	e02f      	b.n	8001908 <HAL_RCC_ClockConfig+0x288>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:772
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80018a8:	2b02      	cmp	r3, #2
 80018aa:	d10f      	bne.n	80018cc <HAL_RCC_ClockConfig+0x24c>
 80018ac:	e007      	b.n	80018be <HAL_RCC_ClockConfig+0x23e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:776
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80018ae:	f003 ff9b 	bl	80057e8 <HAL_GetTick>
 80018b2:	1b80      	subs	r0, r0, r6
 80018b4:	f241 3388 	movw	r3, #5000	; 0x1388
 80018b8:	4298      	cmp	r0, r3
 80018ba:	f200 8087 	bhi.w	80019cc <HAL_RCC_ClockConfig+0x34c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:774
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80018be:	4b0b      	ldr	r3, [pc, #44]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 80018c0:	689b      	ldr	r3, [r3, #8]
 80018c2:	f003 030c 	and.w	r3, r3, #12
 80018c6:	2b08      	cmp	r3, #8
 80018c8:	d1f1      	bne.n	80018ae <HAL_RCC_ClockConfig+0x22e>
 80018ca:	e01d      	b.n	8001908 <HAL_RCC_ClockConfig+0x288>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:782
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 80018cc:	2b03      	cmp	r3, #3
 80018ce:	d116      	bne.n	80018fe <HAL_RCC_ClockConfig+0x27e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:784
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 80018d0:	4b06      	ldr	r3, [pc, #24]	; (80018ec <HAL_RCC_ClockConfig+0x26c>)
 80018d2:	689b      	ldr	r3, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:786
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80018d4:	f003 ff88 	bl	80057e8 <HAL_GetTick>
 80018d8:	1b80      	subs	r0, r0, r6
 80018da:	f241 3388 	movw	r3, #5000	; 0x1388
 80018de:	4298      	cmp	r0, r3
 80018e0:	d9f6      	bls.n	80018d0 <HAL_RCC_ClockConfig+0x250>
 80018e2:	e075      	b.n	80019d0 <HAL_RCC_ClockConfig+0x350>
 80018e4:	08006700 	.word	0x08006700
 80018e8:	40023c00 	.word	0x40023c00
 80018ec:	40023800 	.word	0x40023800
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:796
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80018f0:	f003 ff7a 	bl	80057e8 <HAL_GetTick>
 80018f4:	1b80      	subs	r0, r0, r6
 80018f6:	f241 3388 	movw	r3, #5000	; 0x1388
 80018fa:	4298      	cmp	r0, r3
 80018fc:	d86a      	bhi.n	80019d4 <HAL_RCC_ClockConfig+0x354>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:794
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80018fe:	4b37      	ldr	r3, [pc, #220]	; (80019dc <HAL_RCC_ClockConfig+0x35c>)
 8001900:	689b      	ldr	r3, [r3, #8]
 8001902:	f013 0f0c 	tst.w	r3, #12
 8001906:	d1f3      	bne.n	80018f0 <HAL_RCC_ClockConfig+0x270>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:805
        }
      }
    }
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001908:	b2ea      	uxtb	r2, r5
 800190a:	4b35      	ldr	r3, [pc, #212]	; (80019e0 <HAL_RCC_ClockConfig+0x360>)
 800190c:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:809
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800190e:	681b      	ldr	r3, [r3, #0]
 8001910:	f003 030f 	and.w	r3, r3, #15
 8001914:	429d      	cmp	r5, r3
 8001916:	d15f      	bne.n	80019d8 <HAL_RCC_ClockConfig+0x358>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:816
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001918:	6823      	ldr	r3, [r4, #0]
 800191a:	f013 0f04 	tst.w	r3, #4
 800191e:	d019      	beq.n	8001954 <HAL_RCC_ClockConfig+0x2d4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:818
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 8001920:	68e3      	ldr	r3, [r4, #12]
 8001922:	b183      	cbz	r3, 8001946 <HAL_RCC_ClockConfig+0x2c6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:818 (discriminator 1)
 8001924:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001928:	d00d      	beq.n	8001946 <HAL_RCC_ClockConfig+0x2c6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:818 (discriminator 2)
 800192a:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 800192e:	d00a      	beq.n	8001946 <HAL_RCC_ClockConfig+0x2c6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:818 (discriminator 3)
 8001930:	f5b3 5fc0 	cmp.w	r3, #6144	; 0x1800
 8001934:	d007      	beq.n	8001946 <HAL_RCC_ClockConfig+0x2c6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:818 (discriminator 4)
 8001936:	f5b3 5fe0 	cmp.w	r3, #7168	; 0x1c00
 800193a:	d004      	beq.n	8001946 <HAL_RCC_ClockConfig+0x2c6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:818 (discriminator 5)
 800193c:	f240 3132 	movw	r1, #818	; 0x332
 8001940:	4828      	ldr	r0, [pc, #160]	; (80019e4 <HAL_RCC_ClockConfig+0x364>)
 8001942:	f000 fc15 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:819
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001946:	4925      	ldr	r1, [pc, #148]	; (80019dc <HAL_RCC_ClockConfig+0x35c>)
 8001948:	688b      	ldr	r3, [r1, #8]
 800194a:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800194e:	68e3      	ldr	r3, [r4, #12]
 8001950:	4313      	orrs	r3, r2
 8001952:	608b      	str	r3, [r1, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:823
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001954:	6823      	ldr	r3, [r4, #0]
 8001956:	f013 0f08 	tst.w	r3, #8
 800195a:	d01a      	beq.n	8001992 <HAL_RCC_ClockConfig+0x312>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:825
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 800195c:	6923      	ldr	r3, [r4, #16]
 800195e:	b183      	cbz	r3, 8001982 <HAL_RCC_ClockConfig+0x302>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:825 (discriminator 1)
 8001960:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001964:	d00d      	beq.n	8001982 <HAL_RCC_ClockConfig+0x302>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:825 (discriminator 2)
 8001966:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 800196a:	d00a      	beq.n	8001982 <HAL_RCC_ClockConfig+0x302>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:825 (discriminator 3)
 800196c:	f5b3 5fc0 	cmp.w	r3, #6144	; 0x1800
 8001970:	d007      	beq.n	8001982 <HAL_RCC_ClockConfig+0x302>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:825 (discriminator 4)
 8001972:	f5b3 5fe0 	cmp.w	r3, #7168	; 0x1c00
 8001976:	d004      	beq.n	8001982 <HAL_RCC_ClockConfig+0x302>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:825 (discriminator 5)
 8001978:	f240 3139 	movw	r1, #825	; 0x339
 800197c:	4819      	ldr	r0, [pc, #100]	; (80019e4 <HAL_RCC_ClockConfig+0x364>)
 800197e:	f000 fbf7 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:826
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001982:	4a16      	ldr	r2, [pc, #88]	; (80019dc <HAL_RCC_ClockConfig+0x35c>)
 8001984:	6893      	ldr	r3, [r2, #8]
 8001986:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800198a:	6921      	ldr	r1, [r4, #16]
 800198c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001990:	6093      	str	r3, [r2, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:830
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001992:	2000      	movs	r0, #0
 8001994:	f7fe fce4 	bl	8000360 <HAL_InitTick>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:832
  
  return HAL_OK;
 8001998:	2000      	movs	r0, #0
 800199a:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:625
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
    {
      return HAL_ERROR;
 800199c:	2001      	movs	r0, #1
 800199e:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:646
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
        {
          return HAL_ERROR;
 80019a0:	2001      	movs	r0, #1
 80019a2:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:656
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          return HAL_ERROR;
 80019a4:	2001      	movs	r0, #1
 80019a6:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:665
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          return HAL_ERROR;
 80019a8:	2001      	movs	r0, #1
 80019aa:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:679
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019ac:	2003      	movs	r0, #3
 80019ae:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:689
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019b0:	2003      	movs	r0, #3
 80019b2:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:699
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019b4:	2003      	movs	r0, #3
 80019b6:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:709
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019b8:	2003      	movs	r0, #3
 80019ba:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:736
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
        {
          return HAL_ERROR;
 80019bc:	2001      	movs	r0, #1
 80019be:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:746
              (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          return HAL_ERROR;
 80019c0:	2001      	movs	r0, #1
 80019c2:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:755
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          return HAL_ERROR;
 80019c4:	2001      	movs	r0, #1
 80019c6:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:768
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019c8:	2003      	movs	r0, #3
 80019ca:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:778
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019cc:	2003      	movs	r0, #3
 80019ce:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:788
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019d0:	2003      	movs	r0, #3
 80019d2:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:798
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 80019d4:	2003      	movs	r0, #3
 80019d6:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:811
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
    {
      return HAL_ERROR;
 80019d8:	2001      	movs	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:833

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
  
  return HAL_OK;
}
 80019da:	bd70      	pop	{r4, r5, r6, pc}
 80019dc:	40023800 	.word	0x40023800
 80019e0:	40023c00 	.word	0x40023c00
 80019e4:	08006700 	.word	0x08006700

080019e8 <HAL_RCC_GetSysClockFreq>:
HAL_RCC_GetSysClockFreq():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:997
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80019e8:	4b24      	ldr	r3, [pc, #144]	; (8001a7c <HAL_RCC_GetSysClockFreq+0x94>)
 80019ea:	689b      	ldr	r3, [r3, #8]
 80019ec:	f003 030c 	and.w	r3, r3, #12
 80019f0:	2b04      	cmp	r3, #4
 80019f2:	d03f      	beq.n	8001a74 <HAL_RCC_GetSysClockFreq+0x8c>
 80019f4:	2b08      	cmp	r3, #8
 80019f6:	d001      	beq.n	80019fc <HAL_RCC_GetSysClockFreq+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1001
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80019f8:	4821      	ldr	r0, [pc, #132]	; (8001a80 <HAL_RCC_GetSysClockFreq+0x98>)
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1036
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80019fa:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:992
  *         
  *               
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80019fc:	b410      	push	{r4}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1013
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80019fe:	4b1f      	ldr	r3, [pc, #124]	; (8001a7c <HAL_RCC_GetSysClockFreq+0x94>)
 8001a00:	6858      	ldr	r0, [r3, #4]
 8001a02:	f000 003f 	and.w	r0, r0, #63	; 0x3f
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1014
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001a06:	685b      	ldr	r3, [r3, #4]
 8001a08:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001a0c:	d010      	beq.n	8001a30 <HAL_RCC_GetSysClockFreq+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1017
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8001a0e:	4b1d      	ldr	r3, [pc, #116]	; (8001a84 <HAL_RCC_GetSysClockFreq+0x9c>)
 8001a10:	fbb3 f0f0 	udiv	r0, r3, r0
 8001a14:	4b19      	ldr	r3, [pc, #100]	; (8001a7c <HAL_RCC_GetSysClockFreq+0x94>)
 8001a16:	685a      	ldr	r2, [r3, #4]
 8001a18:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8001a1c:	400a      	ands	r2, r1
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 8001a1e:	fa91 f3a1 	rbit	r3, r1
HAL_RCC_GetSysClockFreq():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1017
 8001a22:	fab3 f383 	clz	r3, r3
 8001a26:	fa22 f303 	lsr.w	r3, r2, r3
 8001a2a:	fb03 f300 	mul.w	r3, r3, r0
 8001a2e:	e010      	b.n	8001a52 <HAL_RCC_GetSysClockFreq+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1022
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001a30:	4b13      	ldr	r3, [pc, #76]	; (8001a80 <HAL_RCC_GetSysClockFreq+0x98>)
 8001a32:	fbb3 f0f0 	udiv	r0, r3, r0
 8001a36:	4b11      	ldr	r3, [pc, #68]	; (8001a7c <HAL_RCC_GetSysClockFreq+0x94>)
 8001a38:	685a      	ldr	r2, [r3, #4]
 8001a3a:	f647 74c0 	movw	r4, #32704	; 0x7fc0
 8001a3e:	ea02 0104 	and.w	r1, r2, r4
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 8001a42:	fa94 f2a4 	rbit	r2, r4
HAL_RCC_GetSysClockFreq():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1022
 8001a46:	fab2 f282 	clz	r2, r2
 8001a4a:	fa21 f202 	lsr.w	r2, r1, r2
 8001a4e:	fb02 f300 	mul.w	r3, r2, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1024
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8001a52:	4a0a      	ldr	r2, [pc, #40]	; (8001a7c <HAL_RCC_GetSysClockFreq+0x94>)
 8001a54:	6850      	ldr	r0, [r2, #4]
 8001a56:	f400 3240 	and.w	r2, r0, #196608	; 0x30000
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 8001a5a:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8001a5e:	fa90 f0a0 	rbit	r0, r0
HAL_RCC_GetSysClockFreq():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1024
 8001a62:	fab0 f080 	clz	r0, r0
 8001a66:	fa22 f000 	lsr.w	r0, r2, r0
 8001a6a:	3001      	adds	r0, #1
 8001a6c:	0040      	lsls	r0, r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1026
      
      sysclockfreq = pllvco/pllp;
 8001a6e:	fbb3 f0f0 	udiv	r0, r3, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1027
      break;
 8001a72:	e001      	b.n	8001a78 <HAL_RCC_GetSysClockFreq+0x90>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1006
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8001a74:	4803      	ldr	r0, [pc, #12]	; (8001a84 <HAL_RCC_GetSysClockFreq+0x9c>)
 8001a76:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1036
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001a78:	bc10      	pop	{r4}
 8001a7a:	4770      	bx	lr
 8001a7c:	40023800 	.word	0x40023800
 8001a80:	00f42400 	.word	0x00f42400
 8001a84:	007a1200 	.word	0x007a1200

08001a88 <HAL_RCC_GetHCLKFreq>:
HAL_RCC_GetHCLKFreq():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1048
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8001a88:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1049
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001a8a:	f7ff ffad 	bl	80019e8 <HAL_RCC_GetSysClockFreq>
 8001a8e:	4b08      	ldr	r3, [pc, #32]	; (8001ab0 <HAL_RCC_GetHCLKFreq+0x28>)
 8001a90:	689b      	ldr	r3, [r3, #8]
 8001a92:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
__RBIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:531
 8001a96:	23f0      	movs	r3, #240	; 0xf0
 8001a98:	fa93 f3a3 	rbit	r3, r3
HAL_RCC_GetHCLKFreq():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1049
 8001a9c:	fab3 f383 	clz	r3, r3
 8001aa0:	fa22 f303 	lsr.w	r3, r2, r3
 8001aa4:	4a03      	ldr	r2, [pc, #12]	; (8001ab4 <HAL_RCC_GetHCLKFreq+0x2c>)
 8001aa6:	5cd3      	ldrb	r3, [r2, r3]
 8001aa8:	40d8      	lsrs	r0, r3
 8001aaa:	4b03      	ldr	r3, [pc, #12]	; (8001ab8 <HAL_RCC_GetHCLKFreq+0x30>)
 8001aac:	6018      	str	r0, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_rcc.c:1051
  return SystemCoreClock;
}
 8001aae:	bd08      	pop	{r3, pc}
 8001ab0:	40023800 	.word	0x40023800
 8001ab4:	080066f0 	.word	0x080066f0
 8001ab8:	2000000c 	.word	0x2000000c

08001abc <HAL_SPI_MspInit>:
HAL_SPI_MspInit():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:268
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval None
  */
 __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
 {
 8001abc:	4770      	bx	lr
 8001abe:	bf00      	nop

08001ac0 <HAL_SPI_Init>:
HAL_SPI_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:178
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 8001ac0:	2800      	cmp	r0, #0
 8001ac2:	f000 80af 	beq.w	8001c24 <HAL_SPI_Init+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:176
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001ac6:	b510      	push	{r4, lr}
 8001ac8:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:184
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_SPI_MODE(hspi->Init.Mode));
 8001aca:	6843      	ldr	r3, [r0, #4]
 8001acc:	b133      	cbz	r3, 8001adc <HAL_SPI_Init+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:184 (discriminator 1)
 8001ace:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8001ad2:	d003      	beq.n	8001adc <HAL_SPI_Init+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:184 (discriminator 2)
 8001ad4:	21b8      	movs	r1, #184	; 0xb8
 8001ad6:	4854      	ldr	r0, [pc, #336]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001ad8:	f000 fb4a 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:185
  assert_param(IS_SPI_DIRECTION_MODE(hspi->Init.Direction));
 8001adc:	68a3      	ldr	r3, [r4, #8]
 8001ade:	b14b      	cbz	r3, 8001af4 <HAL_SPI_Init+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:185 (discriminator 1)
 8001ae0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001ae4:	d006      	beq.n	8001af4 <HAL_SPI_Init+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:185 (discriminator 2)
 8001ae6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001aea:	d003      	beq.n	8001af4 <HAL_SPI_Init+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:185 (discriminator 3)
 8001aec:	21b9      	movs	r1, #185	; 0xb9
 8001aee:	484e      	ldr	r0, [pc, #312]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001af0:	f000 fb3e 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:186
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
 8001af4:	68e3      	ldr	r3, [r4, #12]
 8001af6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8001afa:	d004      	beq.n	8001b06 <HAL_SPI_Init+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:186 (discriminator 1)
 8001afc:	b11b      	cbz	r3, 8001b06 <HAL_SPI_Init+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:186 (discriminator 2)
 8001afe:	21ba      	movs	r1, #186	; 0xba
 8001b00:	4849      	ldr	r0, [pc, #292]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b02:	f000 fb35 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:187
  assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
 8001b06:	6923      	ldr	r3, [r4, #16]
 8001b08:	b12b      	cbz	r3, 8001b16 <HAL_SPI_Init+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:187 (discriminator 1)
 8001b0a:	2b02      	cmp	r3, #2
 8001b0c:	d003      	beq.n	8001b16 <HAL_SPI_Init+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:187 (discriminator 2)
 8001b0e:	21bb      	movs	r1, #187	; 0xbb
 8001b10:	4845      	ldr	r0, [pc, #276]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b12:	f000 fb2d 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:188
  assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
 8001b16:	6963      	ldr	r3, [r4, #20]
 8001b18:	2b01      	cmp	r3, #1
 8001b1a:	d903      	bls.n	8001b24 <HAL_SPI_Init+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:188 (discriminator 1)
 8001b1c:	21bc      	movs	r1, #188	; 0xbc
 8001b1e:	4842      	ldr	r0, [pc, #264]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b20:	f000 fb26 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:189
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
 8001b24:	69a3      	ldr	r3, [r4, #24]
 8001b26:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001b2a:	d007      	beq.n	8001b3c <HAL_SPI_Init+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:189 (discriminator 1)
 8001b2c:	b133      	cbz	r3, 8001b3c <HAL_SPI_Init+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:189 (discriminator 2)
 8001b2e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001b32:	d003      	beq.n	8001b3c <HAL_SPI_Init+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:189 (discriminator 3)
 8001b34:	21bd      	movs	r1, #189	; 0xbd
 8001b36:	483c      	ldr	r0, [pc, #240]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b38:	f000 fb1a 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 8001b3c:	69e3      	ldr	r3, [r4, #28]
 8001b3e:	b18b      	cbz	r3, 8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 1)
 8001b40:	2b08      	cmp	r3, #8
 8001b42:	d00f      	beq.n	8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 2)
 8001b44:	2b10      	cmp	r3, #16
 8001b46:	d00d      	beq.n	8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 3)
 8001b48:	2b18      	cmp	r3, #24
 8001b4a:	d00b      	beq.n	8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 4)
 8001b4c:	2b20      	cmp	r3, #32
 8001b4e:	d009      	beq.n	8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 5)
 8001b50:	2b28      	cmp	r3, #40	; 0x28
 8001b52:	d007      	beq.n	8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 6)
 8001b54:	2b30      	cmp	r3, #48	; 0x30
 8001b56:	d005      	beq.n	8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 7)
 8001b58:	2b38      	cmp	r3, #56	; 0x38
 8001b5a:	d003      	beq.n	8001b64 <HAL_SPI_Init+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:190 (discriminator 8)
 8001b5c:	21be      	movs	r1, #190	; 0xbe
 8001b5e:	4832      	ldr	r0, [pc, #200]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b60:	f000 fb06 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:191
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
 8001b64:	6a23      	ldr	r3, [r4, #32]
 8001b66:	b12b      	cbz	r3, 8001b74 <HAL_SPI_Init+0xb4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:191 (discriminator 1)
 8001b68:	2b80      	cmp	r3, #128	; 0x80
 8001b6a:	d003      	beq.n	8001b74 <HAL_SPI_Init+0xb4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:191 (discriminator 2)
 8001b6c:	21bf      	movs	r1, #191	; 0xbf
 8001b6e:	482e      	ldr	r0, [pc, #184]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b70:	f000 fafe 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:192
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
 8001b74:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001b76:	b12b      	cbz	r3, 8001b84 <HAL_SPI_Init+0xc4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:192 (discriminator 1)
 8001b78:	2b10      	cmp	r3, #16
 8001b7a:	d003      	beq.n	8001b84 <HAL_SPI_Init+0xc4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:192 (discriminator 2)
 8001b7c:	21c0      	movs	r1, #192	; 0xc0
 8001b7e:	482a      	ldr	r0, [pc, #168]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b80:	f000 faf6 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:193
  assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
 8001b84:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001b86:	b133      	cbz	r3, 8001b96 <HAL_SPI_Init+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:193 (discriminator 1)
 8001b88:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001b8c:	d003      	beq.n	8001b96 <HAL_SPI_Init+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:193 (discriminator 2)
 8001b8e:	21c1      	movs	r1, #193	; 0xc1
 8001b90:	4825      	ldr	r0, [pc, #148]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001b92:	f000 faed 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:194
  assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
 8001b96:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001b98:	3b01      	subs	r3, #1
 8001b9a:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8001b9e:	4293      	cmp	r3, r2
 8001ba0:	d903      	bls.n	8001baa <HAL_SPI_Init+0xea>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:194 (discriminator 1)
 8001ba2:	21c2      	movs	r1, #194	; 0xc2
 8001ba4:	4820      	ldr	r0, [pc, #128]	; (8001c28 <HAL_SPI_Init+0x168>)
 8001ba6:	f000 fae3 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:196

  if(hspi->State == HAL_SPI_STATE_RESET)
 8001baa:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 8001bae:	f013 0fff 	tst.w	r3, #255	; 0xff
 8001bb2:	d105      	bne.n	8001bc0 <HAL_SPI_Init+0x100>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:199
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001bb4:	2300      	movs	r3, #0
 8001bb6:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:201
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8001bba:	4620      	mov	r0, r4
 8001bbc:	f7ff ff7e 	bl	8001abc <HAL_SPI_MspInit>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:204
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;
 8001bc0:	2302      	movs	r3, #2
 8001bc2:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:207

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001bc6:	6822      	ldr	r2, [r4, #0]
 8001bc8:	6813      	ldr	r3, [r2, #0]
 8001bca:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001bce:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:212

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001bd0:	6821      	ldr	r1, [r4, #0]
 8001bd2:	6862      	ldr	r2, [r4, #4]
 8001bd4:	68a3      	ldr	r3, [r4, #8]
 8001bd6:	431a      	orrs	r2, r3
 8001bd8:	68e3      	ldr	r3, [r4, #12]
 8001bda:	431a      	orrs	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:213
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 8001bdc:	6923      	ldr	r3, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:212
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001bde:	431a      	orrs	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:213
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 8001be0:	6963      	ldr	r3, [r4, #20]
 8001be2:	431a      	orrs	r2, r3
 8001be4:	69a3      	ldr	r3, [r4, #24]
 8001be6:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8001bea:	4313      	orrs	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:214
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8001bec:	69e2      	ldr	r2, [r4, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:213

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 8001bee:	4313      	orrs	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:214
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8001bf0:	6a22      	ldr	r2, [r4, #32]
 8001bf2:	4313      	orrs	r3, r2
 8001bf4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001bf6:	431a      	orrs	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:212
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001bf8:	600a      	str	r2, [r1, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:217
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);

  /* Configure : NSS management */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode);
 8001bfa:	6821      	ldr	r1, [r4, #0]
 8001bfc:	8b63      	ldrh	r3, [r4, #26]
 8001bfe:	f003 0204 	and.w	r2, r3, #4
 8001c02:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001c04:	4313      	orrs	r3, r2
 8001c06:	604b      	str	r3, [r1, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:221

  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 8001c08:	6823      	ldr	r3, [r4, #0]
 8001c0a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001c0c:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:224

  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  hspi->Instance->I2SCFGR &= (uint32_t)(~SPI_I2SCFGR_I2SMOD);
 8001c0e:	6822      	ldr	r2, [r4, #0]
 8001c10:	69d3      	ldr	r3, [r2, #28]
 8001c12:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001c16:	61d3      	str	r3, [r2, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:226

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001c18:	2000      	movs	r0, #0
 8001c1a:	6560      	str	r0, [r4, #84]	; 0x54
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:227
  hspi->State = HAL_SPI_STATE_READY;
 8001c1c:	2301      	movs	r3, #1
 8001c1e:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:229
  
  return HAL_OK;
 8001c22:	bd10      	pop	{r4, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_spi.c:180
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 8001c24:	2001      	movs	r0, #1
 8001c26:	4770      	bx	lr
 8001c28:	08006730 	.word	0x08006730

08001c2c <HAL_TIM_Base_Start_IT>:
HAL_TIM_Base_Start_IT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:350
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 8001c2c:	b510      	push	{r4, lr}
 8001c2e:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8001c30:	6803      	ldr	r3, [r0, #0]
 8001c32:	4a23      	ldr	r2, [pc, #140]	; (8001cc0 <HAL_TIM_Base_Start_IT+0x94>)
 8001c34:	4293      	cmp	r3, r2
 8001c36:	d037      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 1)
 8001c38:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001c3c:	d034      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 2)
 8001c3e:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8001c42:	4293      	cmp	r3, r2
 8001c44:	d030      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 3)
 8001c46:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c4a:	4293      	cmp	r3, r2
 8001c4c:	d02c      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 4)
 8001c4e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c52:	4293      	cmp	r3, r2
 8001c54:	d028      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 5)
 8001c56:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c5a:	4293      	cmp	r3, r2
 8001c5c:	d024      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 6)
 8001c5e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c62:	4293      	cmp	r3, r2
 8001c64:	d020      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 7)
 8001c66:	f502 4270 	add.w	r2, r2, #61440	; 0xf000
 8001c6a:	4293      	cmp	r3, r2
 8001c6c:	d01c      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 8)
 8001c6e:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 8001c72:	4293      	cmp	r3, r2
 8001c74:	d018      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 9)
 8001c76:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c7a:	4293      	cmp	r3, r2
 8001c7c:	d014      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 10)
 8001c7e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c82:	4293      	cmp	r3, r2
 8001c84:	d010      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 11)
 8001c86:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8001c8a:	4293      	cmp	r3, r2
 8001c8c:	d00c      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 12)
 8001c8e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c92:	4293      	cmp	r3, r2
 8001c94:	d008      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 13)
 8001c96:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c9a:	4293      	cmp	r3, r2
 8001c9c:	d004      	beq.n	8001ca8 <HAL_TIM_Base_Start_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:352 (discriminator 14)
 8001c9e:	f44f 71b0 	mov.w	r1, #352	; 0x160
 8001ca2:	4808      	ldr	r0, [pc, #32]	; (8001cc4 <HAL_TIM_Base_Start_IT+0x98>)
 8001ca4:	f000 fa64 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:355
  
  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001ca8:	6822      	ldr	r2, [r4, #0]
 8001caa:	68d3      	ldr	r3, [r2, #12]
 8001cac:	f043 0301 	orr.w	r3, r3, #1
 8001cb0:	60d3      	str	r3, [r2, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:358
      
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8001cb2:	6822      	ldr	r2, [r4, #0]
 8001cb4:	6813      	ldr	r3, [r2, #0]
 8001cb6:	f043 0301 	orr.w	r3, r3, #1
 8001cba:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:362
      
  /* Return function status */
  return HAL_OK;
}
 8001cbc:	2000      	movs	r0, #0
 8001cbe:	bd10      	pop	{r4, pc}
 8001cc0:	40010000 	.word	0x40010000
 8001cc4:	08006760 	.word	0x08006760

08001cc8 <HAL_TIM_Base_Stop_IT>:
HAL_TIM_Base_Stop_IT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:371
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
{
 8001cc8:	b510      	push	{r4, lr}
 8001cca:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8001ccc:	6803      	ldr	r3, [r0, #0]
 8001cce:	4a28      	ldr	r2, [pc, #160]	; (8001d70 <HAL_TIM_Base_Stop_IT+0xa8>)
 8001cd0:	4293      	cmp	r3, r2
 8001cd2:	d037      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 1)
 8001cd4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001cd8:	d034      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 2)
 8001cda:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8001cde:	4293      	cmp	r3, r2
 8001ce0:	d030      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 3)
 8001ce2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001ce6:	4293      	cmp	r3, r2
 8001ce8:	d02c      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 4)
 8001cea:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001cee:	4293      	cmp	r3, r2
 8001cf0:	d028      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 5)
 8001cf2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001cf6:	4293      	cmp	r3, r2
 8001cf8:	d024      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 6)
 8001cfa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001cfe:	4293      	cmp	r3, r2
 8001d00:	d020      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 7)
 8001d02:	f502 4270 	add.w	r2, r2, #61440	; 0xf000
 8001d06:	4293      	cmp	r3, r2
 8001d08:	d01c      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 8)
 8001d0a:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 8001d0e:	4293      	cmp	r3, r2
 8001d10:	d018      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 9)
 8001d12:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d16:	4293      	cmp	r3, r2
 8001d18:	d014      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 10)
 8001d1a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d1e:	4293      	cmp	r3, r2
 8001d20:	d010      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 11)
 8001d22:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8001d26:	4293      	cmp	r3, r2
 8001d28:	d00c      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 12)
 8001d2a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d2e:	4293      	cmp	r3, r2
 8001d30:	d008      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 13)
 8001d32:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001d36:	4293      	cmp	r3, r2
 8001d38:	d004      	beq.n	8001d44 <HAL_TIM_Base_Stop_IT+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:373 (discriminator 14)
 8001d3a:	f240 1175 	movw	r1, #373	; 0x175
 8001d3e:	480d      	ldr	r0, [pc, #52]	; (8001d74 <HAL_TIM_Base_Stop_IT+0xac>)
 8001d40:	f000 fa16 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:375
  /* Disable the TIM Update interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8001d44:	6822      	ldr	r2, [r4, #0]
 8001d46:	68d3      	ldr	r3, [r2, #12]
 8001d48:	f023 0301 	bic.w	r3, r3, #1
 8001d4c:	60d3      	str	r3, [r2, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:378
      
  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 8001d4e:	6823      	ldr	r3, [r4, #0]
 8001d50:	6a19      	ldr	r1, [r3, #32]
 8001d52:	f241 1211 	movw	r2, #4369	; 0x1111
 8001d56:	4211      	tst	r1, r2
 8001d58:	d108      	bne.n	8001d6c <HAL_TIM_Base_Stop_IT+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:378 (discriminator 1)
 8001d5a:	6a19      	ldr	r1, [r3, #32]
 8001d5c:	f240 4244 	movw	r2, #1092	; 0x444
 8001d60:	4211      	tst	r1, r2
 8001d62:	d103      	bne.n	8001d6c <HAL_TIM_Base_Stop_IT+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:378 (discriminator 2)
 8001d64:	681a      	ldr	r2, [r3, #0]
 8001d66:	f022 0201 	bic.w	r2, r2, #1
 8001d6a:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:382
    
  /* Return function status */
  return HAL_OK;
}
 8001d6c:	2000      	movs	r0, #0
 8001d6e:	bd10      	pop	{r4, pc}
 8001d70:	40010000 	.word	0x40010000
 8001d74:	08006760 	.word	0x08006760

08001d78 <HAL_TIM_OC_DelayElapsedCallback>:
HAL_TIM_OC_DelayElapsedCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4267
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8001d78:	4770      	bx	lr
 8001d7a:	bf00      	nop

08001d7c <HAL_TIM_IC_CaptureCallback>:
HAL_TIM_IC_CaptureCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4279
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8001d7c:	4770      	bx	lr
 8001d7e:	bf00      	nop

08001d80 <HAL_TIM_PWM_PulseFinishedCallback>:
HAL_TIM_PWM_PulseFinishedCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4292
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8001d80:	4770      	bx	lr
 8001d82:	bf00      	nop

08001d84 <HAL_TIM_TriggerCallback>:
HAL_TIM_TriggerCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4305
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8001d84:	4770      	bx	lr
 8001d86:	bf00      	nop

08001d88 <HAL_TIM_IRQHandler>:
HAL_TIM_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2776
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8001d88:	b510      	push	{r4, lr}
 8001d8a:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2778
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001d8c:	6803      	ldr	r3, [r0, #0]
 8001d8e:	691a      	ldr	r2, [r3, #16]
 8001d90:	f012 0f02 	tst.w	r2, #2
 8001d94:	d017      	beq.n	8001dc6 <HAL_TIM_IRQHandler+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2780
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 8001d96:	68da      	ldr	r2, [r3, #12]
 8001d98:	f012 0f02 	tst.w	r2, #2
 8001d9c:	d013      	beq.n	8001dc6 <HAL_TIM_IRQHandler+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2783
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8001d9e:	f06f 0202 	mvn.w	r2, #2
 8001da2:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2784
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001da4:	2301      	movs	r3, #1
 8001da6:	7603      	strb	r3, [r0, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2787
        
        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 8001da8:	6803      	ldr	r3, [r0, #0]
 8001daa:	699b      	ldr	r3, [r3, #24]
 8001dac:	f013 0f03 	tst.w	r3, #3
 8001db0:	d002      	beq.n	8001db8 <HAL_TIM_IRQHandler+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2789
        {
          HAL_TIM_IC_CaptureCallback(htim);
 8001db2:	f7ff ffe3 	bl	8001d7c <HAL_TIM_IC_CaptureCallback>
 8001db6:	e004      	b.n	8001dc2 <HAL_TIM_IRQHandler+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2794
        }
        /* Output compare event */
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8001db8:	f7ff ffde 	bl	8001d78 <HAL_TIM_OC_DelayElapsedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2795
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001dbc:	4620      	mov	r0, r4
 8001dbe:	f7ff ffdf 	bl	8001d80 <HAL_TIM_PWM_PulseFinishedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2797
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001dc2:	2300      	movs	r3, #0
 8001dc4:	7623      	strb	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2802
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8001dc6:	6823      	ldr	r3, [r4, #0]
 8001dc8:	691a      	ldr	r2, [r3, #16]
 8001dca:	f012 0f04 	tst.w	r2, #4
 8001dce:	d019      	beq.n	8001e04 <HAL_TIM_IRQHandler+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2804
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 8001dd0:	68da      	ldr	r2, [r3, #12]
 8001dd2:	f012 0f04 	tst.w	r2, #4
 8001dd6:	d015      	beq.n	8001e04 <HAL_TIM_IRQHandler+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2806
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8001dd8:	f06f 0204 	mvn.w	r2, #4
 8001ddc:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2807
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8001dde:	2302      	movs	r3, #2
 8001de0:	7623      	strb	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2809
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 8001de2:	6823      	ldr	r3, [r4, #0]
 8001de4:	699b      	ldr	r3, [r3, #24]
 8001de6:	f413 7f40 	tst.w	r3, #768	; 0x300
 8001dea:	d003      	beq.n	8001df4 <HAL_TIM_IRQHandler+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2811
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001dec:	4620      	mov	r0, r4
 8001dee:	f7ff ffc5 	bl	8001d7c <HAL_TIM_IC_CaptureCallback>
 8001df2:	e005      	b.n	8001e00 <HAL_TIM_IRQHandler+0x78>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2816
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001df4:	4620      	mov	r0, r4
 8001df6:	f7ff ffbf 	bl	8001d78 <HAL_TIM_OC_DelayElapsedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2817
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001dfa:	4620      	mov	r0, r4
 8001dfc:	f7ff ffc0 	bl	8001d80 <HAL_TIM_PWM_PulseFinishedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2819
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001e00:	2300      	movs	r3, #0
 8001e02:	7623      	strb	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2823
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8001e04:	6823      	ldr	r3, [r4, #0]
 8001e06:	691a      	ldr	r2, [r3, #16]
 8001e08:	f012 0f08 	tst.w	r2, #8
 8001e0c:	d019      	beq.n	8001e42 <HAL_TIM_IRQHandler+0xba>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2825
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 8001e0e:	68da      	ldr	r2, [r3, #12]
 8001e10:	f012 0f08 	tst.w	r2, #8
 8001e14:	d015      	beq.n	8001e42 <HAL_TIM_IRQHandler+0xba>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2827
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8001e16:	f06f 0208 	mvn.w	r2, #8
 8001e1a:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2828
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001e1c:	2304      	movs	r3, #4
 8001e1e:	7623      	strb	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2830
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8001e20:	6823      	ldr	r3, [r4, #0]
 8001e22:	69db      	ldr	r3, [r3, #28]
 8001e24:	f013 0f03 	tst.w	r3, #3
 8001e28:	d003      	beq.n	8001e32 <HAL_TIM_IRQHandler+0xaa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2832
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001e2a:	4620      	mov	r0, r4
 8001e2c:	f7ff ffa6 	bl	8001d7c <HAL_TIM_IC_CaptureCallback>
 8001e30:	e005      	b.n	8001e3e <HAL_TIM_IRQHandler+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2837
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001e32:	4620      	mov	r0, r4
 8001e34:	f7ff ffa0 	bl	8001d78 <HAL_TIM_OC_DelayElapsedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2838
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 8001e38:	4620      	mov	r0, r4
 8001e3a:	f7ff ffa1 	bl	8001d80 <HAL_TIM_PWM_PulseFinishedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2840
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001e3e:	2300      	movs	r3, #0
 8001e40:	7623      	strb	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2844
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8001e42:	6823      	ldr	r3, [r4, #0]
 8001e44:	691a      	ldr	r2, [r3, #16]
 8001e46:	f012 0f10 	tst.w	r2, #16
 8001e4a:	d019      	beq.n	8001e80 <HAL_TIM_IRQHandler+0xf8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2846
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 8001e4c:	68da      	ldr	r2, [r3, #12]
 8001e4e:	f012 0f10 	tst.w	r2, #16
 8001e52:	d015      	beq.n	8001e80 <HAL_TIM_IRQHandler+0xf8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2848
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8001e54:	f06f 0210 	mvn.w	r2, #16
 8001e58:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2849
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001e5a:	2308      	movs	r3, #8
 8001e5c:	7623      	strb	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2851
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 8001e5e:	6823      	ldr	r3, [r4, #0]
 8001e60:	69db      	ldr	r3, [r3, #28]
 8001e62:	f413 7f40 	tst.w	r3, #768	; 0x300
 8001e66:	d003      	beq.n	8001e70 <HAL_TIM_IRQHandler+0xe8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2853
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001e68:	4620      	mov	r0, r4
 8001e6a:	f7ff ff87 	bl	8001d7c <HAL_TIM_IC_CaptureCallback>
 8001e6e:	e005      	b.n	8001e7c <HAL_TIM_IRQHandler+0xf4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2858
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001e70:	4620      	mov	r0, r4
 8001e72:	f7ff ff81 	bl	8001d78 <HAL_TIM_OC_DelayElapsedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2859
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001e76:	4620      	mov	r0, r4
 8001e78:	f7ff ff82 	bl	8001d80 <HAL_TIM_PWM_PulseFinishedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2861
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001e7c:	2300      	movs	r3, #0
 8001e7e:	7623      	strb	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2865
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8001e80:	6823      	ldr	r3, [r4, #0]
 8001e82:	691a      	ldr	r2, [r3, #16]
 8001e84:	f012 0f01 	tst.w	r2, #1
 8001e88:	d009      	beq.n	8001e9e <HAL_TIM_IRQHandler+0x116>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2867
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 8001e8a:	68da      	ldr	r2, [r3, #12]
 8001e8c:	f012 0f01 	tst.w	r2, #1
 8001e90:	d005      	beq.n	8001e9e <HAL_TIM_IRQHandler+0x116>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2869
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8001e92:	f06f 0201 	mvn.w	r2, #1
 8001e96:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2870
      HAL_TIM_PeriodElapsedCallback(htim);
 8001e98:	4620      	mov	r0, r4
 8001e9a:	f000 fd31 	bl	8002900 <HAL_TIM_PeriodElapsedCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2874
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8001e9e:	6823      	ldr	r3, [r4, #0]
 8001ea0:	691a      	ldr	r2, [r3, #16]
 8001ea2:	f012 0f80 	tst.w	r2, #128	; 0x80
 8001ea6:	d009      	beq.n	8001ebc <HAL_TIM_IRQHandler+0x134>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2876
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8001ea8:	68da      	ldr	r2, [r3, #12]
 8001eaa:	f012 0f80 	tst.w	r2, #128	; 0x80
 8001eae:	d005      	beq.n	8001ebc <HAL_TIM_IRQHandler+0x134>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2878
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001eb0:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8001eb4:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2879
      HAL_TIMEx_BreakCallback(htim);
 8001eb6:	4620      	mov	r0, r4
 8001eb8:	f000 f926 	bl	8002108 <HAL_TIMEx_BreakCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2883
    }
  }
  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8001ebc:	6823      	ldr	r3, [r4, #0]
 8001ebe:	691a      	ldr	r2, [r3, #16]
 8001ec0:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001ec4:	d009      	beq.n	8001eda <HAL_TIM_IRQHandler+0x152>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2885
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 8001ec6:	68da      	ldr	r2, [r3, #12]
 8001ec8:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001ecc:	d005      	beq.n	8001eda <HAL_TIM_IRQHandler+0x152>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2887
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8001ece:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8001ed2:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2888
      HAL_TIM_TriggerCallback(htim);
 8001ed4:	4620      	mov	r0, r4
 8001ed6:	f7ff ff55 	bl	8001d84 <HAL_TIM_TriggerCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2892
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8001eda:	6823      	ldr	r3, [r4, #0]
 8001edc:	691a      	ldr	r2, [r3, #16]
 8001ede:	f012 0f20 	tst.w	r2, #32
 8001ee2:	d009      	beq.n	8001ef8 <HAL_TIM_IRQHandler+0x170>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2894
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 8001ee4:	68da      	ldr	r2, [r3, #12]
 8001ee6:	f012 0f20 	tst.w	r2, #32
 8001eea:	d005      	beq.n	8001ef8 <HAL_TIM_IRQHandler+0x170>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2896
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8001eec:	f06f 0220 	mvn.w	r2, #32
 8001ef0:	611a      	str	r2, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:2897
      HAL_TIMEx_CommutationCallback(htim);
 8001ef2:	4620      	mov	r0, r4
 8001ef4:	f000 f906 	bl	8002104 <HAL_TIMEx_CommutationCallback>
 8001ef8:	bd10      	pop	{r4, pc}
 8001efa:	bf00      	nop

08001efc <TIM_Base_SetConfig>:
TIM_Base_SetConfig():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4420
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 8001efc:	6803      	ldr	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 8001efe:	4a45      	ldr	r2, [pc, #276]	; (8002014 <TIM_Base_SetConfig+0x118>)
 8001f00:	4290      	cmp	r0, r2
 8001f02:	d014      	beq.n	8001f2e <TIM_Base_SetConfig+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423 (discriminator 2)
 8001f04:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001f08:	d013      	beq.n	8001f32 <TIM_Base_SetConfig+0x36>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423 (discriminator 4)
 8001f0a:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8001f0e:	4290      	cmp	r0, r2
 8001f10:	d011      	beq.n	8001f36 <TIM_Base_SetConfig+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423 (discriminator 6)
 8001f12:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f16:	4290      	cmp	r0, r2
 8001f18:	d00f      	beq.n	8001f3a <TIM_Base_SetConfig+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423 (discriminator 8)
 8001f1a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f1e:	4290      	cmp	r0, r2
 8001f20:	d00d      	beq.n	8001f3e <TIM_Base_SetConfig+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423 (discriminator 10)
 8001f22:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8001f26:	4290      	cmp	r0, r2
 8001f28:	d10b      	bne.n	8001f42 <TIM_Base_SetConfig+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423
 8001f2a:	2201      	movs	r2, #1
 8001f2c:	e00a      	b.n	8001f44 <TIM_Base_SetConfig+0x48>
 8001f2e:	2201      	movs	r2, #1
 8001f30:	e008      	b.n	8001f44 <TIM_Base_SetConfig+0x48>
 8001f32:	2201      	movs	r2, #1
 8001f34:	e006      	b.n	8001f44 <TIM_Base_SetConfig+0x48>
 8001f36:	2201      	movs	r2, #1
 8001f38:	e004      	b.n	8001f44 <TIM_Base_SetConfig+0x48>
 8001f3a:	2201      	movs	r2, #1
 8001f3c:	e002      	b.n	8001f44 <TIM_Base_SetConfig+0x48>
 8001f3e:	2201      	movs	r2, #1
 8001f40:	e000      	b.n	8001f44 <TIM_Base_SetConfig+0x48>
 8001f42:	2200      	movs	r2, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4423 (discriminator 14)
 8001f44:	b11a      	cbz	r2, 8001f4e <TIM_Base_SetConfig+0x52>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4426
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001f46:	f023 0370 	bic.w	r3, r3, #112	; 0x70
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4427
    tmpcr1 |= Structure->CounterMode;
 8001f4a:	684a      	ldr	r2, [r1, #4]
 8001f4c:	4313      	orrs	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8001f4e:	4a31      	ldr	r2, [pc, #196]	; (8002014 <TIM_Base_SetConfig+0x118>)
 8001f50:	4290      	cmp	r0, r2
 8001f52:	d02c      	beq.n	8001fae <TIM_Base_SetConfig+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 2)
 8001f54:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001f58:	d02b      	beq.n	8001fb2 <TIM_Base_SetConfig+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 4)
 8001f5a:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8001f5e:	4290      	cmp	r0, r2
 8001f60:	d029      	beq.n	8001fb6 <TIM_Base_SetConfig+0xba>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 6)
 8001f62:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f66:	4290      	cmp	r0, r2
 8001f68:	d027      	beq.n	8001fba <TIM_Base_SetConfig+0xbe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 8)
 8001f6a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f6e:	4290      	cmp	r0, r2
 8001f70:	d025      	beq.n	8001fbe <TIM_Base_SetConfig+0xc2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 10)
 8001f72:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8001f76:	4290      	cmp	r0, r2
 8001f78:	d023      	beq.n	8001fc2 <TIM_Base_SetConfig+0xc6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 12)
 8001f7a:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 8001f7e:	4290      	cmp	r0, r2
 8001f80:	d021      	beq.n	8001fc6 <TIM_Base_SetConfig+0xca>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 14)
 8001f82:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f86:	4290      	cmp	r0, r2
 8001f88:	d01f      	beq.n	8001fca <TIM_Base_SetConfig+0xce>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 16)
 8001f8a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f8e:	4290      	cmp	r0, r2
 8001f90:	d01d      	beq.n	8001fce <TIM_Base_SetConfig+0xd2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 18)
 8001f92:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8001f96:	4290      	cmp	r0, r2
 8001f98:	d01b      	beq.n	8001fd2 <TIM_Base_SetConfig+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 20)
 8001f9a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001f9e:	4290      	cmp	r0, r2
 8001fa0:	d019      	beq.n	8001fd6 <TIM_Base_SetConfig+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 22)
 8001fa2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001fa6:	4290      	cmp	r0, r2
 8001fa8:	d117      	bne.n	8001fda <TIM_Base_SetConfig+0xde>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430
 8001faa:	2201      	movs	r2, #1
 8001fac:	e016      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fae:	2201      	movs	r2, #1
 8001fb0:	e014      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fb2:	2201      	movs	r2, #1
 8001fb4:	e012      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fb6:	2201      	movs	r2, #1
 8001fb8:	e010      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fba:	2201      	movs	r2, #1
 8001fbc:	e00e      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fbe:	2201      	movs	r2, #1
 8001fc0:	e00c      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fc2:	2201      	movs	r2, #1
 8001fc4:	e00a      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fc6:	2201      	movs	r2, #1
 8001fc8:	e008      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fca:	2201      	movs	r2, #1
 8001fcc:	e006      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fce:	2201      	movs	r2, #1
 8001fd0:	e004      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fd2:	2201      	movs	r2, #1
 8001fd4:	e002      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fd6:	2201      	movs	r2, #1
 8001fd8:	e000      	b.n	8001fdc <TIM_Base_SetConfig+0xe0>
 8001fda:	2200      	movs	r2, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4430 (discriminator 26)
 8001fdc:	b11a      	cbz	r2, 8001fe6 <TIM_Base_SetConfig+0xea>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4433
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8001fde:	f423 7340 	bic.w	r3, r3, #768	; 0x300
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4434
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001fe2:	68ca      	ldr	r2, [r1, #12]
 8001fe4:	4313      	orrs	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4437
  }

  TIMx->CR1 = tmpcr1;
 8001fe6:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4440

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001fe8:	688b      	ldr	r3, [r1, #8]
 8001fea:	62c3      	str	r3, [r0, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4443
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8001fec:	680b      	ldr	r3, [r1, #0]
 8001fee:	6283      	str	r3, [r0, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4445
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 8001ff0:	4b08      	ldr	r3, [pc, #32]	; (8002014 <TIM_Base_SetConfig+0x118>)
 8001ff2:	4298      	cmp	r0, r3
 8001ff4:	d005      	beq.n	8002002 <TIM_Base_SetConfig+0x106>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4445 (discriminator 2)
 8001ff6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001ffa:	4298      	cmp	r0, r3
 8001ffc:	d103      	bne.n	8002006 <TIM_Base_SetConfig+0x10a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4445
 8001ffe:	2301      	movs	r3, #1
 8002000:	e002      	b.n	8002008 <TIM_Base_SetConfig+0x10c>
 8002002:	2301      	movs	r3, #1
 8002004:	e000      	b.n	8002008 <TIM_Base_SetConfig+0x10c>
 8002006:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4445 (discriminator 6)
 8002008:	b10b      	cbz	r3, 800200e <TIM_Base_SetConfig+0x112>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4448
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800200a:	690b      	ldr	r3, [r1, #16]
 800200c:	6303      	str	r3, [r0, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:4453
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800200e:	2301      	movs	r3, #1
 8002010:	6143      	str	r3, [r0, #20]
 8002012:	4770      	bx	lr
 8002014:	40010000 	.word	0x40010000

08002018 <HAL_TIM_Base_Init>:
HAL_TIM_Base_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:211
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{ 
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8002018:	2800      	cmp	r0, #0
 800201a:	d06d      	beq.n	80020f8 <HAL_TIM_Base_Init+0xe0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:209
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{ 
 800201c:	b510      	push	{r4, lr}
 800201e:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217
  {
    return HAL_ERROR;
  }
  
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance)); 
 8002020:	6803      	ldr	r3, [r0, #0]
 8002022:	4a36      	ldr	r2, [pc, #216]	; (80020fc <HAL_TIM_Base_Init+0xe4>)
 8002024:	4293      	cmp	r3, r2
 8002026:	d036      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 1)
 8002028:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800202c:	d033      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 2)
 800202e:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8002032:	4293      	cmp	r3, r2
 8002034:	d02f      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 3)
 8002036:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800203a:	4293      	cmp	r3, r2
 800203c:	d02b      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 4)
 800203e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002042:	4293      	cmp	r3, r2
 8002044:	d027      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 5)
 8002046:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800204a:	4293      	cmp	r3, r2
 800204c:	d023      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 6)
 800204e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002052:	4293      	cmp	r3, r2
 8002054:	d01f      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 7)
 8002056:	f502 4270 	add.w	r2, r2, #61440	; 0xf000
 800205a:	4293      	cmp	r3, r2
 800205c:	d01b      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 8)
 800205e:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 8002062:	4293      	cmp	r3, r2
 8002064:	d017      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 9)
 8002066:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800206a:	4293      	cmp	r3, r2
 800206c:	d013      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 10)
 800206e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002072:	4293      	cmp	r3, r2
 8002074:	d00f      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 11)
 8002076:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800207a:	4293      	cmp	r3, r2
 800207c:	d00b      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 12)
 800207e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002082:	4293      	cmp	r3, r2
 8002084:	d007      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 13)
 8002086:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800208a:	4293      	cmp	r3, r2
 800208c:	d003      	beq.n	8002096 <HAL_TIM_Base_Init+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:217 (discriminator 14)
 800208e:	21d9      	movs	r1, #217	; 0xd9
 8002090:	481b      	ldr	r0, [pc, #108]	; (8002100 <HAL_TIM_Base_Init+0xe8>)
 8002092:	f000 f86d 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:218
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 8002096:	68a3      	ldr	r3, [r4, #8]
 8002098:	b15b      	cbz	r3, 80020b2 <HAL_TIM_Base_Init+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:218 (discriminator 1)
 800209a:	2b10      	cmp	r3, #16
 800209c:	d009      	beq.n	80020b2 <HAL_TIM_Base_Init+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:218 (discriminator 2)
 800209e:	2b20      	cmp	r3, #32
 80020a0:	d007      	beq.n	80020b2 <HAL_TIM_Base_Init+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:218 (discriminator 3)
 80020a2:	2b40      	cmp	r3, #64	; 0x40
 80020a4:	d005      	beq.n	80020b2 <HAL_TIM_Base_Init+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:218 (discriminator 4)
 80020a6:	2b60      	cmp	r3, #96	; 0x60
 80020a8:	d003      	beq.n	80020b2 <HAL_TIM_Base_Init+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:218 (discriminator 5)
 80020aa:	21da      	movs	r1, #218	; 0xda
 80020ac:	4814      	ldr	r0, [pc, #80]	; (8002100 <HAL_TIM_Base_Init+0xe8>)
 80020ae:	f000 f85f 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:219
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 80020b2:	6923      	ldr	r3, [r4, #16]
 80020b4:	b14b      	cbz	r3, 80020ca <HAL_TIM_Base_Init+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:219 (discriminator 1)
 80020b6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80020ba:	d006      	beq.n	80020ca <HAL_TIM_Base_Init+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:219 (discriminator 2)
 80020bc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80020c0:	d003      	beq.n	80020ca <HAL_TIM_Base_Init+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:219 (discriminator 3)
 80020c2:	21db      	movs	r1, #219	; 0xdb
 80020c4:	480e      	ldr	r0, [pc, #56]	; (8002100 <HAL_TIM_Base_Init+0xe8>)
 80020c6:	f000 f853 	bl	8002170 <assert_failed>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:221
  
  if(htim->State == HAL_TIM_STATE_RESET)
 80020ca:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 80020ce:	f013 0fff 	tst.w	r3, #255	; 0xff
 80020d2:	d105      	bne.n	80020e0 <HAL_TIM_Base_Init+0xc8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:224
  {  
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80020d4:	2300      	movs	r3, #0
 80020d6:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:226
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 80020da:	4620      	mov	r0, r4
 80020dc:	f000 fe8c 	bl	8002df8 <HAL_TIM_Base_MspInit>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:230
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 80020e0:	2302      	movs	r3, #2
 80020e2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:233
  
  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 80020e6:	1d21      	adds	r1, r4, #4
 80020e8:	6820      	ldr	r0, [r4, #0]
 80020ea:	f7ff ff07 	bl	8001efc <TIM_Base_SetConfig>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:236
  
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 80020ee:	2301      	movs	r3, #1
 80020f0:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:238
  
  return HAL_OK;
 80020f4:	2000      	movs	r0, #0
 80020f6:	bd10      	pop	{r4, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim.c:213
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{ 
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 80020f8:	2001      	movs	r0, #1
 80020fa:	4770      	bx	lr
 80020fc:	40010000 	.word	0x40010000
 8002100:	08006760 	.word	0x08006760

08002104 <HAL_TIMEx_CommutationCallback>:
HAL_TIMEx_CommutationCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim_ex.c:1754
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
{
 8002104:	4770      	bx	lr
 8002106:	bf00      	nop

08002108 <HAL_TIMEx_BreakCallback>:
HAL_TIMEx_BreakCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/stm32f4-hal/stm32f4xx_hal_tim_ex.c:1767
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8002108:	4770      	bx	lr
 800210a:	bf00      	nop

0800210c <_exit>:
_exit():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_exit.c:36
// is required.

void
__attribute__((weak))
_exit(int code __attribute__((unused)))
{
 800210c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_exit.c:38
#if !defined(DEBUG)
  __reset_hardware();
 800210e:	f000 f843 	bl	8002198 <__reset_hardware>
 8002112:	bf00      	nop

08002114 <abort>:
abort():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_exit.c:51
// ----------------------------------------------------------------------------

void
__attribute__((weak,noreturn))
abort(void)
{
 8002114:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_exit.c:54
  trace_puts("abort(), exiting...");

  _exit(1);
 8002116:	2001      	movs	r0, #1
 8002118:	f7ff fff8 	bl	800210c <_exit>

0800211c <_sbrk>:
_sbrk():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:23
// The definitions used here should be kept in sync with the
// stack definitions in the linker script.

caddr_t
_sbrk(int incr)
{
 800211c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:30
  extern char _Heap_Limit; // Defined by the linker.

  static char* current_heap_end;
  char* current_block_address;

  if (current_heap_end == 0)
 800211e:	4b0d      	ldr	r3, [pc, #52]	; (8002154 <_sbrk+0x38>)
 8002120:	681b      	ldr	r3, [r3, #0]
 8002122:	b913      	cbnz	r3, 800212a <_sbrk+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:32
    {
      current_heap_end = &_Heap_Begin;
 8002124:	4a0c      	ldr	r2, [pc, #48]	; (8002158 <_sbrk+0x3c>)
 8002126:	4b0b      	ldr	r3, [pc, #44]	; (8002154 <_sbrk+0x38>)
 8002128:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:35
    }

  current_block_address = current_heap_end;
 800212a:	4b0a      	ldr	r3, [pc, #40]	; (8002154 <_sbrk+0x38>)
 800212c:	681a      	ldr	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:41

  // Need to align heap to word boundary, else will get
  // hard faults on Cortex-M0. So we assume that heap starts on
  // word boundary, hence make sure we always add a multiple of
  // 4 to it.
  incr = (incr + 3) & (~3); // align value to 4
 800212e:	1cc3      	adds	r3, r0, #3
 8002130:	f023 0303 	bic.w	r3, r3, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:42
  if (current_heap_end + incr > &_Heap_Limit)
 8002134:	4413      	add	r3, r2
 8002136:	4909      	ldr	r1, [pc, #36]	; (800215c <_sbrk+0x40>)
 8002138:	428b      	cmp	r3, r1
 800213a:	d906      	bls.n	800214a <_sbrk+0x2e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:54
      _write (1, "_sbrk: Heap and stack collision\n", 32);

      abort ();
#else
      // Heap has overflowed
      errno = ENOMEM;
 800213c:	f003 fe16 	bl	8005d6c <__errno>
 8002140:	230c      	movs	r3, #12
 8002142:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:55
      return (caddr_t) - 1;
 8002144:	f04f 30ff 	mov.w	r0, #4294967295
 8002148:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:59
#endif
    }

  current_heap_end += incr;
 800214a:	4902      	ldr	r1, [pc, #8]	; (8002154 <_sbrk+0x38>)
 800214c:	600b      	str	r3, [r1, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:61

  return (caddr_t) current_block_address;
 800214e:	4610      	mov	r0, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_sbrk.c:62
}
 8002150:	bd08      	pop	{r3, pc}
 8002152:	bf00      	nop
 8002154:	20000148 	.word	0x20000148
 8002158:	20001e90 	.word	0x20001e90
 800215c:	2001fc00 	.word	0x2001fc00

08002160 <__initialize_args>:
__initialize_args():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_syscalls.c:52
  // available from the host environment. argv[argc] shall be a null pointer.
  // (static, no const)
  static char* argv[2] =
    { name, NULL };

  *p_argc = 1;
 8002160:	2301      	movs	r3, #1
 8002162:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/_syscalls.c:53
  *p_argv = &argv[0];
 8002164:	4b01      	ldr	r3, [pc, #4]	; (800216c <__initialize_args+0xc>)
 8002166:	600b      	str	r3, [r1, #0]
 8002168:	4770      	bx	lr
 800216a:	bf00      	nop
 800216c:	20000004 	.word	0x20000004

08002170 <assert_failed>:
assert_failed():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/assert.c:47

// Called from the assert_param() macro, usually defined in the stm32f*_conf.h
void
__attribute__((noreturn, weak))
assert_failed (uint8_t* file, uint32_t line)
{
 8002170:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/newlib/assert.c:49
  trace_printf ("assert_param() failed: file \"%s\", line %d\n", file, line);
  abort ();
 8002172:	f7ff ffcf 	bl	8002114 <abort>
 8002176:	bf00      	nop

08002178 <__initialize_hardware_early>:
__initialize_hardware_early():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/_initialize_hardware.c:36
// priority is Privileged, and the Stack is set to Main.

void
__attribute__((weak))
__initialize_hardware_early(void)
{
 8002178:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/_initialize_hardware.c:38
  // Call the CSMSIS system initialisation routine.
  SystemInit();
 800217a:	f000 f81f 	bl	80021bc <SystemInit>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/_initialize_hardware.c:43

#if defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__)
  // Set VTOR to the actual address, provided by the linker script.
  // Override the manual, possibly wrong, SystemInit() setting.
  SCB->VTOR = (uint32_t)(&__vectors_start);
 800217e:	4b02      	ldr	r3, [pc, #8]	; (8002188 <__initialize_hardware_early+0x10>)
 8002180:	4a02      	ldr	r2, [pc, #8]	; (800218c <__initialize_hardware_early+0x14>)
 8002182:	609a      	str	r2, [r3, #8]
 8002184:	bd08      	pop	{r3, pc}
 8002186:	bf00      	nop
 8002188:	e000ed00 	.word	0xe000ed00
 800218c:	08000000 	.word	0x08000000

08002190 <__initialize_hardware>:
__initialize_hardware():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/_initialize_hardware.c:81
// constructors.

void
__attribute__((weak))
__initialize_hardware(void)
{
 8002190:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cortexm/_initialize_hardware.c:84
  // Call the CSMSIS system clock routine to store the clock frequency
  // in the SystemCoreClock global RAM location.
  SystemCoreClockUpdate();
 8002192:	f000 f833 	bl	80021fc <SystemCoreClockUpdate>
 8002196:	bd08      	pop	{r3, pc}

08002198 <__reset_hardware>:
__DSB():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:429
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8002198:	f3bf 8f4f 	dsb	sy
NVIC_SystemReset():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1803
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800219c:	4905      	ldr	r1, [pc, #20]	; (80021b4 <__reset_hardware+0x1c>)
 800219e:	68ca      	ldr	r2, [r1, #12]
 80021a0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/core_cm4.h:1802
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80021a4:	4b04      	ldr	r3, [pc, #16]	; (80021b8 <__reset_hardware+0x20>)
 80021a6:	4313      	orrs	r3, r2
 80021a8:	60cb      	str	r3, [r1, #12]
__DSB():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:429
 80021aa:	f3bf 8f4f 	dsb	sy
__NOP():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:375
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80021ae:	bf00      	nop
 80021b0:	e7fd      	b.n	80021ae <__reset_hardware+0x16>
 80021b2:	bf00      	nop
 80021b4:	e000ed00 	.word	0xe000ed00
 80021b8:	05fa0004 	.word	0x05fa0004

080021bc <SystemInit>:
SystemInit():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:179
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80021bc:	4b0c      	ldr	r3, [pc, #48]	; (80021f0 <SystemInit+0x34>)
 80021be:	681a      	ldr	r2, [r3, #0]
 80021c0:	f042 0201 	orr.w	r2, r2, #1
 80021c4:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:182

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80021c6:	2100      	movs	r1, #0
 80021c8:	6099      	str	r1, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:185

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80021ca:	681a      	ldr	r2, [r3, #0]
 80021cc:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80021d0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80021d4:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:188

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80021d6:	4a07      	ldr	r2, [pc, #28]	; (80021f4 <SystemInit+0x38>)
 80021d8:	605a      	str	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:191

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80021da:	681a      	ldr	r2, [r3, #0]
 80021dc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80021e0:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:194

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80021e2:	60d9      	str	r1, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:204

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80021e4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80021e8:	4b03      	ldr	r3, [pc, #12]	; (80021f8 <SystemInit+0x3c>)
 80021ea:	609a      	str	r2, [r3, #8]
 80021ec:	4770      	bx	lr
 80021ee:	bf00      	nop
 80021f0:	40023800 	.word	0x40023800
 80021f4:	24003010 	.word	0x24003010
 80021f8:	e000ed00 	.word	0xe000ed00

080021fc <SystemCoreClockUpdate>:
SystemCoreClockUpdate():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:249
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80021fc:	4b22      	ldr	r3, [pc, #136]	; (8002288 <SystemCoreClockUpdate+0x8c>)
 80021fe:	689b      	ldr	r3, [r3, #8]
 8002200:	f003 030c 	and.w	r3, r3, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:251

  switch (tmp)
 8002204:	2b04      	cmp	r3, #4
 8002206:	d007      	beq.n	8002218 <SystemCoreClockUpdate+0x1c>
 8002208:	2b08      	cmp	r3, #8
 800220a:	d009      	beq.n	8002220 <SystemCoreClockUpdate+0x24>
 800220c:	2b00      	cmp	r3, #0
 800220e:	d12d      	bne.n	800226c <SystemCoreClockUpdate+0x70>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:254
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 8002210:	4a1e      	ldr	r2, [pc, #120]	; (800228c <SystemCoreClockUpdate+0x90>)
 8002212:	4b1f      	ldr	r3, [pc, #124]	; (8002290 <SystemCoreClockUpdate+0x94>)
 8002214:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:255
      break;
 8002216:	e02c      	b.n	8002272 <SystemCoreClockUpdate+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:257
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8002218:	4a1e      	ldr	r2, [pc, #120]	; (8002294 <SystemCoreClockUpdate+0x98>)
 800221a:	4b1d      	ldr	r3, [pc, #116]	; (8002290 <SystemCoreClockUpdate+0x94>)
 800221c:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:258
      break;
 800221e:	e028      	b.n	8002272 <SystemCoreClockUpdate+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:264
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8002220:	4b19      	ldr	r3, [pc, #100]	; (8002288 <SystemCoreClockUpdate+0x8c>)
 8002222:	685a      	ldr	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:265
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002224:	685b      	ldr	r3, [r3, #4]
 8002226:	f003 033f 	and.w	r3, r3, #63	; 0x3f
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:267
      
      if (pllsource != 0)
 800222a:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
 800222e:	d009      	beq.n	8002244 <SystemCoreClockUpdate+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:270
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8002230:	4a18      	ldr	r2, [pc, #96]	; (8002294 <SystemCoreClockUpdate+0x98>)
 8002232:	fbb2 f2f3 	udiv	r2, r2, r3
 8002236:	4b14      	ldr	r3, [pc, #80]	; (8002288 <SystemCoreClockUpdate+0x8c>)
 8002238:	685b      	ldr	r3, [r3, #4]
 800223a:	f3c3 1388 	ubfx	r3, r3, #6, #9
 800223e:	fb03 f202 	mul.w	r2, r3, r2
 8002242:	e008      	b.n	8002256 <SystemCoreClockUpdate+0x5a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:275
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8002244:	4a11      	ldr	r2, [pc, #68]	; (800228c <SystemCoreClockUpdate+0x90>)
 8002246:	fbb2 f3f3 	udiv	r3, r2, r3
 800224a:	4a0f      	ldr	r2, [pc, #60]	; (8002288 <SystemCoreClockUpdate+0x8c>)
 800224c:	6851      	ldr	r1, [r2, #4]
 800224e:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8002252:	fb01 f203 	mul.w	r2, r1, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:278
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8002256:	4b0c      	ldr	r3, [pc, #48]	; (8002288 <SystemCoreClockUpdate+0x8c>)
 8002258:	685b      	ldr	r3, [r3, #4]
 800225a:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800225e:	3301      	adds	r3, #1
 8002260:	005b      	lsls	r3, r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:279
      SystemCoreClock = pllvco/pllp;
 8002262:	fbb2 f3f3 	udiv	r3, r2, r3
 8002266:	4a0a      	ldr	r2, [pc, #40]	; (8002290 <SystemCoreClockUpdate+0x94>)
 8002268:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:280
      break;
 800226a:	e002      	b.n	8002272 <SystemCoreClockUpdate+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:282
    default:
      SystemCoreClock = HSI_VALUE;
 800226c:	4a07      	ldr	r2, [pc, #28]	; (800228c <SystemCoreClockUpdate+0x90>)
 800226e:	4b08      	ldr	r3, [pc, #32]	; (8002290 <SystemCoreClockUpdate+0x94>)
 8002270:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:287
      break;
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8002272:	4b05      	ldr	r3, [pc, #20]	; (8002288 <SystemCoreClockUpdate+0x8c>)
 8002274:	689b      	ldr	r3, [r3, #8]
 8002276:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800227a:	4a07      	ldr	r2, [pc, #28]	; (8002298 <SystemCoreClockUpdate+0x9c>)
 800227c:	5cd1      	ldrb	r1, [r2, r3]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/src/cmsis/system_stm32f4xx.c:289
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 800227e:	4a04      	ldr	r2, [pc, #16]	; (8002290 <SystemCoreClockUpdate+0x94>)
 8002280:	6813      	ldr	r3, [r2, #0]
 8002282:	40cb      	lsrs	r3, r1
 8002284:	6013      	str	r3, [r2, #0]
 8002286:	4770      	bx	lr
 8002288:	40023800 	.word	0x40023800
 800228c:	00f42400 	.word	0x00f42400
 8002290:	2000000c 	.word	0x2000000c
 8002294:	007a1200 	.word	0x007a1200
 8002298:	08006790 	.word	0x08006790

0800229c <MX_CAN1_Init>:
MX_CAN1_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:68
 *
 * @param  None
 *
 * @retval None
 */
void MX_CAN1_Init(void) {
 800229c:	b500      	push	{lr}
 800229e:	b08b      	sub	sp, #44	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:72
	CAN_FilterConfTypeDef sFilterConfig;

	/*##-1- Configure the CAN peripheral #######################################*/
	hcan1.Instance = CAN1;
 80022a0:	481d      	ldr	r0, [pc, #116]	; (8002318 <MX_CAN1_Init+0x7c>)
 80022a2:	4b1e      	ldr	r3, [pc, #120]	; (800231c <MX_CAN1_Init+0x80>)
 80022a4:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:73
	hcan1.pRxMsg = &RxMessage;
 80022a6:	4b1e      	ldr	r3, [pc, #120]	; (8002320 <MX_CAN1_Init+0x84>)
 80022a8:	6343      	str	r3, [r0, #52]	; 0x34
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:74
	hcan1.Init.Prescaler = 12;
 80022aa:	230c      	movs	r3, #12
 80022ac:	6043      	str	r3, [r0, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:75
	hcan1.Init.Mode = CAN_MODE_NORMAL;
 80022ae:	2300      	movs	r3, #0
 80022b0:	6083      	str	r3, [r0, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:76
	hcan1.Init.SJW = CAN_SJW_3TQ;
 80022b2:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 80022b6:	60c2      	str	r2, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:77
	hcan1.Init.BS1 = CAN_BS1_4TQ;
 80022b8:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 80022bc:	6102      	str	r2, [r0, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:78
	hcan1.Init.BS2 = CAN_BS2_2TQ;
 80022be:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 80022c2:	6142      	str	r2, [r0, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:79
	hcan1.Init.TTCM = DISABLE;
 80022c4:	6183      	str	r3, [r0, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:80
	hcan1.Init.ABOM = DISABLE;
 80022c6:	61c3      	str	r3, [r0, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:81
	hcan1.Init.AWUM = DISABLE;
 80022c8:	6203      	str	r3, [r0, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:82
	hcan1.Init.NART = DISABLE;
 80022ca:	6243      	str	r3, [r0, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:83
	hcan1.Init.RFLM = DISABLE;
 80022cc:	6283      	str	r3, [r0, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:84
	hcan1.Init.TXFP = DISABLE;
 80022ce:	62c3      	str	r3, [r0, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:86

	if (HAL_CAN_Init(&hcan1) != HAL_OK) {
 80022d0:	f7fe f92c 	bl	800052c <HAL_CAN_Init>
 80022d4:	b108      	cbz	r0, 80022da <MX_CAN1_Init+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:88
		/* Initialization Error */
		Error_Handler();
 80022d6:	f000 f8e3 	bl	80024a0 <Error_Handler>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:92
	}

	/*##-3- Configure the CAN Filter ###########################################*/
	sFilterConfig.FilterNumber = 0;
 80022da:	2300      	movs	r3, #0
 80022dc:	9305      	str	r3, [sp, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:93
	sFilterConfig.FilterMode = CAN_FILTERMODE_IDLIST;
 80022de:	2201      	movs	r2, #1
 80022e0:	9206      	str	r2, [sp, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:94
	sFilterConfig.FilterScale = CAN_FILTERSCALE_16BIT;
 80022e2:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:95
	sFilterConfig.FilterIdHigh = TORQUE_1 << 5;
 80022e4:	f44f 51a8 	mov.w	r1, #5376	; 0x1500
 80022e8:	9100      	str	r1, [sp, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:96
	sFilterConfig.FilterIdLow = TORQUE_3 << 5;
 80022ea:	f44f 51aa 	mov.w	r1, #5440	; 0x1540
 80022ee:	9101      	str	r1, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:99
//    sFilterConfig.FilterIdHigh = 0xFF << 5;
//	sFilterConfig.FilterIdLow = 0xFF << 5;
	sFilterConfig.FilterMaskIdHigh = GESCHWINDIGKEIT_RAD << 5;
 80022f0:	f44f 51ce 	mov.w	r1, #6592	; 0x19c0
 80022f4:	9102      	str	r1, [sp, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:101
//	sFilterConfig.FilterMaskIdHigh = 0xFF << 5;
	sFilterConfig.FilterMaskIdLow = STAT_KOMBI << 5;
 80022f6:	f44f 515a 	mov.w	r1, #13952	; 0x3680
 80022fa:	9103      	str	r1, [sp, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:103
//  sFilterConfig.FilterMaskIdLow = 0xFF << 5;
	sFilterConfig.FilterFIFOAssignment = 0;
 80022fc:	9304      	str	r3, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:104
	sFilterConfig.FilterActivation = ENABLE;
 80022fe:	9208      	str	r2, [sp, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:105
	sFilterConfig.BankNumber = 14;
 8002300:	230e      	movs	r3, #14
 8002302:	9309      	str	r3, [sp, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:107

	if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK) {
 8002304:	4669      	mov	r1, sp
 8002306:	4804      	ldr	r0, [pc, #16]	; (8002318 <MX_CAN1_Init+0x7c>)
 8002308:	f7fe f858 	bl	80003bc <HAL_CAN_ConfigFilter>
 800230c:	b108      	cbz	r0, 8002312 <MX_CAN1_Init+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:109
		/* Filter configuration Error */
		Error_Handler();
 800230e:	f000 f8c7 	bl	80024a0 <Error_Handler>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:111
	}
}
 8002312:	b00b      	add	sp, #44	; 0x2c
 8002314:	f85d fb04 	ldr.w	pc, [sp], #4
 8002318:	20001b60 	.word	0x20001b60
 800231c:	40006400 	.word	0x40006400
 8002320:	20000154 	.word	0x20000154

08002324 <HAL_CAN_RxCpltCallback>:
HAL_CAN_RxCpltCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:171
 * 		   	 In dieser Methode ist das Speichern von Rohdaten auf dem RAM-Speicher.
 * @param  CanHandle: pointer to a CAN_HandleTypeDef structure that contains
 *         the configuration information for the specified CAN.
 * @retval None
 */
void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* CanHandle) {
 8002324:	b538      	push	{r3, r4, r5, lr}
 8002326:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:173

	switch (CanHandle->pRxMsg->StdId) {
 8002328:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800232a:	6813      	ldr	r3, [r2, #0]
 800232c:	2baa      	cmp	r3, #170	; 0xaa
 800232e:	d02d      	beq.n	800238c <HAL_CAN_RxCpltCallback+0x68>
 8002330:	d802      	bhi.n	8002338 <HAL_CAN_RxCpltCallback+0x14>
 8002332:	2ba8      	cmp	r3, #168	; 0xa8
 8002334:	d006      	beq.n	8002344 <HAL_CAN_RxCpltCallback+0x20>
 8002336:	e060      	b.n	80023fa <HAL_CAN_RxCpltCallback+0xd6>
 8002338:	2bce      	cmp	r3, #206	; 0xce
 800233a:	d037      	beq.n	80023ac <HAL_CAN_RxCpltCallback+0x88>
 800233c:	f5b3 7fda 	cmp.w	r3, #436	; 0x1b4
 8002340:	d044      	beq.n	80023cc <HAL_CAN_RxCpltCallback+0xa8>
 8002342:	e05a      	b.n	80023fa <HAL_CAN_RxCpltCallback+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:177
	case (TORQUE_1):     // Drehmoment

		// Drehmoment abspeichern
		if (CanHandle->pRxMsg->Data[2] & 0x80)       // Falls Zahl negative
 8002344:	7d91      	ldrb	r1, [r2, #22]
 8002346:	f011 0f80 	tst.w	r1, #128	; 0x80
 800234a:	d004      	beq.n	8002356 <HAL_CAN_RxCpltCallback+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:178
			trq_eng_in1 = 0xF0 << 8;
 800234c:	f44f 4070 	mov.w	r0, #61440	; 0xf000
 8002350:	4b2e      	ldr	r3, [pc, #184]	; (800240c <HAL_CAN_RxCpltCallback+0xe8>)
 8002352:	8018      	strh	r0, [r3, #0]
 8002354:	e002      	b.n	800235c <HAL_CAN_RxCpltCallback+0x38>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:180
		else
			trq_eng_in1 = 0;
 8002356:	2000      	movs	r0, #0
 8002358:	4b2c      	ldr	r3, [pc, #176]	; (800240c <HAL_CAN_RxCpltCallback+0xe8>)
 800235a:	8018      	strh	r0, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:182
		trq_eng_in1 += ((CanHandle->pRxMsg->Data[2]) << 4)
				+ ((CanHandle->pRxMsg->Data[1]) >> 4);
 800235c:	7d53      	ldrb	r3, [r2, #21]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:181
		// Drehmoment abspeichern
		if (CanHandle->pRxMsg->Data[2] & 0x80)       // Falls Zahl negative
			trq_eng_in1 = 0xF0 << 8;
		else
			trq_eng_in1 = 0;
		trq_eng_in1 += ((CanHandle->pRxMsg->Data[2]) << 4)
 800235e:	4d2b      	ldr	r5, [pc, #172]	; (800240c <HAL_CAN_RxCpltCallback+0xe8>)
 8002360:	882a      	ldrh	r2, [r5, #0]
 8002362:	091b      	lsrs	r3, r3, #4
 8002364:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 8002368:	fa13 f382 	uxtah	r3, r3, r2
 800236c:	b29b      	uxth	r3, r3
 800236e:	802b      	strh	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:183
				+ ((CanHandle->pRxMsg->Data[1]) >> 4);
		trq_eng_in1 = trq_eng_in1 >> 1;
 8002370:	882b      	ldrh	r3, [r5, #0]
 8002372:	f343 034e 	sbfx	r3, r3, #1, #15
 8002376:	b29b      	uxth	r3, r3
 8002378:	802b      	strh	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:185

		PtCan_SdStorage_storeRAM(0, PtCan_Tim_GetCounter(), trq_eng_in1);
 800237a:	f000 fae9 	bl	8002950 <PtCan_Tim_GetCounter>
 800237e:	882a      	ldrh	r2, [r5, #0]
 8002380:	b212      	sxth	r2, r2
 8002382:	4601      	mov	r1, r0
 8002384:	2000      	movs	r0, #0
 8002386:	f000 f93b 	bl	8002600 <PtCan_SdStorage_storeRAM>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:190
#if defined (CAN2_EIN)
		hcan2.pTxMsg->StdId = TORQUE_3;
#endif

		break;
 800238a:	e036      	b.n	80023fa <HAL_CAN_RxCpltCallback+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:193

	case (TORQUE_3):     // Speed of the shaft
		trq_eng_in3 = (((CanHandle->pRxMsg->Data[5]) << 8)
 800238c:	7e51      	ldrb	r1, [r2, #25]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:194
				| CanHandle->pRxMsg->Data[4]) >> 2;
 800238e:	7e13      	ldrb	r3, [r2, #24]
 8002390:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:193
#endif

		break;

	case (TORQUE_3):     // Speed of the shaft
		trq_eng_in3 = (((CanHandle->pRxMsg->Data[5]) << 8)
 8002394:	089b      	lsrs	r3, r3, #2
 8002396:	4d1e      	ldr	r5, [pc, #120]	; (8002410 <HAL_CAN_RxCpltCallback+0xec>)
 8002398:	802b      	strh	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:196
				| CanHandle->pRxMsg->Data[4]) >> 2;

		PtCan_SdStorage_storeRAM(1, PtCan_Tim_GetCounter(), trq_eng_in3);
 800239a:	f000 fad9 	bl	8002950 <PtCan_Tim_GetCounter>
 800239e:	882a      	ldrh	r2, [r5, #0]
 80023a0:	b212      	sxth	r2, r2
 80023a2:	4601      	mov	r1, r0
 80023a4:	2001      	movs	r0, #1
 80023a6:	f000 f92b 	bl	8002600 <PtCan_SdStorage_storeRAM>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:202

#if defined (CAN2_EIN)
		hcan2.pTxMsg->StdId = GESCHWINDIGKEIT_RAD;
#endif

		break;
 80023aa:	e026      	b.n	80023fa <HAL_CAN_RxCpltCallback+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:206

	case (GESCHWINDIGKEIT_RAD):

		left_wheel_speed = (((CanHandle->pRxMsg->Data[5]) << 8)
 80023ac:	7e51      	ldrb	r1, [r2, #25]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:207
				| CanHandle->pRxMsg->Data[4]) >> 4;
 80023ae:	7e13      	ldrb	r3, [r2, #24]
 80023b0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:206

		break;

	case (GESCHWINDIGKEIT_RAD):

		left_wheel_speed = (((CanHandle->pRxMsg->Data[5]) << 8)
 80023b4:	091b      	lsrs	r3, r3, #4
 80023b6:	4d17      	ldr	r5, [pc, #92]	; (8002414 <HAL_CAN_RxCpltCallback+0xf0>)
 80023b8:	802b      	strh	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:209
				| CanHandle->pRxMsg->Data[4]) >> 4;

		PtCan_SdStorage_storeRAM(2, PtCan_Tim_GetCounter(), left_wheel_speed);
 80023ba:	f000 fac9 	bl	8002950 <PtCan_Tim_GetCounter>
 80023be:	882a      	ldrh	r2, [r5, #0]
 80023c0:	b212      	sxth	r2, r2
 80023c2:	4601      	mov	r1, r0
 80023c4:	2002      	movs	r0, #2
 80023c6:	f000 f91b 	bl	8002600 <PtCan_SdStorage_storeRAM>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:214
#if defined (CAN2_EIN)
		hcan2.pTxMsg->StdId = STAT_KOMBI;
#endif

		break;
 80023ca:	e016      	b.n	80023fa <HAL_CAN_RxCpltCallback+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:219

	case (STAT_KOMBI):

		// Geschwindigkeit abspeichern
		vehicle_speed = ((CanHandle->pRxMsg->Data[1] & 0xF) << 8)
 80023cc:	7d53      	ldrb	r3, [r2, #21]
 80023ce:	f003 010f 	and.w	r1, r3, #15
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:220
				| CanHandle->pRxMsg->Data[0];
 80023d2:	7d13      	ldrb	r3, [r2, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:219
		break;

	case (STAT_KOMBI):

		// Geschwindigkeit abspeichern
		vehicle_speed = ((CanHandle->pRxMsg->Data[1] & 0xF) << 8)
 80023d4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80023d8:	4d0f      	ldr	r5, [pc, #60]	; (8002418 <HAL_CAN_RxCpltCallback+0xf4>)
 80023da:	802b      	strh	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:221
				| CanHandle->pRxMsg->Data[0];
		vehicle_speed /= 10;
 80023dc:	882b      	ldrh	r3, [r5, #0]
 80023de:	b29b      	uxth	r3, r3
 80023e0:	4a0e      	ldr	r2, [pc, #56]	; (800241c <HAL_CAN_RxCpltCallback+0xf8>)
 80023e2:	fba2 2303 	umull	r2, r3, r2, r3
 80023e6:	08db      	lsrs	r3, r3, #3
 80023e8:	802b      	strh	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:223

		PtCan_SdStorage_storeRAM(3, PtCan_Tim_GetCounter(), vehicle_speed);
 80023ea:	f000 fab1 	bl	8002950 <PtCan_Tim_GetCounter>
 80023ee:	882a      	ldrh	r2, [r5, #0]
 80023f0:	b212      	sxth	r2, r2
 80023f2:	4601      	mov	r1, r0
 80023f4:	2003      	movs	r0, #3
 80023f6:	f000 f903 	bl	8002600 <PtCan_SdStorage_storeRAM>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:235
	default:
		break;
	}

	/* Receive. This function must be called after each data reception process */
	if (HAL_CAN_Receive_IT(CanHandle, CAN_FIFO0) != HAL_OK) {
 80023fa:	2100      	movs	r1, #0
 80023fc:	4620      	mov	r0, r4
 80023fe:	f7fe f9cb 	bl	8000798 <HAL_CAN_Receive_IT>
 8002402:	b108      	cbz	r0, 8002408 <HAL_CAN_RxCpltCallback+0xe4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:237
		/* Reception Error */
		Error_Handler_CANR();
 8002404:	f000 f82c 	bl	8002460 <Error_Handler_CANR>
 8002408:	bd38      	pop	{r3, r4, r5, pc}
 800240a:	bf00      	nop
 800240c:	20000178 	.word	0x20000178
 8002410:	20000152 	.word	0x20000152
 8002414:	20000150 	.word	0x20000150
 8002418:	2000014e 	.word	0x2000014e
 800241c:	cccccccd 	.word	0xcccccccd

08002420 <PtCan_Can1ActivReceiveIT>:
PtCan_Can1ActivReceiveIT():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:249
 * @brief  Initialize receive process of CAN-Messages
 * @param  None
 * @retval None
 */
void PtCan_Can1ActivReceiveIT()
{
 8002420:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:250
	if (HAL_CAN_Receive_IT(&hcan1, CAN_FIFO0) != HAL_OK) {
 8002422:	2100      	movs	r1, #0
 8002424:	4803      	ldr	r0, [pc, #12]	; (8002434 <PtCan_Can1ActivReceiveIT+0x14>)
 8002426:	f7fe f9b7 	bl	8000798 <HAL_CAN_Receive_IT>
 800242a:	b108      	cbz	r0, 8002430 <PtCan_Can1ActivReceiveIT+0x10>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:252
		/* Reception Error */
		Error_Handler_CANR();
 800242c:	f000 f818 	bl	8002460 <Error_Handler_CANR>
 8002430:	bd08      	pop	{r3, pc}
 8002432:	bf00      	nop
 8002434:	20001b60 	.word	0x20001b60

08002438 <PtCan_Can1Sleep>:
PtCan_Can1Sleep():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:263
 * @brief  Sleep the CAN module.
 * @param  None
 * @retval None
 */
void PtCan_Can1Sleep()
{
 8002438:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:264
	if (HAL_CAN_Sleep(&hcan1) != HAL_OK) {
 800243a:	4803      	ldr	r0, [pc, #12]	; (8002448 <PtCan_Can1Sleep+0x10>)
 800243c:	f7fe fa02 	bl	8000844 <HAL_CAN_Sleep>
 8002440:	b108      	cbz	r0, 8002446 <PtCan_Can1Sleep+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:266
		/* Reception Error */
		Error_Handler_CANR();
 8002442:	f000 f80d 	bl	8002460 <Error_Handler_CANR>
 8002446:	bd08      	pop	{r3, pc}
 8002448:	20001b60 	.word	0x20001b60

0800244c <PtCan_Can1WU>:
PtCan_Can1WU():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:277
 * @brief  Wake up CAN module CAN1 Interface
 * @param  None
 * @retval None
 */
void PtCan_Can1WU()
{
 800244c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:278
	if (HAL_CAN_WakeUp(&hcan1) != HAL_OK) {
 800244e:	4803      	ldr	r0, [pc, #12]	; (800245c <PtCan_Can1WU+0x10>)
 8002450:	f7fe fa36 	bl	80008c0 <HAL_CAN_WakeUp>
 8002454:	b108      	cbz	r0, 800245a <PtCan_Can1WU+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Can.c:280
		/* Reception Error */
		Error_Handler_CANR();
 8002456:	f000 f803 	bl	8002460 <Error_Handler_CANR>
 800245a:	bd08      	pop	{r3, pc}
 800245c:	20001b60 	.word	0x20001b60

08002460 <Error_Handler_CANR>:
Error_Handler_CANR():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:53
/**
 * @brief  This function is executed in case of error occurrence.
 * @param  None
 * @retval None
 */
void Error_Handler_CANR(void) {
 8002460:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:54
	f_mount(NULL, "SD:", 1);
 8002462:	2201      	movs	r2, #1
 8002464:	4905      	ldr	r1, [pc, #20]	; (800247c <Error_Handler_CANR+0x1c>)
 8002466:	2000      	movs	r0, #0
 8002468:	f002 fe48 	bl	80050fc <f_mount>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:57 (discriminator 1)

	while (1) {
		BSP_LED_Toggle(LED6);
 800246c:	2003      	movs	r0, #3
 800246e:	f000 facd 	bl	8002a0c <BSP_LED_Toggle>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:58 (discriminator 1)
		HAL_Delay(100);
 8002472:	2064      	movs	r0, #100	; 0x64
 8002474:	f003 f9be 	bl	80057f4 <HAL_Delay>
 8002478:	e7f8      	b.n	800246c <Error_Handler_CANR+0xc>
 800247a:	bf00      	nop
 800247c:	080067a0 	.word	0x080067a0

08002480 <Error_Handler_fats>:
Error_Handler_fats():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:67
/**
 * @brief  This function is executed in case of error occurrence.
 * @param  None
 * @retval None
 */
void Error_Handler_fats(void) {
 8002480:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:68
	f_mount(NULL, "SD:", 1);
 8002482:	2201      	movs	r2, #1
 8002484:	4905      	ldr	r1, [pc, #20]	; (800249c <Error_Handler_fats+0x1c>)
 8002486:	2000      	movs	r0, #0
 8002488:	f002 fe38 	bl	80050fc <f_mount>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:71 (discriminator 1)

	while (1) {
		BSP_LED_Toggle(LED6);
 800248c:	2003      	movs	r0, #3
 800248e:	f000 fabd 	bl	8002a0c <BSP_LED_Toggle>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:72 (discriminator 1)
		HAL_Delay(100);
 8002492:	2064      	movs	r0, #100	; 0x64
 8002494:	f003 f9ae 	bl	80057f4 <HAL_Delay>
 8002498:	e7f8      	b.n	800248c <Error_Handler_fats+0xc>
 800249a:	bf00      	nop
 800249c:	080067a0 	.word	0x080067a0

080024a0 <Error_Handler>:
Error_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:81
/**
 * @brief  This function is executed in case of error occurrence.
 * @param  None
 * @retval None
 */
void Error_Handler(void) {
 80024a0:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:82
	f_mount(NULL, "SD:", 1);
 80024a2:	2201      	movs	r2, #1
 80024a4:	4905      	ldr	r1, [pc, #20]	; (80024bc <Error_Handler+0x1c>)
 80024a6:	2000      	movs	r0, #0
 80024a8:	f002 fe28 	bl	80050fc <f_mount>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:84 (discriminator 1)
	while (1) {
		BSP_LED_Toggle(LED6);
 80024ac:	2003      	movs	r0, #3
 80024ae:	f000 faad 	bl	8002a0c <BSP_LED_Toggle>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_ErrHandling.c:85 (discriminator 1)
		HAL_Delay(100);
 80024b2:	2064      	movs	r0, #100	; 0x64
 80024b4:	f003 f99e 	bl	80057f4 <HAL_Delay>
 80024b8:	e7f8      	b.n	80024ac <Error_Handler+0xc>
 80024ba:	bf00      	nop
 80024bc:	080067a0 	.word	0x080067a0

080024c0 <PtCan_SdStorage_openFile>:
PtCan_SdStorage_openFile():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:107
 * @param  dataIndex: variable to adress the corresponding entry
 * 				 of 'FileDescriptorMap' variable
 * @retval statusOpening: status of opening process of the corresponding
 * 				 File object structure
 */
static StatusType PtCan_SdStorage_openFile(uint8_t dataIndex) {
 80024c0:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:109

	StatusType statusOpening = f_open(FileDescriptorMap[dataIndex].file_data,
 80024c2:	4b04      	ldr	r3, [pc, #16]	; (80024d4 <PtCan_SdStorage_openFile+0x14>)
 80024c4:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 80024c8:	2213      	movs	r2, #19
 80024ca:	68c1      	ldr	r1, [r0, #12]
 80024cc:	6880      	ldr	r0, [r0, #8]
 80024ce:	f002 fe45 	bl	800515c <f_open>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:114
			FileDescriptorMap[dataIndex].strs_data,
			FA_OPEN_ALWAYS | FA_READ | FA_WRITE);
	return statusOpening;

}
 80024d2:	bd08      	pop	{r3, pc}
 80024d4:	20001ba0 	.word	0x20001ba0

080024d8 <PtCan_SdStorage_closeFile>:
PtCan_SdStorage_closeFile():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:123
 * @param  dataIndex: variable to address the corresponding entry
 * 				 of 'FileDescriptorMap' variable
 * @retval statusOpening: status of closing process of the corresponding
 * 				 File object structure
 */
static StatusType PtCan_SdStorage_closeFile(uint8_t dataIndex) {
 80024d8:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:124
	StatusType statusClosing = f_close(FileDescriptorMap[dataIndex].file_data);
 80024da:	4b03      	ldr	r3, [pc, #12]	; (80024e8 <PtCan_SdStorage_closeFile+0x10>)
 80024dc:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 80024e0:	6880      	ldr	r0, [r0, #8]
 80024e2:	f003 f853 	bl	800558c <f_close>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:126
	return statusClosing;
}
 80024e6:	bd08      	pop	{r3, pc}
 80024e8:	20001ba0 	.word	0x20001ba0

080024ec <PtCan_SdStorage_sendData>:
PtCan_SdStorage_sendData():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:134
 * @brief  Send raw data to sd card.
 * @param  dataIndex: variable to address the corresponding entry
 * 				 of 'FileDescriptorMap' variable
 * @retval None
 */
static void PtCan_SdStorage_sendData(uint8_t dataIndex) {
 80024ec:	b530      	push	{r4, r5, lr}
 80024ee:	b083      	sub	sp, #12
 80024f0:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:136

	if (PtCan_SdStorage_openFile(dataIndex) == E_OK) {
 80024f2:	f7ff ffe5 	bl	80024c0 <PtCan_SdStorage_openFile>
 80024f6:	bb98      	cbnz	r0, 8002560 <PtCan_SdStorage_sendData+0x74>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:137
		uint32_t FileSize = f_size(FileDescriptorMap[dataIndex].file_data);
 80024f8:	4d1b      	ldr	r5, [pc, #108]	; (8002568 <PtCan_SdStorage_sendData+0x7c>)
 80024fa:	eb05 1504 	add.w	r5, r5, r4, lsl #4
 80024fe:	68a8      	ldr	r0, [r5, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:140
		uint8_t wbytes;
		/* Move to offset of FileSize from top of the file */
		f_lseek(FileDescriptorMap[dataIndex].file_data, FileSize);
 8002500:	68c1      	ldr	r1, [r0, #12]
 8002502:	f003 f857 	bl	80055b4 <f_lseek>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:143

		/* Write 512 bytes to file */
		if (FileDescriptorMap[dataIndex].co_arr_full == ((dataIndex<<1) + 1)) { // nachdem am Anfang das 1. array gefuellt wurde, wird dieses an die SD geschickt. Hierbei ist co_arr_full_GR==1
 8002506:	792a      	ldrb	r2, [r5, #4]
 8002508:	b2d2      	uxtb	r2, r2
 800250a:	0063      	lsls	r3, r4, #1
 800250c:	3301      	adds	r3, #1
 800250e:	429a      	cmp	r2, r3
 8002510:	d110      	bne.n	8002534 <PtCan_SdStorage_sendData+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:145
			if (f_write(FileDescriptorMap[dataIndex].file_data,
					arr2SD[FileDescriptorMap[dataIndex].co_arr_full - 1], 512, (void *) &wbytes) != FR_OK) {
 8002512:	4628      	mov	r0, r5
 8002514:	7929      	ldrb	r1, [r5, #4]
 8002516:	3901      	subs	r1, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:144
		/* Move to offset of FileSize from top of the file */
		f_lseek(FileDescriptorMap[dataIndex].file_data, FileSize);

		/* Write 512 bytes to file */
		if (FileDescriptorMap[dataIndex].co_arr_full == ((dataIndex<<1) + 1)) { // nachdem am Anfang das 1. array gefuellt wurde, wird dieses an die SD geschickt. Hierbei ist co_arr_full_GR==1
			if (f_write(FileDescriptorMap[dataIndex].file_data,
 8002518:	f10d 0307 	add.w	r3, sp, #7
 800251c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002520:	4d12      	ldr	r5, [pc, #72]	; (800256c <PtCan_SdStorage_sendData+0x80>)
 8002522:	eb05 2141 	add.w	r1, r5, r1, lsl #9
 8002526:	6880      	ldr	r0, [r0, #8]
 8002528:	f002 ff08 	bl	800533c <f_write>
 800252c:	b1a0      	cbz	r0, 8002558 <PtCan_SdStorage_sendData+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:146
					arr2SD[FileDescriptorMap[dataIndex].co_arr_full - 1], 512, (void *) &wbytes) != FR_OK) {
				Error_Handler_fats();
 800252e:	f7ff ffa7 	bl	8002480 <Error_Handler_fats>
 8002532:	e011      	b.n	8002558 <PtCan_SdStorage_sendData+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:150
			}
		} else { // nachdem das 2. array gefuellt wurde, wird dieses an die SD geschickt. Hierbei ist co_arr_full_GR==0
			if (f_write(FileDescriptorMap[dataIndex].file_data,
					arr2SD[FileDescriptorMap[dataIndex].co_arr_full + 1], 512, (void *) &wbytes) != FR_OK) {
 8002534:	480c      	ldr	r0, [pc, #48]	; (8002568 <PtCan_SdStorage_sendData+0x7c>)
 8002536:	eb00 1004 	add.w	r0, r0, r4, lsl #4
 800253a:	7901      	ldrb	r1, [r0, #4]
 800253c:	3101      	adds	r1, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:149
			if (f_write(FileDescriptorMap[dataIndex].file_data,
					arr2SD[FileDescriptorMap[dataIndex].co_arr_full - 1], 512, (void *) &wbytes) != FR_OK) {
				Error_Handler_fats();
			}
		} else { // nachdem das 2. array gefuellt wurde, wird dieses an die SD geschickt. Hierbei ist co_arr_full_GR==0
			if (f_write(FileDescriptorMap[dataIndex].file_data,
 800253e:	f10d 0307 	add.w	r3, sp, #7
 8002542:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002546:	4d09      	ldr	r5, [pc, #36]	; (800256c <PtCan_SdStorage_sendData+0x80>)
 8002548:	eb05 2141 	add.w	r1, r5, r1, lsl #9
 800254c:	6880      	ldr	r0, [r0, #8]
 800254e:	f002 fef5 	bl	800533c <f_write>
 8002552:	b108      	cbz	r0, 8002558 <PtCan_SdStorage_sendData+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:151
					arr2SD[FileDescriptorMap[dataIndex].co_arr_full + 1], 512, (void *) &wbytes) != FR_OK) {
				Error_Handler_fats();
 8002554:	f7ff ff94 	bl	8002480 <Error_Handler_fats>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:154 (discriminator 1)
			}
		}
		PtCan_SdStorage_closeFile(dataIndex);
 8002558:	4620      	mov	r0, r4
 800255a:	f7ff ffbd 	bl	80024d8 <PtCan_SdStorage_closeFile>
 800255e:	e001      	b.n	8002564 <PtCan_SdStorage_sendData+0x78>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:157
	} else {
		//Error ausgeben
		Error_Handler_fats();
 8002560:	f7ff ff8e 	bl	8002480 <Error_Handler_fats>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:159
	}
}
 8002564:	b003      	add	sp, #12
 8002566:	bd30      	pop	{r4, r5, pc}
 8002568:	20001ba0 	.word	0x20001ba0
 800256c:	2000017c 	.word	0x2000017c

08002570 <PtCan_SdStorage_storeSD>:
PtCan_SdStorage_storeSD():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:172
 * 				 If 'save_files' indicates a full column of 'arr2SD', then the corresponding data stored in RAM
 * 				 has to be sent to sd card.
 * @param  None
 * @retval None
 */
void PtCan_SdStorage_storeSD() { // von hier aus werden die Daten an die SD gesendet, von der isr werden die Daten in die Puffer gespeichert
 8002570:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:174

	if (save_files & TORQUE1_MASK) {
 8002572:	4b21      	ldr	r3, [pc, #132]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 8002574:	781b      	ldrb	r3, [r3, #0]
 8002576:	f013 0f01 	tst.w	r3, #1
 800257a:	d00a      	beq.n	8002592 <PtCan_SdStorage_storeSD+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:176

		PtCan_SdStorage_sendData(0);
 800257c:	2000      	movs	r0, #0
 800257e:	f7ff ffb5 	bl	80024ec <PtCan_SdStorage_sendData>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:178
		// data transfer finished
		save_files = save_files & (~TORQUE1_MASK); // setze entsprechendes bit von Gesch.rad bei save_files, damit man signal., dass der erster Buffer von Geschw. voll ist
 8002582:	4a1d      	ldr	r2, [pc, #116]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 8002584:	7813      	ldrb	r3, [r2, #0]
 8002586:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 800258a:	7013      	strb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:179
		FileDescriptorMap[0].signal_arrvoll = 0;
 800258c:	2200      	movs	r2, #0
 800258e:	4b1b      	ldr	r3, [pc, #108]	; (80025fc <PtCan_SdStorage_storeSD+0x8c>)
 8002590:	715a      	strb	r2, [r3, #5]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:182
	}

	if (save_files & TORQUE3_MASK) {
 8002592:	4b19      	ldr	r3, [pc, #100]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 8002594:	781b      	ldrb	r3, [r3, #0]
 8002596:	f013 0f02 	tst.w	r3, #2
 800259a:	d00a      	beq.n	80025b2 <PtCan_SdStorage_storeSD+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:184

		PtCan_SdStorage_sendData(1);
 800259c:	2001      	movs	r0, #1
 800259e:	f7ff ffa5 	bl	80024ec <PtCan_SdStorage_sendData>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:187

		// data transfer finished
		save_files = save_files & (~TORQUE3_MASK); // setze entsprechendes bit von Gesch.rad bei save_files, damit man signal., dass der erster Buffer von Geschw. voll ist
 80025a2:	4a15      	ldr	r2, [pc, #84]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 80025a4:	7813      	ldrb	r3, [r2, #0]
 80025a6:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 80025aa:	7013      	strb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:188
		FileDescriptorMap[1].signal_arrvoll = 0;
 80025ac:	2200      	movs	r2, #0
 80025ae:	4b13      	ldr	r3, [pc, #76]	; (80025fc <PtCan_SdStorage_storeSD+0x8c>)
 80025b0:	755a      	strb	r2, [r3, #21]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:192

	}

	if (save_files & VELOCITYWHEEL_MASK) {
 80025b2:	4b11      	ldr	r3, [pc, #68]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 80025b4:	781b      	ldrb	r3, [r3, #0]
 80025b6:	f013 0f04 	tst.w	r3, #4
 80025ba:	d00b      	beq.n	80025d4 <PtCan_SdStorage_storeSD+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:194

		PtCan_SdStorage_sendData(2);
 80025bc:	2002      	movs	r0, #2
 80025be:	f7ff ff95 	bl	80024ec <PtCan_SdStorage_sendData>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:196
		// data transfer finished
		save_files = save_files & (~VELOCITYWHEEL_MASK); // setze entsprechendes bit von Gesch.rad bei save_files, damit man signal., dass der erster Buffer von Geschw. voll ist
 80025c2:	4a0d      	ldr	r2, [pc, #52]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 80025c4:	7813      	ldrb	r3, [r2, #0]
 80025c6:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80025ca:	7013      	strb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:197
		FileDescriptorMap[2].signal_arrvoll = 0;
 80025cc:	2200      	movs	r2, #0
 80025ce:	4b0b      	ldr	r3, [pc, #44]	; (80025fc <PtCan_SdStorage_storeSD+0x8c>)
 80025d0:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:201

	}

	if (save_files & VELOCITYCAR_MASK) {
 80025d4:	4b08      	ldr	r3, [pc, #32]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 80025d6:	781b      	ldrb	r3, [r3, #0]
 80025d8:	f013 0f08 	tst.w	r3, #8
 80025dc:	d00b      	beq.n	80025f6 <PtCan_SdStorage_storeSD+0x86>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:203

		PtCan_SdStorage_sendData(3);
 80025de:	2003      	movs	r0, #3
 80025e0:	f7ff ff84 	bl	80024ec <PtCan_SdStorage_sendData>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:205
		// data transfer finished
		save_files = save_files & (~VELOCITYCAR_MASK); // ruecksetze entsprechendes bit von Gesch.rad bei save_files, damit man signal., dass der erster Buffer von Geschw. gesendet worden ist
 80025e4:	4a04      	ldr	r2, [pc, #16]	; (80025f8 <PtCan_SdStorage_storeSD+0x88>)
 80025e6:	7813      	ldrb	r3, [r2, #0]
 80025e8:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
 80025ec:	7013      	strb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:206
		FileDescriptorMap[3].signal_arrvoll = 0; // Array gesendet
 80025ee:	2200      	movs	r2, #0
 80025f0:	4b02      	ldr	r3, [pc, #8]	; (80025fc <PtCan_SdStorage_storeSD+0x8c>)
 80025f2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 80025f6:	bd08      	pop	{r3, pc}
 80025f8:	2000117c 	.word	0x2000117c
 80025fc:	20001ba0 	.word	0x20001ba0

08002600 <PtCan_SdStorage_storeRAM>:
PtCan_SdStorage_storeRAM():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:218
 * 				 has to be sent to sd card.
 * @param  None
 * @retval None
 */
void PtCan_SdStorage_storeRAM(uint8_t dataIndex, volatile uint32_t time,
		volatile int16_t value) {
 8002600:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002602:	b091      	sub	sp, #68	; 0x44
 8002604:	4604      	mov	r4, r0
 8002606:	9101      	str	r1, [sp, #4]
 8002608:	f8ad 2002 	strh.w	r2, [sp, #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:222
	uint8_t help_array = 0;
	char buffer_tmp[50];

	help_array = sprintf(buffer_tmp, "%u;%d\n", time, value); // Fuelle Array zum ueberpruefen, ob 512 Bytes schon voll sind
 800260c:	9a01      	ldr	r2, [sp, #4]
 800260e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002612:	b21b      	sxth	r3, r3
 8002614:	495d      	ldr	r1, [pc, #372]	; (800278c <PtCan_SdStorage_storeRAM+0x18c>)
 8002616:	a803      	add	r0, sp, #12
 8002618:	f003 fc68 	bl	8005eec <siprintf>
 800261c:	b2c0      	uxtb	r0, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:224

	if (512 <= (FileDescriptorMap[dataIndex].co_arr_save + help_array)) { // Falls zu fuellendes Array keinen Platz mehr hat, dann...
 800261e:	4626      	mov	r6, r4
 8002620:	4b5b      	ldr	r3, [pc, #364]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002622:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 8002626:	885b      	ldrh	r3, [r3, #2]
 8002628:	fa10 f383 	uxtah	r3, r0, r3
 800262c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002630:	db7d      	blt.n	800272e <PtCan_SdStorage_storeRAM+0x12e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:225
		uint16_t anfang_2fuell = FileDescriptorMap[dataIndex].co_arr_save;
 8002632:	4b57      	ldr	r3, [pc, #348]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002634:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 8002638:	885d      	ldrh	r5, [r3, #2]
 800263a:	b2ad      	uxth	r5, r5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:226
		FileDescriptorMap[dataIndex].signal_arrvoll = 1;     // Array ist voll
 800263c:	2201      	movs	r2, #1
 800263e:	715a      	strb	r2, [r3, #5]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:228

		for (uint8_t i = 0; i < help_array; i++) {
 8002640:	2300      	movs	r3, #0
 8002642:	e05d      	b.n	8002700 <PtCan_SdStorage_storeRAM+0x100>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:230

			if (i < 512 - anfang_2fuell) { // Fuelle Array bis 512...
 8002644:	461a      	mov	r2, r3
 8002646:	f5c5 7100 	rsb	r1, r5, #512	; 0x200
 800264a:	428b      	cmp	r3, r1
 800264c:	da12      	bge.n	8002674 <PtCan_SdStorage_storeRAM+0x74>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:231
				arr2SD[FileDescriptorMap[dataIndex].co_arr_full][FileDescriptorMap[dataIndex].co_arr_save++] =	buffer_tmp[i];
 800264e:	4a50      	ldr	r2, [pc, #320]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002650:	eb02 1206 	add.w	r2, r2, r6, lsl #4
 8002654:	f892 e004 	ldrb.w	lr, [r2, #4]
 8002658:	8851      	ldrh	r1, [r2, #2]
 800265a:	b289      	uxth	r1, r1
 800265c:	1c4f      	adds	r7, r1, #1
 800265e:	b2bf      	uxth	r7, r7
 8002660:	8057      	strh	r7, [r2, #2]
 8002662:	aa10      	add	r2, sp, #64	; 0x40
 8002664:	441a      	add	r2, r3
 8002666:	f812 7c34 	ldrb.w	r7, [r2, #-52]
 800266a:	4a4a      	ldr	r2, [pc, #296]	; (8002794 <PtCan_SdStorage_storeRAM+0x194>)
 800266c:	eb02 224e 	add.w	r2, r2, lr, lsl #9
 8002670:	5457      	strb	r7, [r2, r1]
 8002672:	e036      	b.n	80026e2 <PtCan_SdStorage_storeRAM+0xe2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:233
			} else {         // den Rest im naechsten Array
				if (FileDescriptorMap[dataIndex].co_arr_full == (dataIndex<<1)) { // Falls 1. array voll
 8002674:	4946      	ldr	r1, [pc, #280]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002676:	eb01 1106 	add.w	r1, r1, r6, lsl #4
 800267a:	7909      	ldrb	r1, [r1, #4]
 800267c:	b2c9      	uxtb	r1, r1
 800267e:	ebb1 0f46 	cmp.w	r1, r6, lsl #1
 8002682:	d117      	bne.n	80026b4 <PtCan_SdStorage_storeRAM+0xb4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:234
					arr2SD[FileDescriptorMap[dataIndex].co_arr_full + 1][FileDescriptorMap[dataIndex].co_arr_save++] =	buffer_tmp[i]; // ich verwende diese Anweisung co_arr_full_TR1+1, da ich nicht immer wieder co_arr_full_TR1 erhoehen kann
 8002684:	4942      	ldr	r1, [pc, #264]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002686:	eb01 1106 	add.w	r1, r1, r6, lsl #4
 800268a:	f891 e004 	ldrb.w	lr, [r1, #4]
 800268e:	f10e 0e01 	add.w	lr, lr, #1
 8002692:	884f      	ldrh	r7, [r1, #2]
 8002694:	b2bf      	uxth	r7, r7
 8002696:	f107 0c01 	add.w	ip, r7, #1
 800269a:	fa1f fc8c 	uxth.w	ip, ip
 800269e:	f8a1 c002 	strh.w	ip, [r1, #2]
 80026a2:	a910      	add	r1, sp, #64	; 0x40
 80026a4:	440a      	add	r2, r1
 80026a6:	f812 1c34 	ldrb.w	r1, [r2, #-52]
 80026aa:	4a3a      	ldr	r2, [pc, #232]	; (8002794 <PtCan_SdStorage_storeRAM+0x194>)
 80026ac:	eb02 224e 	add.w	r2, r2, lr, lsl #9
 80026b0:	55d1      	strb	r1, [r2, r7]
 80026b2:	e016      	b.n	80026e2 <PtCan_SdStorage_storeRAM+0xe2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:237
				} else
					// Falls 2. array voll
					arr2SD[FileDescriptorMap[dataIndex].co_arr_full - 1][FileDescriptorMap[dataIndex].co_arr_save++] =	buffer_tmp[i]; // ich verwende diese Anweisung co_arr_full_TR1+1, da ich nicht immer wieder co_arr_full_TR1 erhoehen kann
 80026b4:	4936      	ldr	r1, [pc, #216]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 80026b6:	eb01 1106 	add.w	r1, r1, r6, lsl #4
 80026ba:	f891 e004 	ldrb.w	lr, [r1, #4]
 80026be:	f10e 3eff 	add.w	lr, lr, #4294967295
 80026c2:	884f      	ldrh	r7, [r1, #2]
 80026c4:	b2bf      	uxth	r7, r7
 80026c6:	f107 0c01 	add.w	ip, r7, #1
 80026ca:	fa1f fc8c 	uxth.w	ip, ip
 80026ce:	f8a1 c002 	strh.w	ip, [r1, #2]
 80026d2:	a910      	add	r1, sp, #64	; 0x40
 80026d4:	440a      	add	r2, r1
 80026d6:	f812 1c34 	ldrb.w	r1, [r2, #-52]
 80026da:	4a2e      	ldr	r2, [pc, #184]	; (8002794 <PtCan_SdStorage_storeRAM+0x194>)
 80026dc:	eb02 224e 	add.w	r2, r2, lr, lsl #9
 80026e0:	55d1      	strb	r1, [r2, r7]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:239
			}
			if (FileDescriptorMap[dataIndex].co_arr_save == 512) // Ist beliebiger Array voll
 80026e2:	4a2b      	ldr	r2, [pc, #172]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 80026e4:	eb02 1206 	add.w	r2, r2, r6, lsl #4
 80026e8:	8852      	ldrh	r2, [r2, #2]
 80026ea:	b292      	uxth	r2, r2
 80026ec:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 80026f0:	d104      	bne.n	80026fc <PtCan_SdStorage_storeRAM+0xfc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:240
				FileDescriptorMap[dataIndex].co_arr_save = 0; // initialisiere erneut Array-Fuellung
 80026f2:	4a27      	ldr	r2, [pc, #156]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 80026f4:	eb02 1206 	add.w	r2, r2, r6, lsl #4
 80026f8:	2100      	movs	r1, #0
 80026fa:	8051      	strh	r1, [r2, #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:228 (discriminator 2)

	if (512 <= (FileDescriptorMap[dataIndex].co_arr_save + help_array)) { // Falls zu fuellendes Array keinen Platz mehr hat, dann...
		uint16_t anfang_2fuell = FileDescriptorMap[dataIndex].co_arr_save;
		FileDescriptorMap[dataIndex].signal_arrvoll = 1;     // Array ist voll

		for (uint8_t i = 0; i < help_array; i++) {
 80026fc:	3301      	adds	r3, #1
 80026fe:	b2db      	uxtb	r3, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:228 (discriminator 1)
 8002700:	4283      	cmp	r3, r0
 8002702:	d39f      	bcc.n	8002644 <PtCan_SdStorage_storeRAM+0x44>
 8002704:	e016      	b.n	8002734 <PtCan_SdStorage_storeRAM+0x134>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:246 (discriminator 3)
		}

	} else { // Falls zu fuellendes Array noch Platz hat, dann...

		for (uint8_t i = 0; i < help_array; i++)
			arr2SD[FileDescriptorMap[dataIndex].co_arr_full][FileDescriptorMap[dataIndex].co_arr_save++] =	buffer_tmp[i];
 8002706:	4a22      	ldr	r2, [pc, #136]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002708:	eb02 1206 	add.w	r2, r2, r6, lsl #4
 800270c:	7917      	ldrb	r7, [r2, #4]
 800270e:	8851      	ldrh	r1, [r2, #2]
 8002710:	b289      	uxth	r1, r1
 8002712:	1c4d      	adds	r5, r1, #1
 8002714:	b2ad      	uxth	r5, r5
 8002716:	8055      	strh	r5, [r2, #2]
 8002718:	aa10      	add	r2, sp, #64	; 0x40
 800271a:	441a      	add	r2, r3
 800271c:	f812 5c34 	ldrb.w	r5, [r2, #-52]
 8002720:	4a1c      	ldr	r2, [pc, #112]	; (8002794 <PtCan_SdStorage_storeRAM+0x194>)
 8002722:	eb02 2247 	add.w	r2, r2, r7, lsl #9
 8002726:	5455      	strb	r5, [r2, r1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:245 (discriminator 3)
				FileDescriptorMap[dataIndex].co_arr_save = 0; // initialisiere erneut Array-Fuellung
		}

	} else { // Falls zu fuellendes Array noch Platz hat, dann...

		for (uint8_t i = 0; i < help_array; i++)
 8002728:	3301      	adds	r3, #1
 800272a:	b2db      	uxtb	r3, r3
 800272c:	e000      	b.n	8002730 <PtCan_SdStorage_storeRAM+0x130>
 800272e:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:245 (discriminator 1)
 8002730:	4283      	cmp	r3, r0
 8002732:	d3e8      	bcc.n	8002706 <PtCan_SdStorage_storeRAM+0x106>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:249
			arr2SD[FileDescriptorMap[dataIndex].co_arr_full][FileDescriptorMap[dataIndex].co_arr_save++] =	buffer_tmp[i];
	}

	if (FileDescriptorMap[dataIndex].signal_arrvoll	&& ((save_files & FileDescriptorMap[dataIndex].savingMasks) == 0)) { // Falls buffer voll und Datenspeicherung gerade nicht stattfindet...
 8002734:	4b16      	ldr	r3, [pc, #88]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002736:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 800273a:	795b      	ldrb	r3, [r3, #5]
 800273c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8002740:	d022      	beq.n	8002788 <PtCan_SdStorage_storeRAM+0x188>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:249 (discriminator 1)
 8002742:	0123      	lsls	r3, r4, #4
 8002744:	4a12      	ldr	r2, [pc, #72]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002746:	5cd3      	ldrb	r3, [r2, r3]
 8002748:	4a13      	ldr	r2, [pc, #76]	; (8002798 <PtCan_SdStorage_storeRAM+0x198>)
 800274a:	7812      	ldrb	r2, [r2, #0]
 800274c:	421a      	tst	r2, r3
 800274e:	d11b      	bne.n	8002788 <PtCan_SdStorage_storeRAM+0x188>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:250
		save_files = save_files | FileDescriptorMap[dataIndex].savingMasks; // setze entsprechendes bit von Gesch.rad bei save_files, damit man signal., dass der erster Buffer von Geschw. voll ist
 8002750:	4a0f      	ldr	r2, [pc, #60]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 8002752:	0123      	lsls	r3, r4, #4
 8002754:	18d1      	adds	r1, r2, r3
 8002756:	5cd3      	ldrb	r3, [r2, r3]
 8002758:	4a0f      	ldr	r2, [pc, #60]	; (8002798 <PtCan_SdStorage_storeRAM+0x198>)
 800275a:	7810      	ldrb	r0, [r2, #0]
 800275c:	4303      	orrs	r3, r0
 800275e:	7013      	strb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:251
		if (FileDescriptorMap[dataIndex].co_arr_full == (dataIndex<<1)) // nachdem am Anfang das 1. array gefuellt wurde
 8002760:	790b      	ldrb	r3, [r1, #4]
 8002762:	b2db      	uxtb	r3, r3
 8002764:	ebb3 0f44 	cmp.w	r3, r4, lsl #1
 8002768:	d107      	bne.n	800277a <PtCan_SdStorage_storeRAM+0x17a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:252
			FileDescriptorMap[dataIndex].co_arr_full++;
 800276a:	4b09      	ldr	r3, [pc, #36]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 800276c:	eb03 1404 	add.w	r4, r3, r4, lsl #4
 8002770:	7923      	ldrb	r3, [r4, #4]
 8002772:	3301      	adds	r3, #1
 8002774:	b2db      	uxtb	r3, r3
 8002776:	7123      	strb	r3, [r4, #4]
 8002778:	e006      	b.n	8002788 <PtCan_SdStorage_storeRAM+0x188>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:255
		else
			// nachdem das 2. array gefuellt wurde, wird das erste wieder gefuellt
			FileDescriptorMap[dataIndex].co_arr_full--;
 800277a:	4b05      	ldr	r3, [pc, #20]	; (8002790 <PtCan_SdStorage_storeRAM+0x190>)
 800277c:	eb03 1404 	add.w	r4, r3, r4, lsl #4
 8002780:	7923      	ldrb	r3, [r4, #4]
 8002782:	3b01      	subs	r3, #1
 8002784:	b2db      	uxtb	r3, r3
 8002786:	7123      	strb	r3, [r4, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:257
	}
}
 8002788:	b011      	add	sp, #68	; 0x44
 800278a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800278c:	080067a4 	.word	0x080067a4
 8002790:	20001ba0 	.word	0x20001ba0
 8002794:	2000017c 	.word	0x2000017c
 8002798:	2000117c 	.word	0x2000117c

0800279c <PtCan_initMemory>:
PtCan_initMemory():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:267
 * @param  None
 * @retval None
 */
void PtCan_initMemory() {

	FileDescriptorMap[0].savingMasks = TORQUE1_MASK;
 800279c:	4b16      	ldr	r3, [pc, #88]	; (80027f8 <PtCan_initMemory+0x5c>)
 800279e:	2201      	movs	r2, #1
 80027a0:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:268
	FileDescriptorMap[0].co_arr_full = 0;
 80027a2:	2200      	movs	r2, #0
 80027a4:	711a      	strb	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:269
	FileDescriptorMap[0].co_arr_save = 0;
 80027a6:	805a      	strh	r2, [r3, #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:270
	FileDescriptorMap[0].signal_arrvoll = 0;
 80027a8:	715a      	strb	r2, [r3, #5]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:271
	FileDescriptorMap[0].file_data = &fil_torque1;
 80027aa:	4914      	ldr	r1, [pc, #80]	; (80027fc <PtCan_initMemory+0x60>)
 80027ac:	6099      	str	r1, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:272
	FileDescriptorMap[0].strs_data = "SD:torque1_zus.csv";
 80027ae:	4914      	ldr	r1, [pc, #80]	; (8002800 <PtCan_initMemory+0x64>)
 80027b0:	60d9      	str	r1, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:274

	FileDescriptorMap[1].savingMasks = TORQUE3_MASK;
 80027b2:	2102      	movs	r1, #2
 80027b4:	7419      	strb	r1, [r3, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:275
	FileDescriptorMap[1].co_arr_full = 2;
 80027b6:	7519      	strb	r1, [r3, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:276
	FileDescriptorMap[1].co_arr_save = 0;
 80027b8:	825a      	strh	r2, [r3, #18]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:277
	FileDescriptorMap[1].signal_arrvoll = 0;
 80027ba:	755a      	strb	r2, [r3, #21]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:278
	FileDescriptorMap[1].file_data = &fil_torque3;
 80027bc:	4911      	ldr	r1, [pc, #68]	; (8002804 <PtCan_initMemory+0x68>)
 80027be:	6199      	str	r1, [r3, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:279
	FileDescriptorMap[1].strs_data = "SD:torque3_zus.csv";
 80027c0:	4911      	ldr	r1, [pc, #68]	; (8002808 <PtCan_initMemory+0x6c>)
 80027c2:	61d9      	str	r1, [r3, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:281

	FileDescriptorMap[2].savingMasks = VELOCITYWHEEL_MASK;
 80027c4:	2104      	movs	r1, #4
 80027c6:	f883 1020 	strb.w	r1, [r3, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:282
	FileDescriptorMap[2].co_arr_full = 4;
 80027ca:	f883 1024 	strb.w	r1, [r3, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:283
	FileDescriptorMap[2].co_arr_save = 0;
 80027ce:	845a      	strh	r2, [r3, #34]	; 0x22
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:284
	FileDescriptorMap[2].signal_arrvoll = 0;
 80027d0:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:285
	FileDescriptorMap[2].file_data = &fil_gesch_wheel;
 80027d4:	490d      	ldr	r1, [pc, #52]	; (800280c <PtCan_initMemory+0x70>)
 80027d6:	6299      	str	r1, [r3, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:286
	FileDescriptorMap[2].strs_data = "SD:geschwindigkeit_rad_zus.csv";
 80027d8:	490d      	ldr	r1, [pc, #52]	; (8002810 <PtCan_initMemory+0x74>)
 80027da:	62d9      	str	r1, [r3, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:288

	FileDescriptorMap[3].savingMasks = VELOCITYCAR_MASK;
 80027dc:	2108      	movs	r1, #8
 80027de:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:289
	FileDescriptorMap[3].co_arr_full = 6;
 80027e2:	2106      	movs	r1, #6
 80027e4:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:290
	FileDescriptorMap[3].co_arr_save = 0;
 80027e8:	865a      	strh	r2, [r3, #50]	; 0x32
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:291
	FileDescriptorMap[3].signal_arrvoll = 0;
 80027ea:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:292
	FileDescriptorMap[3].file_data = &fil_gesch_car;
 80027ee:	4a09      	ldr	r2, [pc, #36]	; (8002814 <PtCan_initMemory+0x78>)
 80027f0:	639a      	str	r2, [r3, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:293
	FileDescriptorMap[3].strs_data = "SD:geschwindigkeit_auto_zus.csv";
 80027f2:	4a09      	ldr	r2, [pc, #36]	; (8002818 <PtCan_initMemory+0x7c>)
 80027f4:	63da      	str	r2, [r3, #60]	; 0x3c
 80027f6:	4770      	bx	lr
 80027f8:	20001ba0 	.word	0x20001ba0
 80027fc:	20001180 	.word	0x20001180
 8002800:	080067ac 	.word	0x080067ac
 8002804:	200013a8 	.word	0x200013a8
 8002808:	080067c0 	.word	0x080067c0
 800280c:	200015d0 	.word	0x200015d0
 8002810:	080067d4 	.word	0x080067d4
 8002814:	200017f8 	.word	0x200017f8
 8002818:	080067f4 	.word	0x080067f4

0800281c <PtCan_SdStorage_SDMount>:
PtCan_SdStorage_SDMount():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:302
/**
 * @brief  Force communication with SD card
 * @param  on_off: connect or disconnect
 * @retval StatusType: return exit status of communication setting
 */
void PtCan_SdStorage_SDMount(uint8_t on_off) {
 800281c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:304

	if (on_off == STD_ON) {
 800281e:	2801      	cmp	r0, #1
 8002820:	d108      	bne.n	8002834 <PtCan_SdStorage_SDMount+0x18>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:305
		if(f_mount(&FS, "SD:", 1) != E_OK)
 8002822:	2201      	movs	r2, #1
 8002824:	4908      	ldr	r1, [pc, #32]	; (8002848 <PtCan_SdStorage_SDMount+0x2c>)
 8002826:	4809      	ldr	r0, [pc, #36]	; (800284c <PtCan_SdStorage_SDMount+0x30>)
 8002828:	f002 fc68 	bl	80050fc <f_mount>
 800282c:	b150      	cbz	r0, 8002844 <PtCan_SdStorage_SDMount+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:306
			Error_Handler_fats();
 800282e:	f7ff fe27 	bl	8002480 <Error_Handler_fats>
 8002832:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:309
	} else {
		/* Unmount SDCARD */
		if(f_mount(NULL, "SD:", 1) != E_OK)
 8002834:	2201      	movs	r2, #1
 8002836:	4904      	ldr	r1, [pc, #16]	; (8002848 <PtCan_SdStorage_SDMount+0x2c>)
 8002838:	2000      	movs	r0, #0
 800283a:	f002 fc5f 	bl	80050fc <f_mount>
 800283e:	b108      	cbz	r0, 8002844 <PtCan_SdStorage_SDMount+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:310
			Error_Handler_fats();
 8002840:	f7ff fe1e 	bl	8002480 <Error_Handler_fats>
 8002844:	bd08      	pop	{r3, pc}
 8002846:	bf00      	nop
 8002848:	080067a0 	.word	0x080067a0
 800284c:	20001be0 	.word	0x20001be0

08002850 <PtCan_SdStorage_getStorageState>:
PtCan_SdStorage_getStorageState():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:321
 * @param  None
 * @retval cantrans_sdstor_init: indicates state of storage process of incoming CAN-Bus raw data
 */
uint8_t PtCan_SdStorage_getStorageState() {

	return cantrans_sdstor_init;
 8002850:	4b01      	ldr	r3, [pc, #4]	; (8002858 <PtCan_SdStorage_getStorageState+0x8>)
 8002852:	7818      	ldrb	r0, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:323

}
 8002854:	4770      	bx	lr
 8002856:	bf00      	nop
 8002858:	20001a20 	.word	0x20001a20

0800285c <PtCan_SdStorage_setStorageState>:
PtCan_SdStorage_setStorageState():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_SdStorage.c:333
 * 							STD_OFF Data file closed, storage has still not begun or has been finished.
 * @retval None
 */
void PtCan_SdStorage_setStorageState(uint8_t neu) {

	cantrans_sdstor_init = neu;
 800285c:	4b01      	ldr	r3, [pc, #4]	; (8002864 <PtCan_SdStorage_setStorageState+0x8>)
 800285e:	7018      	strb	r0, [r3, #0]
 8002860:	4770      	bx	lr
 8002862:	bf00      	nop
 8002864:	20001a20 	.word	0x20001a20

08002868 <MX_TIM2_Init>:
MX_TIM2_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:52
/**
 * @brief  Initialization functions for Timer 2 object.
 * @param  None
 * @retval None
 */
void MX_TIM2_Init(void) {
 8002868:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:54

	htim2.Instance = TIM2;
 800286a:	4806      	ldr	r0, [pc, #24]	; (8002884 <MX_TIM2_Init+0x1c>)
 800286c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002870:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:55
	htim2.Init.Prescaler = 0;
 8002872:	2300      	movs	r3, #0
 8002874:	6043      	str	r3, [r0, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:56
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8002876:	6083      	str	r3, [r0, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:57
	htim2.Init.Period = 84000;                    // Timer eingestellt bei 1ms
 8002878:	4a03      	ldr	r2, [pc, #12]	; (8002888 <MX_TIM2_Init+0x20>)
 800287a:	60c2      	str	r2, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:58
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800287c:	6103      	str	r3, [r0, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:59
	HAL_TIM_Base_Init(&htim2);
 800287e:	f7ff fbcb 	bl	8002018 <HAL_TIM_Base_Init>
 8002882:	bd08      	pop	{r3, pc}
 8002884:	20001e50 	.word	0x20001e50
 8002888:	00014820 	.word	0x00014820

0800288c <MX_TIM3_Init>:
MX_TIM3_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:68
/**
 * @brief  Initialization functions for Timer 3 object.
 * @param  None
 * @retval None
 */
void MX_TIM3_Init(void) {
 800288c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:70

	htim3.Instance = TIM3;
 800288e:	4807      	ldr	r0, [pc, #28]	; (80028ac <MX_TIM3_Init+0x20>)
 8002890:	4b07      	ldr	r3, [pc, #28]	; (80028b0 <MX_TIM3_Init+0x24>)
 8002892:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:71
	htim3.Init.Prescaler = 16800;
 8002894:	f244 13a0 	movw	r3, #16800	; 0x41a0
 8002898:	6043      	str	r3, [r0, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:72
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 800289a:	2300      	movs	r3, #0
 800289c:	6083      	str	r3, [r0, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:73
	htim3.Init.Period = 10000;                    // Timer eingestellt bei 2s
 800289e:	f242 7210 	movw	r2, #10000	; 0x2710
 80028a2:	60c2      	str	r2, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:74
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80028a4:	6103      	str	r3, [r0, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:75
	HAL_TIM_Base_Init(&htim3);
 80028a6:	f7ff fbb7 	bl	8002018 <HAL_TIM_Base_Init>
 80028aa:	bd08      	pop	{r3, pc}
 80028ac:	20001e14 	.word	0x20001e14
 80028b0:	40000400 	.word	0x40000400

080028b4 <PtCan_Tim_SetState>:
PtCan_Tim_SetState():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:118
 * 												- INST_TIM3
 * 				 on_off: 	- STD_ON: activate timer interrupt handling process
 * 				 					- STD_OFF: deactivate timer interrupt handling process
 * @retval None
 */
void PtCan_Tim_SetState(uint8_t instance_timer, uint8_t on_off) {
 80028b4:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:119
	if (on_off == STD_ON) {
 80028b6:	2901      	cmp	r1, #1
 80028b8:	d10e      	bne.n	80028d8 <PtCan_Tim_SetState+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:120
		if (instance_timer == INST_TIM2) {
 80028ba:	b930      	cbnz	r0, 80028ca <PtCan_Tim_SetState+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:121
			if (HAL_TIM_Base_Start_IT(&htim2) != HAL_OK) { // (Erneute) Initialisierung Timer2
 80028bc:	480e      	ldr	r0, [pc, #56]	; (80028f8 <PtCan_Tim_SetState+0x44>)
 80028be:	f7ff f9b5 	bl	8001c2c <HAL_TIM_Base_Start_IT>
 80028c2:	b1b8      	cbz	r0, 80028f4 <PtCan_Tim_SetState+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:123
				/* Counter Enable Error */
				Error_Handler();
 80028c4:	f7ff fdec 	bl	80024a0 <Error_Handler>
 80028c8:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:126
			}
		} else {
			if (HAL_TIM_Base_Start_IT(&htim3) != HAL_OK) { // (Erneute) Initialisierung Timer3
 80028ca:	480c      	ldr	r0, [pc, #48]	; (80028fc <PtCan_Tim_SetState+0x48>)
 80028cc:	f7ff f9ae 	bl	8001c2c <HAL_TIM_Base_Start_IT>
 80028d0:	b180      	cbz	r0, 80028f4 <PtCan_Tim_SetState+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:128
				/* Counter Enable Error */
				Error_Handler();
 80028d2:	f7ff fde5 	bl	80024a0 <Error_Handler>
 80028d6:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:133
			}
		}
	} else {
		// Stop timer interrupt
		if (instance_timer == INST_TIM2) {
 80028d8:	b930      	cbnz	r0, 80028e8 <PtCan_Tim_SetState+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:134
					if (HAL_TIM_Base_Stop_IT(&htim2) != HAL_OK) {
 80028da:	4807      	ldr	r0, [pc, #28]	; (80028f8 <PtCan_Tim_SetState+0x44>)
 80028dc:	f7ff f9f4 	bl	8001cc8 <HAL_TIM_Base_Stop_IT>
 80028e0:	b140      	cbz	r0, 80028f4 <PtCan_Tim_SetState+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:136
						/* Counter Enable Error */
						Error_Handler();
 80028e2:	f7ff fddd 	bl	80024a0 <Error_Handler>
 80028e6:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:139
					}
		} else {
					if (HAL_TIM_Base_Stop_IT(&htim3) != HAL_OK) {
 80028e8:	4804      	ldr	r0, [pc, #16]	; (80028fc <PtCan_Tim_SetState+0x48>)
 80028ea:	f7ff f9ed 	bl	8001cc8 <HAL_TIM_Base_Stop_IT>
 80028ee:	b108      	cbz	r0, 80028f4 <PtCan_Tim_SetState+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:141
						/* Counter Enable Error */
						Error_Handler();
 80028f0:	f7ff fdd6 	bl	80024a0 <Error_Handler>
 80028f4:	bd08      	pop	{r3, pc}
 80028f6:	bf00      	nop
 80028f8:	20001e50 	.word	0x20001e50
 80028fc:	20001e14 	.word	0x20001e14

08002900 <HAL_TIM_PeriodElapsedCallback>:
HAL_TIM_PeriodElapsedCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:87
 * @param  htim: timer handling object
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {

	if (htim->Instance == TIM2) {
 8002900:	6803      	ldr	r3, [r0, #0]
 8002902:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002906:	d10d      	bne.n	8002924 <HAL_TIM_PeriodElapsedCallback+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:89

		if (counter < 0xFFFFFFFF) {
 8002908:	4b0e      	ldr	r3, [pc, #56]	; (8002944 <HAL_TIM_PeriodElapsedCallback+0x44>)
 800290a:	681b      	ldr	r3, [r3, #0]
 800290c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002910:	d004      	beq.n	800291c <HAL_TIM_PeriodElapsedCallback+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:91

			counter++;
 8002912:	4a0c      	ldr	r2, [pc, #48]	; (8002944 <HAL_TIM_PeriodElapsedCallback+0x44>)
 8002914:	6813      	ldr	r3, [r2, #0]
 8002916:	3301      	adds	r3, #1
 8002918:	6013      	str	r3, [r2, #0]
 800291a:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:93
		} else
			counter = 0;
 800291c:	2200      	movs	r2, #0
 800291e:	4b09      	ldr	r3, [pc, #36]	; (8002944 <HAL_TIM_PeriodElapsedCallback+0x44>)
 8002920:	601a      	str	r2, [r3, #0]
 8002922:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:95

	} else if (htim->Instance == TIM3) {
 8002924:	4a08      	ldr	r2, [pc, #32]	; (8002948 <HAL_TIM_PeriodElapsedCallback+0x48>)
 8002926:	4293      	cmp	r3, r2
 8002928:	d1f7      	bne.n	800291a <HAL_TIM_PeriodElapsedCallback+0x1a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:85
 * @brief  Callback handling. TIM2 counts until 1ms to increment variable before being restarted.
 * 				 TIM3 counts until 2s to activate external interrupt for button usage, before beginning counting process.
 * @param  htim: timer handling object
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
 800292a:	b510      	push	{r4, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:97
		} else
			counter = 0;

	} else if (htim->Instance == TIM3) {

		__HAL_GPIO_EXTI_CLEAR_IT(KEY_BUTTON_PIN);
 800292c:	2401      	movs	r4, #1
 800292e:	4b07      	ldr	r3, [pc, #28]	; (800294c <HAL_TIM_PeriodElapsedCallback+0x4c>)
 8002930:	615c      	str	r4, [r3, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:98
		HAL_NVIC_EnableIRQ(KEY_BUTTON_EXTI_IRQn);
 8002932:	2006      	movs	r0, #6
 8002934:	f7fe fa08 	bl	8000d48 <HAL_NVIC_EnableIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:104

//		if (HAL_TIM_Base_Stop_IT(&htim3) != HAL_OK) { // Stop timer interrupt nach 2 Sekunden
//			/* Counter Enable Error */
//			Error_Handler();
//		}
		PtCan_Tim_SetState(INST_TIM3, STD_OFF);
 8002938:	2100      	movs	r1, #0
 800293a:	4620      	mov	r0, r4
 800293c:	f7ff ffba 	bl	80028b4 <PtCan_Tim_SetState>
 8002940:	bd10      	pop	{r4, pc}
 8002942:	bf00      	nop
 8002944:	20001a24 	.word	0x20001a24
 8002948:	40000400 	.word	0x40000400
 800294c:	40013c00 	.word	0x40013c00

08002950 <PtCan_Tim_GetCounter>:
PtCan_Tim_GetCounter():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:153
 * @brief  Get actual counter number incresed thought timer2 interrupt handling routine
 * @retval counter
 */
uint16_t PtCan_Tim_GetCounter()
{
	return counter;
 8002950:	4b01      	ldr	r3, [pc, #4]	; (8002958 <PtCan_Tim_GetCounter+0x8>)
 8002952:	6818      	ldr	r0, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:154
}
 8002954:	b280      	uxth	r0, r0
 8002956:	4770      	bx	lr
 8002958:	20001a24 	.word	0x20001a24

0800295c <PtCan_Tim_ResetCounter>:
PtCan_Tim_ResetCounter():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/PtCan_Tim.c:163
 * @param  None
 * @retval None
 */
void PtCan_Tim_ResetCounter()
{
	counter = 0;
 800295c:	2200      	movs	r2, #0
 800295e:	4b01      	ldr	r3, [pc, #4]	; (8002964 <PtCan_Tim_ResetCounter+0x8>)
 8002960:	601a      	str	r2, [r3, #0]
 8002962:	4770      	bx	lr
 8002964:	20001a24 	.word	0x20001a24

08002968 <BSP_LED_Init>:
BSP_LED_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:50
 *     @arg LED3
 *     @arg LED5
 *     @arg LED6
 * @retval None
 */
void BSP_LED_Init(Led_TypeDef Led) {
 8002968:	b570      	push	{r4, r5, r6, lr}
 800296a:	b08a      	sub	sp, #40	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54
	GPIO_InitTypeDef GPIO_InitStruct;

	/* Enable the GPIO_LED Clock */
	LEDx_GPIO_CLK_ENABLE(Led);
 800296c:	4604      	mov	r4, r0
 800296e:	b950      	cbnz	r0, 8002986 <BSP_LED_Init+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54 (discriminator 1)
 8002970:	4b23      	ldr	r3, [pc, #140]	; (8002a00 <BSP_LED_Init+0x98>)
 8002972:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002974:	f042 0208 	orr.w	r2, r2, #8
 8002978:	631a      	str	r2, [r3, #48]	; 0x30
 800297a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800297c:	f003 0308 	and.w	r3, r3, #8
 8002980:	9301      	str	r3, [sp, #4]
 8002982:	9b01      	ldr	r3, [sp, #4]
 8002984:	e025      	b.n	80029d2 <BSP_LED_Init+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54 (discriminator 2)
 8002986:	2801      	cmp	r0, #1
 8002988:	d10a      	bne.n	80029a0 <BSP_LED_Init+0x38>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54 (discriminator 3)
 800298a:	4b1d      	ldr	r3, [pc, #116]	; (8002a00 <BSP_LED_Init+0x98>)
 800298c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800298e:	f042 0208 	orr.w	r2, r2, #8
 8002992:	631a      	str	r2, [r3, #48]	; 0x30
 8002994:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002996:	f003 0308 	and.w	r3, r3, #8
 800299a:	9302      	str	r3, [sp, #8]
 800299c:	9b02      	ldr	r3, [sp, #8]
 800299e:	e018      	b.n	80029d2 <BSP_LED_Init+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54 (discriminator 4)
 80029a0:	2802      	cmp	r0, #2
 80029a2:	d10a      	bne.n	80029ba <BSP_LED_Init+0x52>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54 (discriminator 5)
 80029a4:	4b16      	ldr	r3, [pc, #88]	; (8002a00 <BSP_LED_Init+0x98>)
 80029a6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80029a8:	f042 0208 	orr.w	r2, r2, #8
 80029ac:	631a      	str	r2, [r3, #48]	; 0x30
 80029ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80029b0:	f003 0308 	and.w	r3, r3, #8
 80029b4:	9303      	str	r3, [sp, #12]
 80029b6:	9b03      	ldr	r3, [sp, #12]
 80029b8:	e00b      	b.n	80029d2 <BSP_LED_Init+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54 (discriminator 6)
 80029ba:	2803      	cmp	r0, #3
 80029bc:	d109      	bne.n	80029d2 <BSP_LED_Init+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:54 (discriminator 7)
 80029be:	4b10      	ldr	r3, [pc, #64]	; (8002a00 <BSP_LED_Init+0x98>)
 80029c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80029c2:	f042 0208 	orr.w	r2, r2, #8
 80029c6:	631a      	str	r2, [r3, #48]	; 0x30
 80029c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80029ca:	f003 0308 	and.w	r3, r3, #8
 80029ce:	9304      	str	r3, [sp, #16]
 80029d0:	9b04      	ldr	r3, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:57

	/* Configure the GPIO_LED pin */
	GPIO_InitStruct.Pin = GPIO_PIN[Led];
 80029d2:	4b0c      	ldr	r3, [pc, #48]	; (8002a04 <BSP_LED_Init+0x9c>)
 80029d4:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 80029d8:	9605      	str	r6, [sp, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:58
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80029da:	2301      	movs	r3, #1
 80029dc:	9306      	str	r3, [sp, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:59
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 80029de:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:60
	GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 80029e0:	2302      	movs	r3, #2
 80029e2:	9308      	str	r3, [sp, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:62

	HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 80029e4:	4d08      	ldr	r5, [pc, #32]	; (8002a08 <BSP_LED_Init+0xa0>)
 80029e6:	a905      	add	r1, sp, #20
 80029e8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 80029ec:	f7fe fa28 	bl	8000e40 <HAL_GPIO_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:64

	HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 80029f0:	2200      	movs	r2, #0
 80029f2:	4631      	mov	r1, r6
 80029f4:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 80029f8:	f7fe fbb8 	bl	800116c <HAL_GPIO_WritePin>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:65
}
 80029fc:	b00a      	add	sp, #40	; 0x28
 80029fe:	bd70      	pop	{r4, r5, r6, pc}
 8002a00:	40023800 	.word	0x40023800
 8002a04:	08006814 	.word	0x08006814
 8002a08:	20000010 	.word	0x20000010

08002a0c <BSP_LED_Toggle>:
BSP_LED_Toggle():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:77
 *     @arg LED3
 *     @arg LED5
 *     @arg LED6
 * @retval None
 */
void BSP_LED_Toggle(Led_TypeDef Led) {
 8002a0c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:78
	HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 8002a0e:	4b04      	ldr	r3, [pc, #16]	; (8002a20 <BSP_LED_Toggle+0x14>)
 8002a10:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8002a14:	4b03      	ldr	r3, [pc, #12]	; (8002a24 <BSP_LED_Toggle+0x18>)
 8002a16:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8002a1a:	f7fe fbc1 	bl	80011a0 <HAL_GPIO_TogglePin>
 8002a1e:	bd08      	pop	{r3, pc}
 8002a20:	08006814 	.word	0x08006814
 8002a24:	20000010 	.word	0x20000010

08002a28 <BSP_LED_On>:
BSP_LED_On():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:91
 *     @arg LED3
 *     @arg LED5
 *     @arg LED6
 * @retval None
 */
void BSP_LED_On(Led_TypeDef Led) {
 8002a28:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:92
	HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET);
 8002a2a:	2201      	movs	r2, #1
 8002a2c:	4b04      	ldr	r3, [pc, #16]	; (8002a40 <BSP_LED_On+0x18>)
 8002a2e:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8002a32:	4b04      	ldr	r3, [pc, #16]	; (8002a44 <BSP_LED_On+0x1c>)
 8002a34:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8002a38:	f7fe fb98 	bl	800116c <HAL_GPIO_WritePin>
 8002a3c:	bd08      	pop	{r3, pc}
 8002a3e:	bf00      	nop
 8002a40:	08006814 	.word	0x08006814
 8002a44:	20000010 	.word	0x20000010

08002a48 <BSP_LED_Off>:
BSP_LED_Off():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:105
 *     @arg LED3
 *     @arg LED5
 *     @arg LED6
 * @retval None
 */
void BSP_LED_Off(Led_TypeDef Led) {
 8002a48:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:106
	HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 8002a4a:	2200      	movs	r2, #0
 8002a4c:	4b04      	ldr	r3, [pc, #16]	; (8002a60 <BSP_LED_Off+0x18>)
 8002a4e:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8002a52:	4b04      	ldr	r3, [pc, #16]	; (8002a64 <BSP_LED_Off+0x1c>)
 8002a54:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8002a58:	f7fe fb88 	bl	800116c <HAL_GPIO_WritePin>
 8002a5c:	bd08      	pop	{r3, pc}
 8002a5e:	bf00      	nop
 8002a60:	08006814 	.word	0x08006814
 8002a64:	20000010 	.word	0x20000010

08002a68 <BSP_PB_Init>:
BSP_PB_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:120
 *     @arg BUTTON_MODE_GPIO: Button will be used as simple IO
 *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
 *                            generation capability
 * @retval None
 */
void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef Mode) {
 8002a68:	b530      	push	{r4, r5, lr}
 8002a6a:	b087      	sub	sp, #28
 8002a6c:	460c      	mov	r4, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:124
	GPIO_InitTypeDef GPIO_InitStruct;

	/* Enable the BUTTON Clock */
	BUTTONx_GPIO_CLK_ENABLE(Button);
 8002a6e:	4605      	mov	r5, r0
 8002a70:	b948      	cbnz	r0, 8002a86 <BSP_PB_Init+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:124 (discriminator 1)
 8002a72:	4b19      	ldr	r3, [pc, #100]	; (8002ad8 <BSP_PB_Init+0x70>)
 8002a74:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002a76:	f042 0201 	orr.w	r2, r2, #1
 8002a7a:	631a      	str	r2, [r3, #48]	; 0x30
 8002a7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002a7e:	f003 0301 	and.w	r3, r3, #1
 8002a82:	9300      	str	r3, [sp, #0]
 8002a84:	9b00      	ldr	r3, [sp, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:126

	if (Mode == BUTTON_MODE_GPIO) {
 8002a86:	b964      	cbnz	r4, 8002aa2 <BSP_PB_Init+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:128
		/* Configure Button pin as input */
		GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 8002a88:	2301      	movs	r3, #1
 8002a8a:	9301      	str	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:129
		GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8002a8c:	2300      	movs	r3, #0
 8002a8e:	9302      	str	r3, [sp, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:130
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002a90:	9303      	str	r3, [sp, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:131
		GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 8002a92:	2302      	movs	r3, #2
 8002a94:	9304      	str	r3, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:133

		HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 8002a96:	a901      	add	r1, sp, #4
 8002a98:	4b10      	ldr	r3, [pc, #64]	; (8002adc <BSP_PB_Init+0x74>)
 8002a9a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8002a9e:	f7fe f9cf 	bl	8000e40 <HAL_GPIO_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:136
	}

	if (Mode == BUTTON_MODE_EXTI) {
 8002aa2:	2c01      	cmp	r4, #1
 8002aa4:	d115      	bne.n	8002ad2 <BSP_PB_Init+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:138
		/* Configure Button pin as input with External interrupt */
		GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 8002aa6:	2301      	movs	r3, #1
 8002aa8:	9301      	str	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:139
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002aaa:	2400      	movs	r4, #0
 8002aac:	9403      	str	r4, [sp, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:140
		GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 8002aae:	2302      	movs	r3, #2
 8002ab0:	9304      	str	r3, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:141
		GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8002ab2:	4b0b      	ldr	r3, [pc, #44]	; (8002ae0 <BSP_PB_Init+0x78>)
 8002ab4:	9302      	str	r3, [sp, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:142
		HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 8002ab6:	a901      	add	r1, sp, #4
 8002ab8:	4b08      	ldr	r3, [pc, #32]	; (8002adc <BSP_PB_Init+0x74>)
 8002aba:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8002abe:	f7fe f9bf 	bl	8000e40 <HAL_GPIO_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:145

		/* Enable and set Button EXTI Interrupt to the lowest priority */
		HAL_NVIC_SetPriority((IRQn_Type) (BUTTON_IRQn[Button]), 14, 0);
 8002ac2:	4622      	mov	r2, r4
 8002ac4:	210e      	movs	r1, #14
 8002ac6:	2006      	movs	r0, #6
 8002ac8:	f7fe f8fc 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:146
		HAL_NVIC_EnableIRQ((IRQn_Type) (BUTTON_IRQn[Button]));
 8002acc:	2006      	movs	r0, #6
 8002ace:	f7fe f93b 	bl	8000d48 <HAL_NVIC_EnableIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:148
	}
}
 8002ad2:	b007      	add	sp, #28
 8002ad4:	bd30      	pop	{r4, r5, pc}
 8002ad6:	bf00      	nop
 8002ad8:	40023800 	.word	0x40023800
 8002adc:	20000020 	.word	0x20000020
 8002ae0:	10110000 	.word	0x10110000

08002ae4 <set_button_state>:
set_button_state():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:188
 * @param  None
 * @retval None
 */
void set_button_state(void) {

	button = STD_ON;
 8002ae4:	2201      	movs	r2, #1
 8002ae6:	4b01      	ldr	r3, [pc, #4]	; (8002aec <set_button_state+0x8>)
 8002ae8:	701a      	strb	r2, [r3, #0]
 8002aea:	4770      	bx	lr
 8002aec:	20001a28 	.word	0x20001a28

08002af0 <reset_button_state>:
reset_button_state():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:201
 * @param  None
 * @retval None
 */
void reset_button_state(void) {

	button = STD_OFF;
 8002af0:	2200      	movs	r2, #0
 8002af2:	4b01      	ldr	r3, [pc, #4]	; (8002af8 <reset_button_state+0x8>)
 8002af4:	701a      	strb	r2, [r3, #0]
 8002af6:	4770      	bx	lr
 8002af8:	20001a28 	.word	0x20001a28

08002afc <get_button_state>:
get_button_state():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:212
 * @param  None
 * @retval None
 */
uint8_t get_button_state() {

	return button;
 8002afc:	4b01      	ldr	r3, [pc, #4]	; (8002b04 <get_button_state+0x8>)
 8002afe:	7818      	ldrb	r0, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:214

}
 8002b00:	4770      	bx	lr
 8002b02:	bf00      	nop
 8002b04:	20001a28 	.word	0x20001a28

08002b08 <HAL_GPIO_EXTI_Callback>:
HAL_GPIO_EXTI_Callback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:157
 * @param  GPIO_Pin: Specifies the pins connected EXTI line
 * @retval None
 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {

	if (GPIO_Pin == KEY_BUTTON_PIN) {
 8002b08:	2801      	cmp	r0, #1
 8002b0a:	d110      	bne.n	8002b2e <HAL_GPIO_EXTI_Callback+0x26>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:155
/**
 * @brief  EXTI line detection callbacks.
 * @param  GPIO_Pin: Specifies the pins connected EXTI line
 * @retval None
 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
 8002b0c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:160

	if (GPIO_Pin == KEY_BUTTON_PIN) {

		// Wurde Knopf zur Datenspeicherung gedrueckt?
		if (get_button_state() == STD_OFF) {
 8002b0e:	f7ff fff5 	bl	8002afc <get_button_state>
 8002b12:	b910      	cbnz	r0, 8002b1a <HAL_GPIO_EXTI_Callback+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:162
			// Dann setze ensprechendes Signalisierungsbit
			set_button_state();
 8002b14:	f7ff ffe6 	bl	8002ae4 <set_button_state>
 8002b18:	e001      	b.n	8002b1e <HAL_GPIO_EXTI_Callback+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:165
		} else {
			// Sonst, signalisiere, dass Knopf erneut gedrueckt wurde, um Messung zu stoppen
			reset_button_state();
 8002b1a:	f7ff ffe9 	bl	8002af0 <reset_button_state>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:170

		}

		// Startet Timer, welcher 2 Sekunde lang laeuft
		PtCan_Tim_SetState(INST_TIM3, STD_ON);
 8002b1e:	2101      	movs	r1, #1
 8002b20:	4608      	mov	r0, r1
 8002b22:	f7ff fec7 	bl	80028b4 <PtCan_Tim_SetState>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/led_button.c:173

		// Deaktivierung des Interrupts fuer den Button 2 Sekunde lang
		HAL_NVIC_DisableIRQ(KEY_BUTTON_EXTI_IRQn);
 8002b26:	2006      	movs	r0, #6
 8002b28:	f7fe f924 	bl	8000d74 <HAL_NVIC_DisableIRQ>
 8002b2c:	bd08      	pop	{r3, pc}
 8002b2e:	4770      	bx	lr

08002b30 <SystemClock_Config>:
SystemClock_Config():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:109
/**
 * @brief  System Clock Configuration.
 * @param  None
 * @retval None
 */
void SystemClock_Config(void) {
 8002b30:	b510      	push	{r4, lr}
 8002b32:	b094      	sub	sp, #80	; 0x50
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:114

	RCC_OscInitTypeDef RCC_OscInitStruct;
	RCC_ClkInitTypeDef RCC_ClkInitStruct;

	__PWR_CLK_ENABLE()
 8002b34:	4b24      	ldr	r3, [pc, #144]	; (8002bc8 <SystemClock_Config+0x98>)
 8002b36:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002b38:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002b3c:	641a      	str	r2, [r3, #64]	; 0x40
 8002b3e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002b40:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002b44:	9301      	str	r3, [sp, #4]
 8002b46:	9b01      	ldr	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:117
	;

	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002b48:	4b20      	ldr	r3, [pc, #128]	; (8002bcc <SystemClock_Config+0x9c>)
 8002b4a:	681a      	ldr	r2, [r3, #0]
 8002b4c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002b50:	601a      	str	r2, [r3, #0]
 8002b52:	681b      	ldr	r3, [r3, #0]
 8002b54:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002b58:	9302      	str	r3, [sp, #8]
 8002b5a:	9b02      	ldr	r3, [sp, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:119

	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8002b5c:	2301      	movs	r3, #1
 8002b5e:	9308      	str	r3, [sp, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:120
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8002b60:	9309      	str	r3, [sp, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:121
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002b62:	2402      	movs	r4, #2
 8002b64:	940e      	str	r4, [sp, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:122
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8002b66:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8002b6a:	930f      	str	r3, [sp, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:123
	RCC_OscInitStruct.PLL.PLLM = 8;
 8002b6c:	2308      	movs	r3, #8
 8002b6e:	9310      	str	r3, [sp, #64]	; 0x40
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:124
	RCC_OscInitStruct.PLL.PLLN = 336;
 8002b70:	f44f 73a8 	mov.w	r3, #336	; 0x150
 8002b74:	9311      	str	r3, [sp, #68]	; 0x44
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:125
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8002b76:	9412      	str	r4, [sp, #72]	; 0x48
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:126
	RCC_OscInitStruct.PLL.PLLQ = 7;
 8002b78:	2307      	movs	r3, #7
 8002b7a:	9313      	str	r3, [sp, #76]	; 0x4c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:127
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8002b7c:	a808      	add	r0, sp, #32
 8002b7e:	f7fe fb2b 	bl	80011d8 <HAL_RCC_OscConfig>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:129

	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1
 8002b82:	230d      	movs	r3, #13
 8002b84:	9303      	str	r3, [sp, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:131
			| RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002b86:	9404      	str	r4, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:132
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002b88:	2400      	movs	r4, #0
 8002b8a:	9405      	str	r4, [sp, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:133
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8002b8c:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8002b90:	9306      	str	r3, [sp, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:134
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8002b92:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8002b96:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:135
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 8002b98:	2105      	movs	r1, #5
 8002b9a:	a803      	add	r0, sp, #12
 8002b9c:	f7fe fd70 	bl	8001680 <HAL_RCC_ClockConfig>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:137

	HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
 8002ba0:	f7fe ff72 	bl	8001a88 <HAL_RCC_GetHCLKFreq>
 8002ba4:	4b0a      	ldr	r3, [pc, #40]	; (8002bd0 <SystemClock_Config+0xa0>)
 8002ba6:	fba3 3000 	umull	r3, r0, r3, r0
 8002baa:	0980      	lsrs	r0, r0, #6
 8002bac:	f7fe f8f8 	bl	8000da0 <HAL_SYSTICK_Config>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:139

	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8002bb0:	2004      	movs	r0, #4
 8002bb2:	f7fe f923 	bl	8000dfc <HAL_SYSTICK_CLKSourceConfig>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:142

	/* SysTick_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002bb6:	4622      	mov	r2, r4
 8002bb8:	4621      	mov	r1, r4
 8002bba:	f04f 30ff 	mov.w	r0, #4294967295
 8002bbe:	f7fe f881 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:143
}
 8002bc2:	b014      	add	sp, #80	; 0x50
 8002bc4:	bd10      	pop	{r4, pc}
 8002bc6:	bf00      	nop
 8002bc8:	40023800 	.word	0x40023800
 8002bcc:	40007000 	.word	0x40007000
 8002bd0:	10624dd3 	.word	0x10624dd3

08002bd4 <main_StartStorage>:
main_StartStorage():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:208
/**
 * @brief  Routine for initialization of CAN-Communication and SPI-Communication with SD-Card.
 * @param  None
 * @retval None
 */
void main_StartStorage() {
 8002bd4:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:214


//	if ( PtCan_SdStorage_SDMount(STD_ON) != E_OK) {
//		Error_Handler_fats();
//	}
	PtCan_SdStorage_SDMount(STD_ON);
 8002bd6:	2001      	movs	r0, #1
 8002bd8:	f7ff fe20 	bl	800281c <PtCan_SdStorage_SDMount>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:216

	BSP_LED_On(LED5);
 8002bdc:	2002      	movs	r0, #2
 8002bde:	f7ff ff23 	bl	8002a28 <BSP_LED_On>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:223
	// Diese LED gibt an, dass CAN2 nicht dabei ist
	BSP_LED_On(LED4);
#endif

	// Setze Initialisierungsbit der Speicherung
	PtCan_SdStorage_setStorageState(STD_ON);
 8002be2:	2001      	movs	r0, #1
 8002be4:	f7ff fe3a 	bl	800285c <PtCan_SdStorage_setStorageState>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:225

	if (program_start == STD_OFF) {
 8002be8:	4b08      	ldr	r3, [pc, #32]	; (8002c0c <main_StartStorage+0x38>)
 8002bea:	781b      	ldrb	r3, [r3, #0]
 8002bec:	f013 0fff 	tst.w	r3, #255	; 0xff
 8002bf0:	d102      	bne.n	8002bf8 <main_StartStorage+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:227

		PtCan_Can1ActivReceiveIT();
 8002bf2:	f7ff fc15 	bl	8002420 <PtCan_Can1ActivReceiveIT>
 8002bf6:	e001      	b.n	8002bfc <main_StartStorage+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:230
	} else {
		// Sonst erwecke den CAN-Controller
		PtCan_Can1WU();
 8002bf8:	f7ff fc28 	bl	800244c <PtCan_Can1WU>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:233
	}

	PtCan_Tim_SetState(INST_TIM2, STD_ON);
 8002bfc:	2101      	movs	r1, #1
 8002bfe:	2000      	movs	r0, #0
 8002c00:	f7ff fe58 	bl	80028b4 <PtCan_Tim_SetState>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:238

	// Setze Initialisierungsbit ab Start der Speicherung.
	// Gibt an, dass Button das erste Mal zum Abspeichern gedruckt wurde.
	// Sein Wert wird nie mehr geaendert
	program_start = STD_ON;
 8002c04:	2201      	movs	r2, #1
 8002c06:	4b01      	ldr	r3, [pc, #4]	; (8002c0c <main_StartStorage+0x38>)
 8002c08:	701a      	strb	r2, [r3, #0]
 8002c0a:	bd08      	pop	{r3, pc}
 8002c0c:	20001a29 	.word	0x20001a29

08002c10 <main_StopStorage>:
main_StopStorage():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:246
/**
 * @brief  Routine for stopping CAN-Communication and SPI-Communication with SD-Card.
 * @param  None
 * @retval None
 */
void main_StopStorage() {
 8002c10:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:253
	/* Unmount SDCARD */
//	if( PtCan_SdStorage_SDMount(STD_OFF) != E_OK) {
//		Error_Handler_fats();
//	}

	PtCan_SdStorage_SDMount(STD_OFF);
 8002c12:	2000      	movs	r0, #0
 8002c14:	f7ff fe02 	bl	800281c <PtCan_SdStorage_SDMount>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:255

	PtCan_Can1Sleep();
 8002c18:	f7ff fc0e 	bl	8002438 <PtCan_Can1Sleep>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:257

	PtCan_Tim_SetState(INST_TIM2, STD_OFF);
 8002c1c:	2100      	movs	r1, #0
 8002c1e:	4608      	mov	r0, r1
 8002c20:	f7ff fe48 	bl	80028b4 <PtCan_Tim_SetState>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:259

	BSP_LED_Off(LED5);
 8002c24:	2002      	movs	r0, #2
 8002c26:	f7ff ff0f 	bl	8002a48 <BSP_LED_Off>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:266
	// Diese LED gibt an, dass CAN2 nicht dabei ist
	BSP_LED_Off(LED4);
#endif

	// Die CAN-Uebertragung kann wieder neu gestartet werden, nachdem dieses Bit zurueckgesetzt wurde
	PtCan_SdStorage_setStorageState(STD_OFF);
 8002c2a:	2000      	movs	r0, #0
 8002c2c:	f7ff fe16 	bl	800285c <PtCan_SdStorage_setStorageState>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:268
	// Reset Timer
	PtCan_Tim_ResetCounter();
 8002c30:	f7ff fe94 	bl	800295c <PtCan_Tim_ResetCounter>
 8002c34:	bd08      	pop	{r3, pc}
 8002c36:	bf00      	nop

08002c38 <MX_GPIO_Init>:
MX_GPIO_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:151
/**
 * @brief  Pinout Configuration.
 * @param  None
 * @retval None
 */
void MX_GPIO_Init(void) {
 8002c38:	b082      	sub	sp, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:154

	/* GPIO Ports Clock Enable */
	__GPIOD_CLK_ENABLE()
 8002c3a:	4b0a      	ldr	r3, [pc, #40]	; (8002c64 <MX_GPIO_Init+0x2c>)
 8002c3c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002c3e:	f042 0208 	orr.w	r2, r2, #8
 8002c42:	631a      	str	r2, [r3, #48]	; 0x30
 8002c44:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002c46:	f002 0208 	and.w	r2, r2, #8
 8002c4a:	9200      	str	r2, [sp, #0]
 8002c4c:	9a00      	ldr	r2, [sp, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:156
	;
	__GPIOB_CLK_ENABLE()
 8002c4e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002c50:	f042 0202 	orr.w	r2, r2, #2
 8002c54:	631a      	str	r2, [r3, #48]	; 0x30
 8002c56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002c58:	f003 0302 	and.w	r3, r3, #2
 8002c5c:	9301      	str	r3, [sp, #4]
 8002c5e:	9b01      	ldr	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:159
	;

}
 8002c60:	b002      	add	sp, #8
 8002c62:	4770      	bx	lr
 8002c64:	40023800 	.word	0x40023800

08002c68 <main_InitMcu>:
main_InitMcu():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:166
/**
 * @brief  Initialization routine for all peripheral interfaces and internal HAL-Functions.
 * @param  None
 * @retval None
 */
void main_InitMcu() {
 8002c68:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:171

	/* MCU Configuration----------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
 8002c6a:	f7fd fb8d 	bl	8000388 <HAL_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:173

	SystemClock_Config();
 8002c6e:	f7ff ff5f 	bl	8002b30 <SystemClock_Config>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:176

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
 8002c72:	f7ff ffe1 	bl	8002c38 <MX_GPIO_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:178

	PtCan_initMemory();
 8002c76:	f7ff fd91 	bl	800279c <PtCan_initMemory>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:181

	/* Configure LED1, LED2, LED3 and LED4 */
	BSP_LED_Init(LED4);
 8002c7a:	2000      	movs	r0, #0
 8002c7c:	f7ff fe74 	bl	8002968 <BSP_LED_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:182
	BSP_LED_Init(LED3);
 8002c80:	2001      	movs	r0, #1
 8002c82:	f7ff fe71 	bl	8002968 <BSP_LED_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:183
	BSP_LED_Init(LED5);
 8002c86:	2002      	movs	r0, #2
 8002c88:	f7ff fe6e 	bl	8002968 <BSP_LED_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:184
	BSP_LED_Init(LED6);
 8002c8c:	2003      	movs	r0, #3
 8002c8e:	f7ff fe6b 	bl	8002968 <BSP_LED_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:188

	/*##-1- Configure the CAN peripheral #######################################*/
	// CAN Controller-Empfaenger
	MX_CAN1_Init();
 8002c92:	f7ff fb03 	bl	800229c <MX_CAN1_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:193
#if defined (CAN2_EIN)
		// CAN Controller-Sender
		MX_CAN2_Init();
#endif
	MX_TIM2_Init();
 8002c96:	f7ff fde7 	bl	8002868 <MX_TIM2_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:194
	MX_TIM3_Init();
 8002c9a:	f7ff fdf7 	bl	800288c <MX_TIM3_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:197

	/* Configure Key Button */
	BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
 8002c9e:	2101      	movs	r1, #1
 8002ca0:	2000      	movs	r0, #0
 8002ca2:	f7ff fee1 	bl	8002a68 <BSP_PB_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:199

	reset_button_state();
 8002ca6:	f7ff ff23 	bl	8002af0 <reset_button_state>
 8002caa:	bd08      	pop	{r3, pc}

08002cac <main>:
main():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:74


/**********************************************************************************************************************
 *  LOCAL FUNCTIONS
 **********************************************************************************************************************/
int main(void) {
 8002cac:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:76

	main_InitMcu();
 8002cae:	f7ff ffdb 	bl	8002c68 <main_InitMcu>
 8002cb2:	e006      	b.n	8002cc2 <main+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:84

		// Warte bis Knopf gedruckt wird
		while (get_button_state() == STD_ON) {

			// Wurde die Datenuebertragung richtig eingestellt und Messung noch nicht gestartet?
			if (PtCan_SdStorage_getStorageState() == STD_OFF) {
 8002cb4:	f7ff fdcc 	bl	8002850 <PtCan_SdStorage_getStorageState>
 8002cb8:	b908      	cbnz	r0, 8002cbe <main+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:86
				// Starte Speicherung
				main_StartStorage();
 8002cba:	f7ff ff8b 	bl	8002bd4 <main_StartStorage>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:92
			}
#if defined (CAN2_EIN)
			PtCan_Can2_Transmit();
#endif
			// Sende Rohdaten an SD-Karte, wenn Buffer voll sind
			PtCan_SdStorage_storeSD();
 8002cbe:	f7ff fc57 	bl	8002570 <PtCan_SdStorage_storeSD>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:81
	main_InitMcu();

	while (1) {

		// Warte bis Knopf gedruckt wird
		while (get_button_state() == STD_ON) {
 8002cc2:	f7ff ff1b 	bl	8002afc <get_button_state>
 8002cc6:	2801      	cmp	r0, #1
 8002cc8:	d0f4      	beq.n	8002cb4 <main+0x8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:96
			// Sende Rohdaten an SD-Karte, wenn Buffer voll sind
			PtCan_SdStorage_storeSD();
		}

		// wurde Knopf erneut gedruckt und Datenspeicherung laeuft?
		if (PtCan_SdStorage_getStorageState() != STD_OFF && get_button_state() == STD_OFF) {
 8002cca:	f7ff fdc1 	bl	8002850 <PtCan_SdStorage_getStorageState>
 8002cce:	2800      	cmp	r0, #0
 8002cd0:	d0f7      	beq.n	8002cc2 <main+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:96 (discriminator 1)
 8002cd2:	f7ff ff13 	bl	8002afc <get_button_state>
 8002cd6:	2800      	cmp	r0, #0
 8002cd8:	d1f3      	bne.n	8002cc2 <main+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/main.c:98
			//Stope Speicherung
			main_StopStorage();
 8002cda:	f7ff ff99 	bl	8002c10 <main_StopStorage>
 8002cde:	e7f0      	b.n	8002cc2 <main+0x16>

08002ce0 <HAL_MspInit>:
HAL_MspInit():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:44
/* USER CODE END 0 */

/**
 * Initializes the Global MSP.
 */
void HAL_MspInit(void) {
 8002ce0:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:49
	/* USER CODE BEGIN MspInit 0 */

	/* USER CODE END MspInit 0 */

	HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002ce2:	2003      	movs	r0, #3
 8002ce4:	f7fd ffd0 	bl	8000c88 <HAL_NVIC_SetPriorityGrouping>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:53

	/* System interrupt init*/
	/* SysTick_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002ce8:	2200      	movs	r2, #0
 8002cea:	4611      	mov	r1, r2
 8002cec:	f04f 30ff 	mov.w	r0, #4294967295
 8002cf0:	f7fd ffe8 	bl	8000cc4 <HAL_NVIC_SetPriority>
 8002cf4:	bd08      	pop	{r3, pc}
 8002cf6:	bf00      	nop

08002cf8 <HAL_CAN_MspInit>:
HAL_CAN_MspInit():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:63
}

static int CAN1_CLK_ENABLED = 0;
static int CAN2_CLK_ENABLED = 0;

void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan) {
 8002cf8:	b510      	push	{r4, lr}
 8002cfa:	b088      	sub	sp, #32
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:66

	GPIO_InitTypeDef GPIO_InitStruct;
	if (hcan->Instance == CAN1) {
 8002cfc:	6803      	ldr	r3, [r0, #0]
 8002cfe:	4a37      	ldr	r2, [pc, #220]	; (8002ddc <HAL_CAN_MspInit+0xe4>)
 8002d00:	4293      	cmp	r3, r2
 8002d02:	d12d      	bne.n	8002d60 <HAL_CAN_MspInit+0x68>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:71
		/* USER CODE BEGIN CAN1_MspInit 0 */

		/* USER CODE END CAN1_MspInit 0 */
		/* Peripheral clock enable */
		CAN1_CLK_ENABLED++;
 8002d04:	4a36      	ldr	r2, [pc, #216]	; (8002de0 <HAL_CAN_MspInit+0xe8>)
 8002d06:	6813      	ldr	r3, [r2, #0]
 8002d08:	3301      	adds	r3, #1
 8002d0a:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:72
		if (CAN1_CLK_ENABLED == 1) {
 8002d0c:	2b01      	cmp	r3, #1
 8002d0e:	d109      	bne.n	8002d24 <HAL_CAN_MspInit+0x2c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:73
			__CAN1_CLK_ENABLE()
 8002d10:	4b34      	ldr	r3, [pc, #208]	; (8002de4 <HAL_CAN_MspInit+0xec>)
 8002d12:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002d14:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8002d18:	641a      	str	r2, [r3, #64]	; 0x40
 8002d1a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002d1c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002d20:	9300      	str	r3, [sp, #0]
 8002d22:	9b00      	ldr	r3, [sp, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:81

		/**CAN1 GPIO Configuration
		 PD0     ------> CAN1_RX
		 PD1     ------> CAN1_TX
		 */
		GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;
 8002d24:	2303      	movs	r3, #3
 8002d26:	9303      	str	r3, [sp, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:82
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002d28:	2202      	movs	r2, #2
 8002d2a:	9204      	str	r2, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:83
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002d2c:	2400      	movs	r4, #0
 8002d2e:	9405      	str	r4, [sp, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:84
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8002d30:	9306      	str	r3, [sp, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:85
		GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 8002d32:	2309      	movs	r3, #9
 8002d34:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:86
		HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002d36:	a903      	add	r1, sp, #12
 8002d38:	482b      	ldr	r0, [pc, #172]	; (8002de8 <HAL_CAN_MspInit+0xf0>)
 8002d3a:	f7fe f881 	bl	8000e40 <HAL_GPIO_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:89

		/* Peripheral interrupt init*/
		HAL_NVIC_SetPriority(CAN1_TX_IRQn, 6, 0);
 8002d3e:	4622      	mov	r2, r4
 8002d40:	2106      	movs	r1, #6
 8002d42:	2013      	movs	r0, #19
 8002d44:	f7fd ffbe 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:90
		HAL_NVIC_EnableIRQ(CAN1_TX_IRQn);
 8002d48:	2013      	movs	r0, #19
 8002d4a:	f7fd fffd 	bl	8000d48 <HAL_NVIC_EnableIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:92
//    HAL_NVIC_SetPriority(CAN1_RX0_IRQn, 1, 0);
		HAL_NVIC_SetPriority(CAN1_RX0_IRQn, 6, 0);
 8002d4e:	4622      	mov	r2, r4
 8002d50:	2106      	movs	r1, #6
 8002d52:	2014      	movs	r0, #20
 8002d54:	f7fd ffb6 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:93
		HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);
 8002d58:	2014      	movs	r0, #20
 8002d5a:	f7fd fff5 	bl	8000d48 <HAL_NVIC_EnableIRQ>
 8002d5e:	e03a      	b.n	8002dd6 <HAL_CAN_MspInit+0xde>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:97
		/* USER CODE BEGIN CAN1_MspInit 1 */

		/* USER CODE END CAN1_MspInit 1 */
	} else if (hcan->Instance == CAN2) {
 8002d60:	4a22      	ldr	r2, [pc, #136]	; (8002dec <HAL_CAN_MspInit+0xf4>)
 8002d62:	4293      	cmp	r3, r2
 8002d64:	d137      	bne.n	8002dd6 <HAL_CAN_MspInit+0xde>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:102
		/* USER CODE BEGIN CAN2_MspInit 0 */

		/* USER CODE END CAN2_MspInit 0 */
		/* Peripheral clock enable */
		__CAN2_CLK_ENABLE()
 8002d66:	4b1f      	ldr	r3, [pc, #124]	; (8002de4 <HAL_CAN_MspInit+0xec>)
 8002d68:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002d6a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8002d6e:	641a      	str	r2, [r3, #64]	; 0x40
 8002d70:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002d72:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8002d76:	9301      	str	r3, [sp, #4]
 8002d78:	9b01      	ldr	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:104
		;
		CAN2_CLK_ENABLED++;
 8002d7a:	4a1d      	ldr	r2, [pc, #116]	; (8002df0 <HAL_CAN_MspInit+0xf8>)
 8002d7c:	6813      	ldr	r3, [r2, #0]
 8002d7e:	3301      	adds	r3, #1
 8002d80:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:105
		if (CAN2_CLK_ENABLED == 1) {
 8002d82:	2b01      	cmp	r3, #1
 8002d84:	d109      	bne.n	8002d9a <HAL_CAN_MspInit+0xa2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:106
			__CAN2_CLK_ENABLE()
 8002d86:	4b17      	ldr	r3, [pc, #92]	; (8002de4 <HAL_CAN_MspInit+0xec>)
 8002d88:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002d8a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8002d8e:	641a      	str	r2, [r3, #64]	; 0x40
 8002d90:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002d92:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8002d96:	9302      	str	r3, [sp, #8]
 8002d98:	9b02      	ldr	r3, [sp, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:114

		/**CAN2 GPIO Configuration
		 PB5     ------> CAN2_RX
		 PB6     ------> CAN2_TX
		 */
		GPIO_InitStruct.Pin = GPIO_PIN_5 | GPIO_PIN_6;
 8002d9a:	2360      	movs	r3, #96	; 0x60
 8002d9c:	9303      	str	r3, [sp, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:115
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002d9e:	2302      	movs	r3, #2
 8002da0:	9304      	str	r3, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:116
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002da2:	2400      	movs	r4, #0
 8002da4:	9405      	str	r4, [sp, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:117
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8002da6:	2303      	movs	r3, #3
 8002da8:	9306      	str	r3, [sp, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:118
		GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
 8002daa:	2309      	movs	r3, #9
 8002dac:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:119
		HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002dae:	a903      	add	r1, sp, #12
 8002db0:	4810      	ldr	r0, [pc, #64]	; (8002df4 <HAL_CAN_MspInit+0xfc>)
 8002db2:	f7fe f845 	bl	8000e40 <HAL_GPIO_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:122

		/* Peripheral interrupt init*/
		HAL_NVIC_SetPriority(CAN2_TX_IRQn, 8, 0);
 8002db6:	4622      	mov	r2, r4
 8002db8:	2108      	movs	r1, #8
 8002dba:	203f      	movs	r0, #63	; 0x3f
 8002dbc:	f7fd ff82 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:123
		HAL_NVIC_EnableIRQ(CAN2_TX_IRQn);
 8002dc0:	203f      	movs	r0, #63	; 0x3f
 8002dc2:	f7fd ffc1 	bl	8000d48 <HAL_NVIC_EnableIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:124
		HAL_NVIC_SetPriority(CAN2_RX0_IRQn, 8, 0);
 8002dc6:	4622      	mov	r2, r4
 8002dc8:	2108      	movs	r1, #8
 8002dca:	2040      	movs	r0, #64	; 0x40
 8002dcc:	f7fd ff7a 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:125
		HAL_NVIC_EnableIRQ(CAN2_RX0_IRQn);
 8002dd0:	2040      	movs	r0, #64	; 0x40
 8002dd2:	f7fd ffb9 	bl	8000d48 <HAL_NVIC_EnableIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:131
		/* USER CODE BEGIN CAN2_MspInit 1 */

		/* USER CODE END CAN2_MspInit 1 */
	}

}
 8002dd6:	b008      	add	sp, #32
 8002dd8:	bd10      	pop	{r4, pc}
 8002dda:	bf00      	nop
 8002ddc:	40006400 	.word	0x40006400
 8002de0:	20001a30 	.word	0x20001a30
 8002de4:	40023800 	.word	0x40023800
 8002de8:	40020c00 	.word	0x40020c00
 8002dec:	40006800 	.word	0x40006800
 8002df0:	20001a2c 	.word	0x20001a2c
 8002df4:	40020400 	.word	0x40020400

08002df8 <HAL_TIM_Base_MspInit>:
HAL_TIM_Base_MspInit():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:188
		/* USER CODE END CAN2_MspDeInit 1 */
	}

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base) {
 8002df8:	b500      	push	{lr}
 8002dfa:	b083      	sub	sp, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:190

	if (htim_base->Instance == TIM2) {
 8002dfc:	6803      	ldr	r3, [r0, #0]
 8002dfe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002e02:	d113      	bne.n	8002e2c <HAL_TIM_Base_MspInit+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:195
		/* USER CODE BEGIN TIM2_MspInit 0 */

		/* USER CODE END TIM2_MspInit 0 */
		/* Peripheral clock enable */
		__TIM2_CLK_ENABLE()
 8002e04:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 8002e08:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002e0a:	f042 0201 	orr.w	r2, r2, #1
 8002e0e:	641a      	str	r2, [r3, #64]	; 0x40
 8002e10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002e12:	f003 0301 	and.w	r3, r3, #1
 8002e16:	9300      	str	r3, [sp, #0]
 8002e18:	9b00      	ldr	r3, [sp, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:198
		;
		/* Peripheral interrupt init*/
		HAL_NVIC_SetPriority(TIM2_IRQn, 3, 0);
 8002e1a:	2200      	movs	r2, #0
 8002e1c:	2103      	movs	r1, #3
 8002e1e:	201c      	movs	r0, #28
 8002e20:	f7fd ff50 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:199
		HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8002e24:	201c      	movs	r0, #28
 8002e26:	f7fd ff8f 	bl	8000d48 <HAL_NVIC_EnableIRQ>
 8002e2a:	e014      	b.n	8002e56 <HAL_TIM_Base_MspInit+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:203
		/* USER CODE BEGIN TIM2_MspInit 1 */

		/* USER CODE END TIM2_MspInit 1 */
	} else if (htim_base->Instance == TIM3) {
 8002e2c:	4a0b      	ldr	r2, [pc, #44]	; (8002e5c <HAL_TIM_Base_MspInit+0x64>)
 8002e2e:	4293      	cmp	r3, r2
 8002e30:	d111      	bne.n	8002e56 <HAL_TIM_Base_MspInit+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:208
		/* USER CODE BEGIN TIM2_MspInit 0 */

		/* USER CODE END TIM2_MspInit 0 */
		/* Peripheral clock enable */
		__TIM3_CLK_ENABLE()
 8002e32:	4b0b      	ldr	r3, [pc, #44]	; (8002e60 <HAL_TIM_Base_MspInit+0x68>)
 8002e34:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002e36:	f042 0202 	orr.w	r2, r2, #2
 8002e3a:	641a      	str	r2, [r3, #64]	; 0x40
 8002e3c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002e3e:	f003 0302 	and.w	r3, r3, #2
 8002e42:	9301      	str	r3, [sp, #4]
 8002e44:	9b01      	ldr	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:211
		;
		/* Peripheral interrupt init*/
		HAL_NVIC_SetPriority(TIM3_IRQn, 15, 0);
 8002e46:	2200      	movs	r2, #0
 8002e48:	210f      	movs	r1, #15
 8002e4a:	201d      	movs	r0, #29
 8002e4c:	f7fd ff3a 	bl	8000cc4 <HAL_NVIC_SetPriority>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:212
		HAL_NVIC_EnableIRQ(TIM3_IRQn);
 8002e50:	201d      	movs	r0, #29
 8002e52:	f7fd ff79 	bl	8000d48 <HAL_NVIC_EnableIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_hal_msp.c:216
		/* USER CODE BEGIN TIM2_MspInit 1 */
	}

}
 8002e56:	b003      	add	sp, #12
 8002e58:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e5c:	40000400 	.word	0x40000400
 8002e60:	40023800 	.word	0x40023800

08002e64 <SysTick_Handler>:
SysTick_Handler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:55
/******************************************************************************/

/**
 * @brief This function handles System tick timer.
 */
void SysTick_Handler(void) {
 8002e64:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:59
	/* USER CODE BEGIN SysTick_IRQn 0 */

	/* USER CODE END SysTick_IRQn 0 */
	HAL_IncTick();
 8002e66:	f002 fc7d 	bl	8005764 <HAL_IncTick>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:60
	HAL_SYSTICK_IRQHandler();
 8002e6a:	f7fd ffe5 	bl	8000e38 <HAL_SYSTICK_IRQHandler>
 8002e6e:	bd08      	pop	{r3, pc}

08002e70 <CAN1_RX0_IRQHandler>:
CAN1_RX0_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:76
/******************************************************************************/

/**
 * @brief This function handles CAN1 RX0 interrupts.
 */
void CAN1_RX0_IRQHandler(void) {
 8002e70:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:80
	/* USER CODE BEGIN CAN1_RX0_IRQn 0 */

	/* USER CODE END CAN1_RX0_IRQn 0 */
	HAL_CAN_IRQHandler(&hcan1);
 8002e72:	4802      	ldr	r0, [pc, #8]	; (8002e7c <CAN1_RX0_IRQHandler+0xc>)
 8002e74:	f7fd fe42 	bl	8000afc <HAL_CAN_IRQHandler>
 8002e78:	bd08      	pop	{r3, pc}
 8002e7a:	bf00      	nop
 8002e7c:	20001b60 	.word	0x20001b60

08002e80 <CAN2_TX_IRQHandler>:
CAN2_TX_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:89
}

/**
 * @brief This function handles CAN2 TX interrupts.
 */
void CAN2_TX_IRQHandler(void) {
 8002e80:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:93
	/* USER CODE BEGIN CAN2_TX_IRQn 0 */

	/* USER CODE END CAN2_TX_IRQn 0 */
	HAL_CAN_IRQHandler(&hcan2);
 8002e82:	4802      	ldr	r0, [pc, #8]	; (8002e8c <CAN2_TX_IRQHandler+0xc>)
 8002e84:	f7fd fe3a 	bl	8000afc <HAL_CAN_IRQHandler>
 8002e88:	bd08      	pop	{r3, pc}
 8002e8a:	bf00      	nop
 8002e8c:	20001b20 	.word	0x20001b20

08002e90 <EXTI0_IRQHandler>:
EXTI0_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:104
/* USER CODE BEGIN 1 */

/**
 * @brief This function handles EXTI line0 interrupt.
 */
void EXTI0_IRQHandler(void) {
 8002e90:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:108
	/* USER CODE BEGIN EXTI0_IRQn 0 */

	/* USER CODE END EXTI0_IRQn 0 */
	HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 8002e92:	2001      	movs	r0, #1
 8002e94:	f7fe f994 	bl	80011c0 <HAL_GPIO_EXTI_IRQHandler>
 8002e98:	bd08      	pop	{r3, pc}
 8002e9a:	bf00      	nop

08002e9c <TIM2_IRQHandler>:
TIM2_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:117
}

/**
 * @brief This function handles TIM2 global interrupt.
 */
void TIM2_IRQHandler(void) {
 8002e9c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:121
	/* USER CODE BEGIN TIM2_IRQn 0 */

	/* USER CODE END TIM2_IRQn 0 */
	HAL_NVIC_ClearPendingIRQ(TIM2_IRQn);
 8002e9e:	201c      	movs	r0, #28
 8002ea0:	f7fd ff94 	bl	8000dcc <HAL_NVIC_ClearPendingIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:122
	HAL_TIM_IRQHandler(&htim2);
 8002ea4:	4801      	ldr	r0, [pc, #4]	; (8002eac <TIM2_IRQHandler+0x10>)
 8002ea6:	f7fe ff6f 	bl	8001d88 <HAL_TIM_IRQHandler>
 8002eaa:	bd08      	pop	{r3, pc}
 8002eac:	20001e50 	.word	0x20001e50

08002eb0 <TIM3_IRQHandler>:
TIM3_IRQHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:134
}

/**
 * @brief This function handles TIM3 global interrupt.
 */
void TIM3_IRQHandler(void) {
 8002eb0:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:138
	/* USER CODE BEGIN TIM2_IRQn 0 */

	/* USER CODE END TIM2_IRQn 0 */
	HAL_NVIC_ClearPendingIRQ(TIM3_IRQn);
 8002eb2:	201d      	movs	r0, #29
 8002eb4:	f7fd ff8a 	bl	8000dcc <HAL_NVIC_ClearPendingIRQ>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../src/stm32f4xx_it.c:139
	HAL_TIM_IRQHandler(&htim3);
 8002eb8:	4801      	ldr	r0, [pc, #4]	; (8002ec0 <TIM3_IRQHandler+0x10>)
 8002eba:	f7fe ff65 	bl	8001d88 <HAL_TIM_IRQHandler>
 8002ebe:	bd08      	pop	{r3, pc}
 8002ec0:	20001e14 	.word	0x20001e14

08002ec4 <TM_FATFS_USBFS_disk_initialize>:
TM_FATFS_USBFS_disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:284
}

/* Function declarations to prevent link errors if functions are not found */
__weak DSTATUS TM_FATFS_SD_SDIO_disk_initialize(void) {return RES_ERROR;}
__weak DSTATUS TM_FATFS_SD_disk_initialize(void) {return RES_ERROR;}
__weak DSTATUS TM_FATFS_USBFS_disk_initialize(void) {return RES_ERROR;}
 8002ec4:	2001      	movs	r0, #1
 8002ec6:	4770      	bx	lr

08002ec8 <TM_FATFS_USBHS_disk_initialize>:
TM_FATFS_USBHS_disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:285
__weak DSTATUS TM_FATFS_USBHS_disk_initialize(void) {return RES_ERROR;}
 8002ec8:	2001      	movs	r0, #1
 8002eca:	4770      	bx	lr

08002ecc <TM_FATFS_SDRAM_disk_initialize>:
TM_FATFS_SDRAM_disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:286
__weak DSTATUS TM_FATFS_SDRAM_disk_initialize(void) {return RES_ERROR;}
 8002ecc:	2001      	movs	r0, #1
 8002ece:	4770      	bx	lr

08002ed0 <TM_FATFS_SPI_FLASH_disk_initialize>:
TM_FATFS_SPI_FLASH_disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:287
__weak DSTATUS TM_FATFS_SPI_FLASH_disk_initialize(void) {return RES_ERROR;}
 8002ed0:	2001      	movs	r0, #1
 8002ed2:	4770      	bx	lr

08002ed4 <TM_FATFS_USBFS_disk_status>:
TM_FATFS_USBFS_disk_status():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:291

__weak DSTATUS TM_FATFS_SD_SDIO_disk_status(void) {return RES_ERROR;}
__weak DSTATUS TM_FATFS_SD_disk_status(void) {return RES_ERROR;}
__weak DSTATUS TM_FATFS_USBFS_disk_status(void) {return RES_ERROR;}
 8002ed4:	2001      	movs	r0, #1
 8002ed6:	4770      	bx	lr

08002ed8 <TM_FATFS_USBHS_disk_status>:
TM_FATFS_USBHS_disk_status():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:292
__weak DSTATUS TM_FATFS_USBHS_disk_status(void) {return RES_ERROR;}
 8002ed8:	2001      	movs	r0, #1
 8002eda:	4770      	bx	lr

08002edc <TM_FATFS_SDRAM_disk_status>:
TM_FATFS_SDRAM_disk_status():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:293
__weak DSTATUS TM_FATFS_SDRAM_disk_status(void) {return RES_ERROR;}
 8002edc:	2001      	movs	r0, #1
 8002ede:	4770      	bx	lr

08002ee0 <TM_FATFS_SPI_FLASH_disk_status>:
TM_FATFS_SPI_FLASH_disk_status():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:294
__weak DSTATUS TM_FATFS_SPI_FLASH_disk_status(void) {return RES_ERROR;}
 8002ee0:	2001      	movs	r0, #1
 8002ee2:	4770      	bx	lr

08002ee4 <TM_FATFS_USBFS_disk_ioctl>:
TM_FATFS_USBFS_disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:298

__weak DRESULT TM_FATFS_SD_SDIO_disk_ioctl(BYTE cmd, void *buff) {return (DRESULT)STA_NOINIT;}
__weak DRESULT TM_FATFS_SD_disk_ioctl(BYTE cmd, void *buff) {return (DRESULT)STA_NOINIT;}
__weak DRESULT TM_FATFS_USBFS_disk_ioctl(BYTE cmd, void *buff) {return (DRESULT)STA_NOINIT;}
 8002ee4:	2001      	movs	r0, #1
 8002ee6:	4770      	bx	lr

08002ee8 <TM_FATFS_USBHS_disk_ioctl>:
TM_FATFS_USBHS_disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:299
__weak DRESULT TM_FATFS_USBHS_disk_ioctl(BYTE cmd, void *buff) {return (DRESULT)STA_NOINIT;}
 8002ee8:	2001      	movs	r0, #1
 8002eea:	4770      	bx	lr

08002eec <TM_FATFS_SDRAM_disk_ioctl>:
TM_FATFS_SDRAM_disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:300
__weak DRESULT TM_FATFS_SDRAM_disk_ioctl(BYTE cmd, void *buff) {return (DRESULT)STA_NOINIT;}
 8002eec:	2001      	movs	r0, #1
 8002eee:	4770      	bx	lr

08002ef0 <TM_FATFS_SPI_FLASH_disk_ioctl>:
TM_FATFS_SPI_FLASH_disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:301
__weak DRESULT TM_FATFS_SPI_FLASH_disk_ioctl(BYTE cmd, void *buff) {return (DRESULT)STA_NOINIT;}
 8002ef0:	2001      	movs	r0, #1
 8002ef2:	4770      	bx	lr

08002ef4 <TM_FATFS_USBFS_disk_read>:
TM_FATFS_USBFS_disk_read():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:305

__weak DRESULT TM_FATFS_SD_SDIO_disk_read(BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
__weak DRESULT TM_FATFS_SD_disk_read(BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
__weak DRESULT TM_FATFS_USBFS_disk_read(BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002ef4:	2001      	movs	r0, #1
 8002ef6:	4770      	bx	lr

08002ef8 <TM_FATFS_USBHS_disk_read>:
TM_FATFS_USBHS_disk_read():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:306
__weak DRESULT TM_FATFS_USBHS_disk_read(BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002ef8:	2001      	movs	r0, #1
 8002efa:	4770      	bx	lr

08002efc <TM_FATFS_SDRAM_disk_read>:
TM_FATFS_SDRAM_disk_read():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:307
__weak DRESULT TM_FATFS_SDRAM_disk_read(BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002efc:	2001      	movs	r0, #1
 8002efe:	4770      	bx	lr

08002f00 <TM_FATFS_SPI_FLASH_disk_read>:
TM_FATFS_SPI_FLASH_disk_read():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:308
__weak DRESULT TM_FATFS_SPI_FLASH_disk_read(BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002f00:	2001      	movs	r0, #1
 8002f02:	4770      	bx	lr

08002f04 <TM_FATFS_USBFS_disk_write>:
TM_FATFS_USBFS_disk_write():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:312

__weak DRESULT TM_FATFS_SD_SDIO_disk_write(const BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
__weak DRESULT TM_FATFS_SD_disk_write(const BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
__weak DRESULT TM_FATFS_USBFS_disk_write(const BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002f04:	2001      	movs	r0, #1
 8002f06:	4770      	bx	lr

08002f08 <TM_FATFS_USBHS_disk_write>:
TM_FATFS_USBHS_disk_write():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:313
__weak DRESULT TM_FATFS_USBHS_disk_write(const BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002f08:	2001      	movs	r0, #1
 8002f0a:	4770      	bx	lr

08002f0c <TM_FATFS_SDRAM_disk_write>:
TM_FATFS_SDRAM_disk_write():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:314
__weak DRESULT TM_FATFS_SDRAM_disk_write(const BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002f0c:	2001      	movs	r0, #1
 8002f0e:	4770      	bx	lr

08002f10 <TM_FATFS_SPI_FLASH_disk_write>:
TM_FATFS_SPI_FLASH_disk_write():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:315
__weak DRESULT TM_FATFS_SPI_FLASH_disk_write(const BYTE *buff, DWORD sector, UINT count) {return (DRESULT)STA_NOINIT;}
 8002f10:	2001      	movs	r0, #1
 8002f12:	4770      	bx	lr

08002f14 <disk_initialize>:
disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:169
/* Inidialize a Drive                                                    */
/*-----------------------------------------------------------------------*/
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber (0..) */
)
{
 8002f14:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:171
	/* Return low level status */
	if (FATFS_LowLevelDrivers[pdrv].disk_initialize) {
 8002f16:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002f1a:	0083      	lsls	r3, r0, #2
 8002f1c:	4a03      	ldr	r2, [pc, #12]	; (8002f2c <disk_initialize+0x18>)
 8002f1e:	58d3      	ldr	r3, [r2, r3]
 8002f20:	b10b      	cbz	r3, 8002f26 <disk_initialize+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:172
		return FATFS_LowLevelDrivers[pdrv].disk_initialize();
 8002f22:	4798      	blx	r3
 8002f24:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:176
	}
	
	/* Return parameter error */
	return RES_PARERR;
 8002f26:	2004      	movs	r0, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:177
}
 8002f28:	bd08      	pop	{r3, pc}
 8002f2a:	bf00      	nop
 8002f2c:	20000024 	.word	0x20000024

08002f30 <disk_status>:
disk_status():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:185
/* Get Disk Status                                                       */
/*-----------------------------------------------------------------------*/
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber (0..) */
)
{
 8002f30:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:187
	/* Return low level status */
	if (FATFS_LowLevelDrivers[pdrv].disk_status) {
 8002f32:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002f36:	0083      	lsls	r3, r0, #2
 8002f38:	4a03      	ldr	r2, [pc, #12]	; (8002f48 <disk_status+0x18>)
 8002f3a:	4413      	add	r3, r2
 8002f3c:	685b      	ldr	r3, [r3, #4]
 8002f3e:	b10b      	cbz	r3, 8002f44 <disk_status+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:188
		return FATFS_LowLevelDrivers[pdrv].disk_status();
 8002f40:	4798      	blx	r3
 8002f42:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:192
	}
	
	/* Return parameter error */
	return RES_PARERR;
 8002f44:	2004      	movs	r0, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:193
}
 8002f46:	bd08      	pop	{r3, pc}
 8002f48:	20000024 	.word	0x20000024

08002f4c <disk_read>:
disk_read():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:206
	DWORD sector,	/* Sector address (LBA) */
	UINT count		/* Number of sectors to read (1..128) */
)
{
	/* Check count */
	if (!count) {
 8002f4c:	b17b      	cbz	r3, 8002f6e <disk_read+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:204
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	UINT count		/* Number of sectors to read (1..128) */
)
{
 8002f4e:	b538      	push	{r3, r4, r5, lr}
 8002f50:	461c      	mov	r4, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:211
	if (!count) {
		return RES_PARERR;
	}
	
	/* Return low level status */
	if (FATFS_LowLevelDrivers[pdrv].disk_read) {
 8002f52:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002f56:	0083      	lsls	r3, r0, #2
 8002f58:	4807      	ldr	r0, [pc, #28]	; (8002f78 <disk_read+0x2c>)
 8002f5a:	4403      	add	r3, r0
 8002f5c:	691d      	ldr	r5, [r3, #16]
 8002f5e:	b145      	cbz	r5, 8002f72 <disk_read+0x26>
 8002f60:	4623      	mov	r3, r4
 8002f62:	4614      	mov	r4, r2
 8002f64:	4608      	mov	r0, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:212
		return FATFS_LowLevelDrivers[pdrv].disk_read(buff, sector, count);
 8002f66:	461a      	mov	r2, r3
 8002f68:	4621      	mov	r1, r4
 8002f6a:	47a8      	blx	r5
 8002f6c:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:207
	UINT count		/* Number of sectors to read (1..128) */
)
{
	/* Check count */
	if (!count) {
		return RES_PARERR;
 8002f6e:	2004      	movs	r0, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:217
		return FATFS_LowLevelDrivers[pdrv].disk_read(buff, sector, count);
	}
	
	/* Return parameter error */
	return RES_PARERR;
}
 8002f70:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:216
	if (FATFS_LowLevelDrivers[pdrv].disk_read) {
		return FATFS_LowLevelDrivers[pdrv].disk_read(buff, sector, count);
	}
	
	/* Return parameter error */
	return RES_PARERR;
 8002f72:	2004      	movs	r0, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:217
}
 8002f74:	bd38      	pop	{r3, r4, r5, pc}
 8002f76:	bf00      	nop
 8002f78:	20000024 	.word	0x20000024

08002f7c <disk_write>:
disk_write():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:233
	DWORD sector,		/* Sector address (LBA) */
	UINT count			/* Number of sectors to write (1..128) */
)
{
	/* Check count */
	if (!count) {
 8002f7c:	b17b      	cbz	r3, 8002f9e <disk_write+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:231
	BYTE pdrv,			/* Physical drive nmuber (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address (LBA) */
	UINT count			/* Number of sectors to write (1..128) */
)
{
 8002f7e:	b538      	push	{r3, r4, r5, lr}
 8002f80:	461c      	mov	r4, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:238
	if (!count) {
		return RES_PARERR;
	}
	
	/* Return low level status */
	if (FATFS_LowLevelDrivers[pdrv].disk_write) {
 8002f82:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002f86:	0083      	lsls	r3, r0, #2
 8002f88:	4807      	ldr	r0, [pc, #28]	; (8002fa8 <disk_write+0x2c>)
 8002f8a:	4403      	add	r3, r0
 8002f8c:	68dd      	ldr	r5, [r3, #12]
 8002f8e:	b145      	cbz	r5, 8002fa2 <disk_write+0x26>
 8002f90:	4623      	mov	r3, r4
 8002f92:	4614      	mov	r4, r2
 8002f94:	4608      	mov	r0, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:239
		return FATFS_LowLevelDrivers[pdrv].disk_write(buff, sector, count);
 8002f96:	461a      	mov	r2, r3
 8002f98:	4621      	mov	r1, r4
 8002f9a:	47a8      	blx	r5
 8002f9c:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:234
	UINT count			/* Number of sectors to write (1..128) */
)
{
	/* Check count */
	if (!count) {
		return RES_PARERR;
 8002f9e:	2004      	movs	r0, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:244
		return FATFS_LowLevelDrivers[pdrv].disk_write(buff, sector, count);
	}
	
	/* Return parameter error */
	return RES_PARERR;
}
 8002fa0:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:243
	if (FATFS_LowLevelDrivers[pdrv].disk_write) {
		return FATFS_LowLevelDrivers[pdrv].disk_write(buff, sector, count);
	}
	
	/* Return parameter error */
	return RES_PARERR;
 8002fa2:	2004      	movs	r0, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:244
}
 8002fa4:	bd38      	pop	{r3, r4, r5, pc}
 8002fa6:	bf00      	nop
 8002fa8:	20000024 	.word	0x20000024

08002fac <disk_ioctl>:
disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:257
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 8002fac:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:259
	/* Return low level status */
	if (FATFS_LowLevelDrivers[pdrv].disk_ioctl) {
 8002fae:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002fb2:	0083      	lsls	r3, r0, #2
 8002fb4:	4804      	ldr	r0, [pc, #16]	; (8002fc8 <disk_ioctl+0x1c>)
 8002fb6:	4403      	add	r3, r0
 8002fb8:	689b      	ldr	r3, [r3, #8]
 8002fba:	b11b      	cbz	r3, 8002fc4 <disk_ioctl+0x18>
 8002fbc:	4608      	mov	r0, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:260
		return FATFS_LowLevelDrivers[pdrv].disk_ioctl(cmd, buff);
 8002fbe:	4611      	mov	r1, r2
 8002fc0:	4798      	blx	r3
 8002fc2:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:264
	}
	
	/* Return parameter error */
	return RES_PARERR;
 8002fc4:	2004      	movs	r0, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:265
}
 8002fc6:	bd08      	pop	{r3, pc}
 8002fc8:	20000024 	.word	0x20000024

08002fcc <get_fattime>:
get_fattime():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/diskio.c:279
			| ((DWORD)7 << 21)				/* Month 7 */
			| ((DWORD)28 << 16)				/* Mday 28 */
			| ((DWORD)0 << 11)				/* Hour 0 */
			| ((DWORD)0 << 5)				/* Min 0 */
			| ((DWORD)0 >> 1);				/* Sec 0 */
}
 8002fcc:	4800      	ldr	r0, [pc, #0]	; (8002fd0 <get_fattime+0x4>)
 8002fce:	4770      	bx	lr
 8002fd0:	42fc0000 	.word	0x42fc0000

08002fd4 <TM_SPI_Send>:
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8002fd4:	6803      	ldr	r3, [r0, #0]
 8002fd6:	f013 0f40 	tst.w	r3, #64	; 0x40
 8002fda:	d013      	beq.n	8003004 <TM_SPI_Send+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401 (discriminator 3)
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8002fdc:	6883      	ldr	r3, [r0, #8]
 8002fde:	f013 0f02 	tst.w	r3, #2
 8002fe2:	d0fb      	beq.n	8002fdc <TM_SPI_Send+0x8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401 (discriminator 2)
 8002fe4:	6883      	ldr	r3, [r0, #8]
 8002fe6:	f013 0f80 	tst.w	r3, #128	; 0x80
 8002fea:	d1f7      	bne.n	8002fdc <TM_SPI_Send+0x8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8002fec:	7301      	strb	r1, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407 (discriminator 3)
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8002fee:	6883      	ldr	r3, [r0, #8]
 8002ff0:	f013 0f01 	tst.w	r3, #1
 8002ff4:	d0fb      	beq.n	8002fee <TM_SPI_Send+0x1a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407 (discriminator 2)
 8002ff6:	6883      	ldr	r3, [r0, #8]
 8002ff8:	f013 0f80 	tst.w	r3, #128	; 0x80
 8002ffc:	d1f7      	bne.n	8002fee <TM_SPI_Send+0x1a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8002ffe:	68c0      	ldr	r0, [r0, #12]
 8003000:	b2c0      	uxtb	r0, r0
 8003002:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003004:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:411
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
	
	/* Return data from buffer */
	return SPIx->DR;
}
 8003006:	4770      	bx	lr

08003008 <SDCARD_IsDetected>:
SDCARD_IsDetected():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:46
	return !TM_GPIO_GetInputPinValue(FATFS_USE_DETECT_PIN_PORT, FATFS_USE_DETECT_PIN_PIN);
#endif
	
	/* Card is detected */
	return 1;
}
 8003008:	2001      	movs	r0, #1
 800300a:	4770      	bx	lr

0800300c <SDCARD_IsWriteEnabled>:
SDCARD_IsWriteEnabled():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:57
	return !TM_GPIO_GetInputPinValue(FATFS_USE_WRITEPROTECT_PIN_PORT, FATFS_USE_WRITEPROTECT_PIN_PIN);
#endif
	
	/* Card is not write protected */
	return 1;
}
 800300c:	2001      	movs	r0, #1
 800300e:	4770      	bx	lr

08003010 <init_spi>:
init_spi():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:60

/* Initialize MMC interface */
static void init_spi (void) {
 8003010:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:62
	/* Init delay functions */
	TM_DELAY_Init();
 8003012:	f002 fb87 	bl	8005724 <TM_DELAY_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:65
	
	/* Init SPI */
	TM_SPI_Init(FATFS_SPI, FATFS_SPI_PINSPACK);
 8003016:	2101      	movs	r1, #1
 8003018:	4805      	ldr	r0, [pc, #20]	; (8003030 <init_spi+0x20>)
 800301a:	f002 fe2f 	bl	8005c7c <TM_SPI_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:68
	
	/* Set CS high */
	FATFS_CS_HIGH;
 800301e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8003022:	4b04      	ldr	r3, [pc, #16]	; (8003034 <init_spi+0x24>)
 8003024:	619a      	str	r2, [r3, #24]
Delayms():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_delay.h:202
 * @param  millis: Number of milliseconds for delay
 * @retval None
 */
__STATIC_INLINE void Delayms(uint32_t millis) {
	/* Use HAL library for delay ms purpose */
	HAL_Delay(millis);
 8003026:	200a      	movs	r0, #10
 8003028:	f002 fbe4 	bl	80057f4 <HAL_Delay>
 800302c:	bd08      	pop	{r3, pc}
 800302e:	bf00      	nop
 8003030:	40003800 	.word	0x40003800
 8003034:	40021000 	.word	0x40021000

08003038 <rcvr_spi_multi>:
rcvr_spi_multi():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:80
/* Receive multiple byte */
static void rcvr_spi_multi (
	BYTE *buff,		/* Pointer to data buffer */
	UINT btr		/* Number of bytes to receive (even number) */
)
{
 8003038:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:82
	/* Read multiple bytes, send 0xFF as dummy */
	TM_SPI_ReadMulti(FATFS_SPI, buff, 0xFF, btr);
 800303a:	460b      	mov	r3, r1
 800303c:	22ff      	movs	r2, #255	; 0xff
 800303e:	4601      	mov	r1, r0
 8003040:	4801      	ldr	r0, [pc, #4]	; (8003048 <rcvr_spi_multi+0x10>)
 8003042:	f002 fcd1 	bl	80059e8 <TM_SPI_ReadMulti>
 8003046:	bd08      	pop	{r3, pc}
 8003048:	40003800 	.word	0x40003800

0800304c <xmit_spi_multi>:
xmit_spi_multi():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:92
/* Send multiple byte */
static void xmit_spi_multi (
	const BYTE *buff,	/* Pointer to the data */
	UINT btx			/* Number of bytes to send (even number) */
)
{
 800304c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:94
	/* Write multiple bytes */
	TM_SPI_WriteMulti(FATFS_SPI, (uint8_t *)buff, btx);
 800304e:	460a      	mov	r2, r1
 8003050:	4601      	mov	r1, r0
 8003052:	4802      	ldr	r0, [pc, #8]	; (800305c <xmit_spi_multi+0x10>)
 8003054:	f002 fca6 	bl	80059a4 <TM_SPI_WriteMulti>
 8003058:	bd08      	pop	{r3, pc}
 800305a:	bf00      	nop
 800305c:	40003800 	.word	0x40003800

08003060 <wait_ready>:
wait_ready():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:110
)
{
	BYTE d;

	/* Set down counter */
	TM_DELAY_SetTime2(wt);
 8003060:	4b16      	ldr	r3, [pc, #88]	; (80030bc <wait_ready+0x5c>)
 8003062:	6018      	str	r0, [r3, #0]
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398 (discriminator 2)
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003064:	4b16      	ldr	r3, [pc, #88]	; (80030c0 <wait_ready+0x60>)
 8003066:	681b      	ldr	r3, [r3, #0]
 8003068:	f013 0f40 	tst.w	r3, #64	; 0x40
 800306c:	d01a      	beq.n	80030a4 <wait_ready+0x44>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 800306e:	4b14      	ldr	r3, [pc, #80]	; (80030c0 <wait_ready+0x60>)
 8003070:	689b      	ldr	r3, [r3, #8]
 8003072:	f013 0f02 	tst.w	r3, #2
 8003076:	d0fa      	beq.n	800306e <wait_ready+0xe>
 8003078:	4b11      	ldr	r3, [pc, #68]	; (80030c0 <wait_ready+0x60>)
 800307a:	689b      	ldr	r3, [r3, #8]
 800307c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003080:	d1f5      	bne.n	800306e <wait_ready+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003082:	22ff      	movs	r2, #255	; 0xff
 8003084:	4b0e      	ldr	r3, [pc, #56]	; (80030c0 <wait_ready+0x60>)
 8003086:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8003088:	4b0d      	ldr	r3, [pc, #52]	; (80030c0 <wait_ready+0x60>)
 800308a:	689b      	ldr	r3, [r3, #8]
 800308c:	f013 0f01 	tst.w	r3, #1
 8003090:	d0fa      	beq.n	8003088 <wait_ready+0x28>
 8003092:	4b0b      	ldr	r3, [pc, #44]	; (80030c0 <wait_ready+0x60>)
 8003094:	689b      	ldr	r3, [r3, #8]
 8003096:	f013 0f80 	tst.w	r3, #128	; 0x80
 800309a:	d1f5      	bne.n	8003088 <wait_ready+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 800309c:	4b08      	ldr	r3, [pc, #32]	; (80030c0 <wait_ready+0x60>)
 800309e:	68d8      	ldr	r0, [r3, #12]
 80030a0:	b2c0      	uxtb	r0, r0
 80030a2:	e000      	b.n	80030a6 <wait_ready+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 80030a4:	2000      	movs	r0, #0
wait_ready():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:114
	
	do {
		d = TM_SPI_Send(FATFS_SPI, 0xFF);
	} while (d != 0xFF && TM_DELAY_Time2());	/* Wait for card goes ready or timeout */
 80030a6:	28ff      	cmp	r0, #255	; 0xff
 80030a8:	d003      	beq.n	80030b2 <wait_ready+0x52>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:114 (discriminator 1)
 80030aa:	4b04      	ldr	r3, [pc, #16]	; (80030bc <wait_ready+0x5c>)
 80030ac:	681b      	ldr	r3, [r3, #0]
 80030ae:	2b00      	cmp	r3, #0
 80030b0:	d1d8      	bne.n	8003064 <wait_ready+0x4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:117
	
	return (d == 0xFF) ? 1 : 0;
}
 80030b2:	28ff      	cmp	r0, #255	; 0xff
 80030b4:	bf14      	ite	ne
 80030b6:	2000      	movne	r0, #0
 80030b8:	2001      	moveq	r0, #1
 80030ba:	4770      	bx	lr
 80030bc:	20001af4 	.word	0x20001af4
 80030c0:	40003800 	.word	0x40003800

080030c4 <deselect>:
deselect():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:127
/* Deselect card and release SPI                                         */
/*-----------------------------------------------------------------------*/

static void deselect (void)
{
	FATFS_CS_HIGH;			/* CS = H */
 80030c4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80030c8:	4b10      	ldr	r3, [pc, #64]	; (800310c <deselect+0x48>)
 80030ca:	619a      	str	r2, [r3, #24]
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 80030cc:	f5a3 33ec 	sub.w	r3, r3, #120832	; 0x1d800
 80030d0:	681b      	ldr	r3, [r3, #0]
 80030d2:	f013 0f40 	tst.w	r3, #64	; 0x40
 80030d6:	d018      	beq.n	800310a <deselect+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 80030d8:	4b0d      	ldr	r3, [pc, #52]	; (8003110 <deselect+0x4c>)
 80030da:	689b      	ldr	r3, [r3, #8]
 80030dc:	f013 0f02 	tst.w	r3, #2
 80030e0:	d0fa      	beq.n	80030d8 <deselect+0x14>
 80030e2:	4b0b      	ldr	r3, [pc, #44]	; (8003110 <deselect+0x4c>)
 80030e4:	689b      	ldr	r3, [r3, #8]
 80030e6:	f013 0f80 	tst.w	r3, #128	; 0x80
 80030ea:	d1f5      	bne.n	80030d8 <deselect+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80030ec:	22ff      	movs	r2, #255	; 0xff
 80030ee:	4b08      	ldr	r3, [pc, #32]	; (8003110 <deselect+0x4c>)
 80030f0:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80030f2:	4b07      	ldr	r3, [pc, #28]	; (8003110 <deselect+0x4c>)
 80030f4:	689b      	ldr	r3, [r3, #8]
 80030f6:	f013 0f01 	tst.w	r3, #1
 80030fa:	d0fa      	beq.n	80030f2 <deselect+0x2e>
 80030fc:	4b04      	ldr	r3, [pc, #16]	; (8003110 <deselect+0x4c>)
 80030fe:	689b      	ldr	r3, [r3, #8]
 8003100:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003104:	d1f5      	bne.n	80030f2 <deselect+0x2e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003106:	4b02      	ldr	r3, [pc, #8]	; (8003110 <deselect+0x4c>)
 8003108:	68db      	ldr	r3, [r3, #12]
 800310a:	4770      	bx	lr
 800310c:	40021000 	.word	0x40021000
 8003110:	40003800 	.word	0x40003800

08003114 <select>:
select():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:138
/*-----------------------------------------------------------------------*/
/* Select card and wait for ready                                        */
/*-----------------------------------------------------------------------*/

static int select (void)	/* 1:OK, 0:Timeout */
{
 8003114:	b510      	push	{r4, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:139
	FATFS_CS_LOW;
 8003116:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800311a:	4b16      	ldr	r3, [pc, #88]	; (8003174 <select+0x60>)
 800311c:	619a      	str	r2, [r3, #24]
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 800311e:	f5a3 33ec 	sub.w	r3, r3, #120832	; 0x1d800
 8003122:	681b      	ldr	r3, [r3, #0]
 8003124:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003128:	d018      	beq.n	800315c <select+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 800312a:	4b13      	ldr	r3, [pc, #76]	; (8003178 <select+0x64>)
 800312c:	689b      	ldr	r3, [r3, #8]
 800312e:	f013 0f02 	tst.w	r3, #2
 8003132:	d0fa      	beq.n	800312a <select+0x16>
 8003134:	4b10      	ldr	r3, [pc, #64]	; (8003178 <select+0x64>)
 8003136:	689b      	ldr	r3, [r3, #8]
 8003138:	f013 0f80 	tst.w	r3, #128	; 0x80
 800313c:	d1f5      	bne.n	800312a <select+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 800313e:	22ff      	movs	r2, #255	; 0xff
 8003140:	4b0d      	ldr	r3, [pc, #52]	; (8003178 <select+0x64>)
 8003142:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8003144:	4b0c      	ldr	r3, [pc, #48]	; (8003178 <select+0x64>)
 8003146:	689b      	ldr	r3, [r3, #8]
 8003148:	f013 0f01 	tst.w	r3, #1
 800314c:	d0fa      	beq.n	8003144 <select+0x30>
 800314e:	4b0a      	ldr	r3, [pc, #40]	; (8003178 <select+0x64>)
 8003150:	689b      	ldr	r3, [r3, #8]
 8003152:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003156:	d1f5      	bne.n	8003144 <select+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003158:	4b07      	ldr	r3, [pc, #28]	; (8003178 <select+0x64>)
 800315a:	68db      	ldr	r3, [r3, #12]
select():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:142
	TM_SPI_Send(FATFS_SPI, 0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready(500)) {
 800315c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003160:	f7ff ff7e 	bl	8003060 <wait_ready>
 8003164:	4604      	mov	r4, r0
 8003166:	b910      	cbnz	r0, 800316e <select+0x5a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:145
		return 1;	/* OK */
	}
	deselect();
 8003168:	f7ff ffac 	bl	80030c4 <deselect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:146
	return 0;	/* Timeout */
 800316c:	e000      	b.n	8003170 <select+0x5c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:143
{
	FATFS_CS_LOW;
	TM_SPI_Send(FATFS_SPI, 0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready(500)) {
		return 1;	/* OK */
 800316e:	2401      	movs	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:147
	}
	deselect();
	return 0;	/* Timeout */
}
 8003170:	4620      	mov	r0, r4
 8003172:	bd10      	pop	{r4, pc}
 8003174:	40021000 	.word	0x40021000
 8003178:	40003800 	.word	0x40003800

0800317c <xmit_datablock>:
xmit_datablock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:189
#if _USE_WRITE
static int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* Ponter to 512 byte data to be sent */
	BYTE token			/* Token */
)
{
 800317c:	b538      	push	{r3, r4, r5, lr}
 800317e:	4605      	mov	r5, r0
 8003180:	460c      	mov	r4, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:192
	BYTE resp;

	if (!wait_ready(500)) {
 8003182:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003186:	f7ff ff6b 	bl	8003060 <wait_ready>
 800318a:	4603      	mov	r3, r0
 800318c:	2800      	cmp	r0, #0
 800318e:	f000 808a 	beq.w	80032a6 <xmit_datablock+0x12a>
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003192:	4b46      	ldr	r3, [pc, #280]	; (80032ac <xmit_datablock+0x130>)
 8003194:	681b      	ldr	r3, [r3, #0]
 8003196:	f013 0f40 	tst.w	r3, #64	; 0x40
 800319a:	d017      	beq.n	80031cc <xmit_datablock+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 800319c:	4b43      	ldr	r3, [pc, #268]	; (80032ac <xmit_datablock+0x130>)
 800319e:	689b      	ldr	r3, [r3, #8]
 80031a0:	f013 0f02 	tst.w	r3, #2
 80031a4:	d0fa      	beq.n	800319c <xmit_datablock+0x20>
 80031a6:	4b41      	ldr	r3, [pc, #260]	; (80032ac <xmit_datablock+0x130>)
 80031a8:	689b      	ldr	r3, [r3, #8]
 80031aa:	f013 0f80 	tst.w	r3, #128	; 0x80
 80031ae:	d1f5      	bne.n	800319c <xmit_datablock+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80031b0:	4b3e      	ldr	r3, [pc, #248]	; (80032ac <xmit_datablock+0x130>)
 80031b2:	731c      	strb	r4, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80031b4:	4b3d      	ldr	r3, [pc, #244]	; (80032ac <xmit_datablock+0x130>)
 80031b6:	689b      	ldr	r3, [r3, #8]
 80031b8:	f013 0f01 	tst.w	r3, #1
 80031bc:	d0fa      	beq.n	80031b4 <xmit_datablock+0x38>
 80031be:	4b3b      	ldr	r3, [pc, #236]	; (80032ac <xmit_datablock+0x130>)
 80031c0:	689b      	ldr	r3, [r3, #8]
 80031c2:	f013 0f80 	tst.w	r3, #128	; 0x80
 80031c6:	d1f5      	bne.n	80031b4 <xmit_datablock+0x38>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 80031c8:	4b38      	ldr	r3, [pc, #224]	; (80032ac <xmit_datablock+0x130>)
 80031ca:	68db      	ldr	r3, [r3, #12]
xmit_datablock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:197
		return 0;		/* Wait for card ready */
	}

	TM_SPI_Send(FATFS_SPI, token);					/* Send token */
	if (token != 0xFD) {				/* Send data if token is other than StopTran */
 80031cc:	2cfd      	cmp	r4, #253	; 0xfd
 80031ce:	d067      	beq.n	80032a0 <xmit_datablock+0x124>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:198
		xmit_spi_multi(buff, 512);		/* Data */
 80031d0:	f44f 7100 	mov.w	r1, #512	; 0x200
 80031d4:	4628      	mov	r0, r5
 80031d6:	f7ff ff39 	bl	800304c <xmit_spi_multi>
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 80031da:	4b34      	ldr	r3, [pc, #208]	; (80032ac <xmit_datablock+0x130>)
 80031dc:	681b      	ldr	r3, [r3, #0]
 80031de:	f013 0f40 	tst.w	r3, #64	; 0x40
 80031e2:	d018      	beq.n	8003216 <xmit_datablock+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 80031e4:	4b31      	ldr	r3, [pc, #196]	; (80032ac <xmit_datablock+0x130>)
 80031e6:	689b      	ldr	r3, [r3, #8]
 80031e8:	f013 0f02 	tst.w	r3, #2
 80031ec:	d0fa      	beq.n	80031e4 <xmit_datablock+0x68>
 80031ee:	4b2f      	ldr	r3, [pc, #188]	; (80032ac <xmit_datablock+0x130>)
 80031f0:	689b      	ldr	r3, [r3, #8]
 80031f2:	f013 0f80 	tst.w	r3, #128	; 0x80
 80031f6:	d1f5      	bne.n	80031e4 <xmit_datablock+0x68>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80031f8:	22ff      	movs	r2, #255	; 0xff
 80031fa:	4b2c      	ldr	r3, [pc, #176]	; (80032ac <xmit_datablock+0x130>)
 80031fc:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80031fe:	4b2b      	ldr	r3, [pc, #172]	; (80032ac <xmit_datablock+0x130>)
 8003200:	689b      	ldr	r3, [r3, #8]
 8003202:	f013 0f01 	tst.w	r3, #1
 8003206:	d0fa      	beq.n	80031fe <xmit_datablock+0x82>
 8003208:	4b28      	ldr	r3, [pc, #160]	; (80032ac <xmit_datablock+0x130>)
 800320a:	689b      	ldr	r3, [r3, #8]
 800320c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003210:	d1f5      	bne.n	80031fe <xmit_datablock+0x82>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003212:	4b26      	ldr	r3, [pc, #152]	; (80032ac <xmit_datablock+0x130>)
 8003214:	68db      	ldr	r3, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003216:	4b25      	ldr	r3, [pc, #148]	; (80032ac <xmit_datablock+0x130>)
 8003218:	681b      	ldr	r3, [r3, #0]
 800321a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800321e:	d018      	beq.n	8003252 <xmit_datablock+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003220:	4b22      	ldr	r3, [pc, #136]	; (80032ac <xmit_datablock+0x130>)
 8003222:	689b      	ldr	r3, [r3, #8]
 8003224:	f013 0f02 	tst.w	r3, #2
 8003228:	d0fa      	beq.n	8003220 <xmit_datablock+0xa4>
 800322a:	4b20      	ldr	r3, [pc, #128]	; (80032ac <xmit_datablock+0x130>)
 800322c:	689b      	ldr	r3, [r3, #8]
 800322e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003232:	d1f5      	bne.n	8003220 <xmit_datablock+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003234:	22ff      	movs	r2, #255	; 0xff
 8003236:	4b1d      	ldr	r3, [pc, #116]	; (80032ac <xmit_datablock+0x130>)
 8003238:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 800323a:	4b1c      	ldr	r3, [pc, #112]	; (80032ac <xmit_datablock+0x130>)
 800323c:	689b      	ldr	r3, [r3, #8]
 800323e:	f013 0f01 	tst.w	r3, #1
 8003242:	d0fa      	beq.n	800323a <xmit_datablock+0xbe>
 8003244:	4b19      	ldr	r3, [pc, #100]	; (80032ac <xmit_datablock+0x130>)
 8003246:	689b      	ldr	r3, [r3, #8]
 8003248:	f013 0f80 	tst.w	r3, #128	; 0x80
 800324c:	d1f5      	bne.n	800323a <xmit_datablock+0xbe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 800324e:	4b17      	ldr	r3, [pc, #92]	; (80032ac <xmit_datablock+0x130>)
 8003250:	68db      	ldr	r3, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003252:	4b16      	ldr	r3, [pc, #88]	; (80032ac <xmit_datablock+0x130>)
 8003254:	681b      	ldr	r3, [r3, #0]
 8003256:	f013 0f40 	tst.w	r3, #64	; 0x40
 800325a:	d01a      	beq.n	8003292 <xmit_datablock+0x116>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 800325c:	4b13      	ldr	r3, [pc, #76]	; (80032ac <xmit_datablock+0x130>)
 800325e:	689b      	ldr	r3, [r3, #8]
 8003260:	f013 0f02 	tst.w	r3, #2
 8003264:	d0fa      	beq.n	800325c <xmit_datablock+0xe0>
 8003266:	4b11      	ldr	r3, [pc, #68]	; (80032ac <xmit_datablock+0x130>)
 8003268:	689b      	ldr	r3, [r3, #8]
 800326a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800326e:	d1f5      	bne.n	800325c <xmit_datablock+0xe0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003270:	22ff      	movs	r2, #255	; 0xff
 8003272:	4b0e      	ldr	r3, [pc, #56]	; (80032ac <xmit_datablock+0x130>)
 8003274:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8003276:	4b0d      	ldr	r3, [pc, #52]	; (80032ac <xmit_datablock+0x130>)
 8003278:	689b      	ldr	r3, [r3, #8]
 800327a:	f013 0f01 	tst.w	r3, #1
 800327e:	d0fa      	beq.n	8003276 <xmit_datablock+0xfa>
 8003280:	4b0a      	ldr	r3, [pc, #40]	; (80032ac <xmit_datablock+0x130>)
 8003282:	689b      	ldr	r3, [r3, #8]
 8003284:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003288:	d1f5      	bne.n	8003276 <xmit_datablock+0xfa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 800328a:	4b08      	ldr	r3, [pc, #32]	; (80032ac <xmit_datablock+0x130>)
 800328c:	68db      	ldr	r3, [r3, #12]
 800328e:	b2db      	uxtb	r3, r3
 8003290:	e000      	b.n	8003294 <xmit_datablock+0x118>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003292:	2300      	movs	r3, #0
xmit_datablock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:202
		TM_SPI_Send(FATFS_SPI, 0xFF); TM_SPI_Send(FATFS_SPI, 0xFF);	/* Dummy CRC */

		resp = TM_SPI_Send(FATFS_SPI, 0xFF);				/* Receive data resp */
		if ((resp & 0x1F) != 0x05)		/* Function fails if the data packet was not accepted */
 8003294:	f003 031f 	and.w	r3, r3, #31
 8003298:	2b05      	cmp	r3, #5
 800329a:	d003      	beq.n	80032a4 <xmit_datablock+0x128>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:203
			return 0;
 800329c:	2300      	movs	r3, #0
 800329e:	e002      	b.n	80032a6 <xmit_datablock+0x12a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:205
	}
	return 1;
 80032a0:	2301      	movs	r3, #1
 80032a2:	e000      	b.n	80032a6 <xmit_datablock+0x12a>
 80032a4:	2301      	movs	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:206
}
 80032a6:	4618      	mov	r0, r3
 80032a8:	bd38      	pop	{r3, r4, r5, pc}
 80032aa:	bf00      	nop
 80032ac:	40003800 	.word	0x40003800

080032b0 <rcvr_datablock>:
rcvr_datablock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:159

static int rcvr_datablock (	/* 1:OK, 0:Error */
	BYTE *buff,			/* Data buffer */
	UINT btr			/* Data block length (byte) */
)
{
 80032b0:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:164
	BYTE token;
	
	//Timer1 = 200;
	
	TM_DELAY_SetTime2(200);
 80032b2:	22c8      	movs	r2, #200	; 0xc8
 80032b4:	4b36      	ldr	r3, [pc, #216]	; (8003390 <rcvr_datablock+0xe0>)
 80032b6:	601a      	str	r2, [r3, #0]
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398 (discriminator 2)
 80032b8:	4b36      	ldr	r3, [pc, #216]	; (8003394 <rcvr_datablock+0xe4>)
 80032ba:	681b      	ldr	r3, [r3, #0]
 80032bc:	f013 0f40 	tst.w	r3, #64	; 0x40
 80032c0:	d01a      	beq.n	80032f8 <rcvr_datablock+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 80032c2:	4b34      	ldr	r3, [pc, #208]	; (8003394 <rcvr_datablock+0xe4>)
 80032c4:	689b      	ldr	r3, [r3, #8]
 80032c6:	f013 0f02 	tst.w	r3, #2
 80032ca:	d0fa      	beq.n	80032c2 <rcvr_datablock+0x12>
 80032cc:	4b31      	ldr	r3, [pc, #196]	; (8003394 <rcvr_datablock+0xe4>)
 80032ce:	689b      	ldr	r3, [r3, #8]
 80032d0:	f013 0f80 	tst.w	r3, #128	; 0x80
 80032d4:	d1f5      	bne.n	80032c2 <rcvr_datablock+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80032d6:	22ff      	movs	r2, #255	; 0xff
 80032d8:	4b2e      	ldr	r3, [pc, #184]	; (8003394 <rcvr_datablock+0xe4>)
 80032da:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80032dc:	4b2d      	ldr	r3, [pc, #180]	; (8003394 <rcvr_datablock+0xe4>)
 80032de:	689b      	ldr	r3, [r3, #8]
 80032e0:	f013 0f01 	tst.w	r3, #1
 80032e4:	d0fa      	beq.n	80032dc <rcvr_datablock+0x2c>
 80032e6:	4b2b      	ldr	r3, [pc, #172]	; (8003394 <rcvr_datablock+0xe4>)
 80032e8:	689b      	ldr	r3, [r3, #8]
 80032ea:	f013 0f80 	tst.w	r3, #128	; 0x80
 80032ee:	d1f5      	bne.n	80032dc <rcvr_datablock+0x2c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 80032f0:	4b28      	ldr	r3, [pc, #160]	; (8003394 <rcvr_datablock+0xe4>)
 80032f2:	68db      	ldr	r3, [r3, #12]
 80032f4:	b2db      	uxtb	r3, r3
 80032f6:	e000      	b.n	80032fa <rcvr_datablock+0x4a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 80032f8:	2300      	movs	r3, #0
rcvr_datablock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:168
	do {							// Wait for DataStart token in timeout of 200ms 
		token = TM_SPI_Send(FATFS_SPI, 0xFF);
		// This loop will take a time. Insert rot_rdq() here for multitask envilonment. 
	} while ((token == 0xFF) && TM_DELAY_Time2());
 80032fa:	2bff      	cmp	r3, #255	; 0xff
 80032fc:	d103      	bne.n	8003306 <rcvr_datablock+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:168 (discriminator 1)
 80032fe:	4a24      	ldr	r2, [pc, #144]	; (8003390 <rcvr_datablock+0xe0>)
 8003300:	6812      	ldr	r2, [r2, #0]
 8003302:	2a00      	cmp	r2, #0
 8003304:	d1d8      	bne.n	80032b8 <rcvr_datablock+0x8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:169
	if (token != 0xFE) {
 8003306:	2bfe      	cmp	r3, #254	; 0xfe
 8003308:	d13f      	bne.n	800338a <rcvr_datablock+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:173
		return 0;		// Function fails if invalid DataStart token or timeout 
	}

	rcvr_spi_multi(buff, btr);		// Store trailing data to the buffer 
 800330a:	f7ff fe95 	bl	8003038 <rcvr_spi_multi>
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 800330e:	4b21      	ldr	r3, [pc, #132]	; (8003394 <rcvr_datablock+0xe4>)
 8003310:	681b      	ldr	r3, [r3, #0]
 8003312:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003316:	d018      	beq.n	800334a <rcvr_datablock+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003318:	4b1e      	ldr	r3, [pc, #120]	; (8003394 <rcvr_datablock+0xe4>)
 800331a:	689b      	ldr	r3, [r3, #8]
 800331c:	f013 0f02 	tst.w	r3, #2
 8003320:	d0fa      	beq.n	8003318 <rcvr_datablock+0x68>
 8003322:	4b1c      	ldr	r3, [pc, #112]	; (8003394 <rcvr_datablock+0xe4>)
 8003324:	689b      	ldr	r3, [r3, #8]
 8003326:	f013 0f80 	tst.w	r3, #128	; 0x80
 800332a:	d1f5      	bne.n	8003318 <rcvr_datablock+0x68>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 800332c:	22ff      	movs	r2, #255	; 0xff
 800332e:	4b19      	ldr	r3, [pc, #100]	; (8003394 <rcvr_datablock+0xe4>)
 8003330:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8003332:	4b18      	ldr	r3, [pc, #96]	; (8003394 <rcvr_datablock+0xe4>)
 8003334:	689b      	ldr	r3, [r3, #8]
 8003336:	f013 0f01 	tst.w	r3, #1
 800333a:	d0fa      	beq.n	8003332 <rcvr_datablock+0x82>
 800333c:	4b15      	ldr	r3, [pc, #84]	; (8003394 <rcvr_datablock+0xe4>)
 800333e:	689b      	ldr	r3, [r3, #8]
 8003340:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003344:	d1f5      	bne.n	8003332 <rcvr_datablock+0x82>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003346:	4b13      	ldr	r3, [pc, #76]	; (8003394 <rcvr_datablock+0xe4>)
 8003348:	68db      	ldr	r3, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 800334a:	4b12      	ldr	r3, [pc, #72]	; (8003394 <rcvr_datablock+0xe4>)
 800334c:	681b      	ldr	r3, [r3, #0]
 800334e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003352:	d018      	beq.n	8003386 <rcvr_datablock+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003354:	4b0f      	ldr	r3, [pc, #60]	; (8003394 <rcvr_datablock+0xe4>)
 8003356:	689b      	ldr	r3, [r3, #8]
 8003358:	f013 0f02 	tst.w	r3, #2
 800335c:	d0fa      	beq.n	8003354 <rcvr_datablock+0xa4>
 800335e:	4b0d      	ldr	r3, [pc, #52]	; (8003394 <rcvr_datablock+0xe4>)
 8003360:	689b      	ldr	r3, [r3, #8]
 8003362:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003366:	d1f5      	bne.n	8003354 <rcvr_datablock+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003368:	22ff      	movs	r2, #255	; 0xff
 800336a:	4b0a      	ldr	r3, [pc, #40]	; (8003394 <rcvr_datablock+0xe4>)
 800336c:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 800336e:	4b09      	ldr	r3, [pc, #36]	; (8003394 <rcvr_datablock+0xe4>)
 8003370:	689b      	ldr	r3, [r3, #8]
 8003372:	f013 0f01 	tst.w	r3, #1
 8003376:	d0fa      	beq.n	800336e <rcvr_datablock+0xbe>
 8003378:	4b06      	ldr	r3, [pc, #24]	; (8003394 <rcvr_datablock+0xe4>)
 800337a:	689b      	ldr	r3, [r3, #8]
 800337c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003380:	d1f5      	bne.n	800336e <rcvr_datablock+0xbe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003382:	4b04      	ldr	r3, [pc, #16]	; (8003394 <rcvr_datablock+0xe4>)
 8003384:	68db      	ldr	r3, [r3, #12]
rcvr_datablock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:175
	TM_SPI_Send(FATFS_SPI, 0xFF); TM_SPI_Send(FATFS_SPI, 0xFF);			// Discard CRC 
	return 1;						// Function succeeded 
 8003386:	2001      	movs	r0, #1
 8003388:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:170
	do {							// Wait for DataStart token in timeout of 200ms 
		token = TM_SPI_Send(FATFS_SPI, 0xFF);
		// This loop will take a time. Insert rot_rdq() here for multitask envilonment. 
	} while ((token == 0xFF) && TM_DELAY_Time2());
	if (token != 0xFE) {
		return 0;		// Function fails if invalid DataStart token or timeout 
 800338a:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:176
	}

	rcvr_spi_multi(buff, btr);		// Store trailing data to the buffer 
	TM_SPI_Send(FATFS_SPI, 0xFF); TM_SPI_Send(FATFS_SPI, 0xFF);			// Discard CRC 
	return 1;						// Function succeeded 
}
 800338c:	bd08      	pop	{r3, pc}
 800338e:	bf00      	nop
 8003390:	20001af4 	.word	0x20001af4
 8003394:	40003800 	.word	0x40003800

08003398 <send_cmd>:
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:218

static BYTE send_cmd (		/* Return value: R1 resp (bit7==1:Failed to send) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
 8003398:	b538      	push	{r3, r4, r5, lr}
 800339a:	4604      	mov	r4, r0
 800339c:	460d      	mov	r5, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:221
	BYTE n, res;
	
	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 800339e:	f010 0f80 	tst.w	r0, #128	; 0x80
 80033a2:	d008      	beq.n	80033b6 <send_cmd+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:222
		cmd &= 0x7F;
 80033a4:	f000 047f 	and.w	r4, r0, #127	; 0x7f
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:223
		res = send_cmd(CMD55, 0);
 80033a8:	2100      	movs	r1, #0
 80033aa:	2037      	movs	r0, #55	; 0x37
 80033ac:	f7ff fff4 	bl	8003398 <send_cmd>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:224
		if (res > 1) return res;
 80033b0:	2801      	cmp	r0, #1
 80033b2:	f200 8111 	bhi.w	80035d8 <send_cmd+0x240>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:228
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
 80033b6:	2c0c      	cmp	r4, #12
 80033b8:	d006      	beq.n	80033c8 <send_cmd+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:229
		deselect();
 80033ba:	f7ff fe83 	bl	80030c4 <deselect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:230
		if (!select()) return 0xFF;
 80033be:	f7ff fea9 	bl	8003114 <select>
 80033c2:	2800      	cmp	r0, #0
 80033c4:	f000 8107 	beq.w	80035d6 <send_cmd+0x23e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:234
	}

	/* Send command packet */
	TM_SPI_Send(FATFS_SPI, 0x40 | cmd);				/* Start + command index */
 80033c8:	f044 0240 	orr.w	r2, r4, #64	; 0x40
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 80033cc:	4b83      	ldr	r3, [pc, #524]	; (80035dc <send_cmd+0x244>)
 80033ce:	681b      	ldr	r3, [r3, #0]
 80033d0:	f013 0f40 	tst.w	r3, #64	; 0x40
 80033d4:	d017      	beq.n	8003406 <send_cmd+0x6e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 80033d6:	4b81      	ldr	r3, [pc, #516]	; (80035dc <send_cmd+0x244>)
 80033d8:	689b      	ldr	r3, [r3, #8]
 80033da:	f013 0f02 	tst.w	r3, #2
 80033de:	d0fa      	beq.n	80033d6 <send_cmd+0x3e>
 80033e0:	4b7e      	ldr	r3, [pc, #504]	; (80035dc <send_cmd+0x244>)
 80033e2:	689b      	ldr	r3, [r3, #8]
 80033e4:	f013 0f80 	tst.w	r3, #128	; 0x80
 80033e8:	d1f5      	bne.n	80033d6 <send_cmd+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80033ea:	4b7c      	ldr	r3, [pc, #496]	; (80035dc <send_cmd+0x244>)
 80033ec:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80033ee:	4b7b      	ldr	r3, [pc, #492]	; (80035dc <send_cmd+0x244>)
 80033f0:	689b      	ldr	r3, [r3, #8]
 80033f2:	f013 0f01 	tst.w	r3, #1
 80033f6:	d0fa      	beq.n	80033ee <send_cmd+0x56>
 80033f8:	4b78      	ldr	r3, [pc, #480]	; (80035dc <send_cmd+0x244>)
 80033fa:	689b      	ldr	r3, [r3, #8]
 80033fc:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003400:	d1f5      	bne.n	80033ee <send_cmd+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003402:	4b76      	ldr	r3, [pc, #472]	; (80035dc <send_cmd+0x244>)
 8003404:	68db      	ldr	r3, [r3, #12]
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:235
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 24));		/* Argument[31..24] */
 8003406:	0e2a      	lsrs	r2, r5, #24
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003408:	4b74      	ldr	r3, [pc, #464]	; (80035dc <send_cmd+0x244>)
 800340a:	681b      	ldr	r3, [r3, #0]
 800340c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003410:	d017      	beq.n	8003442 <send_cmd+0xaa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003412:	4b72      	ldr	r3, [pc, #456]	; (80035dc <send_cmd+0x244>)
 8003414:	689b      	ldr	r3, [r3, #8]
 8003416:	f013 0f02 	tst.w	r3, #2
 800341a:	d0fa      	beq.n	8003412 <send_cmd+0x7a>
 800341c:	4b6f      	ldr	r3, [pc, #444]	; (80035dc <send_cmd+0x244>)
 800341e:	689b      	ldr	r3, [r3, #8]
 8003420:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003424:	d1f5      	bne.n	8003412 <send_cmd+0x7a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003426:	4b6d      	ldr	r3, [pc, #436]	; (80035dc <send_cmd+0x244>)
 8003428:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 800342a:	4b6c      	ldr	r3, [pc, #432]	; (80035dc <send_cmd+0x244>)
 800342c:	689b      	ldr	r3, [r3, #8]
 800342e:	f013 0f01 	tst.w	r3, #1
 8003432:	d0fa      	beq.n	800342a <send_cmd+0x92>
 8003434:	4b69      	ldr	r3, [pc, #420]	; (80035dc <send_cmd+0x244>)
 8003436:	689b      	ldr	r3, [r3, #8]
 8003438:	f013 0f80 	tst.w	r3, #128	; 0x80
 800343c:	d1f5      	bne.n	800342a <send_cmd+0x92>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 800343e:	4b67      	ldr	r3, [pc, #412]	; (80035dc <send_cmd+0x244>)
 8003440:	68db      	ldr	r3, [r3, #12]
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:236
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 16));		/* Argument[23..16] */
 8003442:	f3c5 4207 	ubfx	r2, r5, #16, #8
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003446:	4b65      	ldr	r3, [pc, #404]	; (80035dc <send_cmd+0x244>)
 8003448:	681b      	ldr	r3, [r3, #0]
 800344a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800344e:	d017      	beq.n	8003480 <send_cmd+0xe8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003450:	4b62      	ldr	r3, [pc, #392]	; (80035dc <send_cmd+0x244>)
 8003452:	689b      	ldr	r3, [r3, #8]
 8003454:	f013 0f02 	tst.w	r3, #2
 8003458:	d0fa      	beq.n	8003450 <send_cmd+0xb8>
 800345a:	4b60      	ldr	r3, [pc, #384]	; (80035dc <send_cmd+0x244>)
 800345c:	689b      	ldr	r3, [r3, #8]
 800345e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003462:	d1f5      	bne.n	8003450 <send_cmd+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003464:	4b5d      	ldr	r3, [pc, #372]	; (80035dc <send_cmd+0x244>)
 8003466:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8003468:	4b5c      	ldr	r3, [pc, #368]	; (80035dc <send_cmd+0x244>)
 800346a:	689b      	ldr	r3, [r3, #8]
 800346c:	f013 0f01 	tst.w	r3, #1
 8003470:	d0fa      	beq.n	8003468 <send_cmd+0xd0>
 8003472:	4b5a      	ldr	r3, [pc, #360]	; (80035dc <send_cmd+0x244>)
 8003474:	689b      	ldr	r3, [r3, #8]
 8003476:	f013 0f80 	tst.w	r3, #128	; 0x80
 800347a:	d1f5      	bne.n	8003468 <send_cmd+0xd0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 800347c:	4b57      	ldr	r3, [pc, #348]	; (80035dc <send_cmd+0x244>)
 800347e:	68db      	ldr	r3, [r3, #12]
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:237
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 8));		/* Argument[15..8] */
 8003480:	f3c5 2207 	ubfx	r2, r5, #8, #8
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003484:	4b55      	ldr	r3, [pc, #340]	; (80035dc <send_cmd+0x244>)
 8003486:	681b      	ldr	r3, [r3, #0]
 8003488:	f013 0f40 	tst.w	r3, #64	; 0x40
 800348c:	d017      	beq.n	80034be <send_cmd+0x126>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 800348e:	4b53      	ldr	r3, [pc, #332]	; (80035dc <send_cmd+0x244>)
 8003490:	689b      	ldr	r3, [r3, #8]
 8003492:	f013 0f02 	tst.w	r3, #2
 8003496:	d0fa      	beq.n	800348e <send_cmd+0xf6>
 8003498:	4b50      	ldr	r3, [pc, #320]	; (80035dc <send_cmd+0x244>)
 800349a:	689b      	ldr	r3, [r3, #8]
 800349c:	f013 0f80 	tst.w	r3, #128	; 0x80
 80034a0:	d1f5      	bne.n	800348e <send_cmd+0xf6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80034a2:	4b4e      	ldr	r3, [pc, #312]	; (80035dc <send_cmd+0x244>)
 80034a4:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80034a6:	4b4d      	ldr	r3, [pc, #308]	; (80035dc <send_cmd+0x244>)
 80034a8:	689b      	ldr	r3, [r3, #8]
 80034aa:	f013 0f01 	tst.w	r3, #1
 80034ae:	d0fa      	beq.n	80034a6 <send_cmd+0x10e>
 80034b0:	4b4a      	ldr	r3, [pc, #296]	; (80035dc <send_cmd+0x244>)
 80034b2:	689b      	ldr	r3, [r3, #8]
 80034b4:	f013 0f80 	tst.w	r3, #128	; 0x80
 80034b8:	d1f5      	bne.n	80034a6 <send_cmd+0x10e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 80034ba:	4b48      	ldr	r3, [pc, #288]	; (80035dc <send_cmd+0x244>)
 80034bc:	68db      	ldr	r3, [r3, #12]
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:238
	TM_SPI_Send(FATFS_SPI, (BYTE)arg);				/* Argument[7..0] */
 80034be:	b2ed      	uxtb	r5, r5
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 80034c0:	4b46      	ldr	r3, [pc, #280]	; (80035dc <send_cmd+0x244>)
 80034c2:	681b      	ldr	r3, [r3, #0]
 80034c4:	f013 0f40 	tst.w	r3, #64	; 0x40
 80034c8:	d017      	beq.n	80034fa <send_cmd+0x162>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 80034ca:	4b44      	ldr	r3, [pc, #272]	; (80035dc <send_cmd+0x244>)
 80034cc:	689b      	ldr	r3, [r3, #8]
 80034ce:	f013 0f02 	tst.w	r3, #2
 80034d2:	d0fa      	beq.n	80034ca <send_cmd+0x132>
 80034d4:	4b41      	ldr	r3, [pc, #260]	; (80035dc <send_cmd+0x244>)
 80034d6:	689b      	ldr	r3, [r3, #8]
 80034d8:	f013 0f80 	tst.w	r3, #128	; 0x80
 80034dc:	d1f5      	bne.n	80034ca <send_cmd+0x132>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80034de:	4b3f      	ldr	r3, [pc, #252]	; (80035dc <send_cmd+0x244>)
 80034e0:	731d      	strb	r5, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80034e2:	4b3e      	ldr	r3, [pc, #248]	; (80035dc <send_cmd+0x244>)
 80034e4:	689b      	ldr	r3, [r3, #8]
 80034e6:	f013 0f01 	tst.w	r3, #1
 80034ea:	d0fa      	beq.n	80034e2 <send_cmd+0x14a>
 80034ec:	4b3b      	ldr	r3, [pc, #236]	; (80035dc <send_cmd+0x244>)
 80034ee:	689b      	ldr	r3, [r3, #8]
 80034f0:	f013 0f80 	tst.w	r3, #128	; 0x80
 80034f4:	d1f5      	bne.n	80034e2 <send_cmd+0x14a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 80034f6:	4b39      	ldr	r3, [pc, #228]	; (80035dc <send_cmd+0x244>)
 80034f8:	68db      	ldr	r3, [r3, #12]
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:240
	n = 0x01;										/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;						/* Valid CRC for CMD0(0) */
 80034fa:	b10c      	cbz	r4, 8003500 <send_cmd+0x168>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:239
	TM_SPI_Send(FATFS_SPI, 0x40 | cmd);				/* Start + command index */
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 24));		/* Argument[31..24] */
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 16));		/* Argument[23..16] */
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 8));		/* Argument[15..8] */
	TM_SPI_Send(FATFS_SPI, (BYTE)arg);				/* Argument[7..0] */
	n = 0x01;										/* Dummy CRC + Stop */
 80034fc:	2201      	movs	r2, #1
 80034fe:	e000      	b.n	8003502 <send_cmd+0x16a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:240
	if (cmd == CMD0) n = 0x95;						/* Valid CRC for CMD0(0) */
 8003500:	2295      	movs	r2, #149	; 0x95
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:241
	if (cmd == CMD8) n = 0x87;						/* Valid CRC for CMD8(0x1AA) */
 8003502:	2c08      	cmp	r4, #8
 8003504:	d100      	bne.n	8003508 <send_cmd+0x170>
 8003506:	2287      	movs	r2, #135	; 0x87
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003508:	4b34      	ldr	r3, [pc, #208]	; (80035dc <send_cmd+0x244>)
 800350a:	681b      	ldr	r3, [r3, #0]
 800350c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003510:	d017      	beq.n	8003542 <send_cmd+0x1aa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003512:	4b32      	ldr	r3, [pc, #200]	; (80035dc <send_cmd+0x244>)
 8003514:	689b      	ldr	r3, [r3, #8]
 8003516:	f013 0f02 	tst.w	r3, #2
 800351a:	d0fa      	beq.n	8003512 <send_cmd+0x17a>
 800351c:	4b2f      	ldr	r3, [pc, #188]	; (80035dc <send_cmd+0x244>)
 800351e:	689b      	ldr	r3, [r3, #8]
 8003520:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003524:	d1f5      	bne.n	8003512 <send_cmd+0x17a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003526:	4b2d      	ldr	r3, [pc, #180]	; (80035dc <send_cmd+0x244>)
 8003528:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 800352a:	4b2c      	ldr	r3, [pc, #176]	; (80035dc <send_cmd+0x244>)
 800352c:	689b      	ldr	r3, [r3, #8]
 800352e:	f013 0f01 	tst.w	r3, #1
 8003532:	d0fa      	beq.n	800352a <send_cmd+0x192>
 8003534:	4b29      	ldr	r3, [pc, #164]	; (80035dc <send_cmd+0x244>)
 8003536:	689b      	ldr	r3, [r3, #8]
 8003538:	f013 0f80 	tst.w	r3, #128	; 0x80
 800353c:	d1f5      	bne.n	800352a <send_cmd+0x192>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 800353e:	4b27      	ldr	r3, [pc, #156]	; (80035dc <send_cmd+0x244>)
 8003540:	68db      	ldr	r3, [r3, #12]
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:245
	TM_SPI_Send(FATFS_SPI, n);

	/* Receive command resp */
	if (cmd == CMD12) {
 8003542:	2c0c      	cmp	r4, #12
 8003544:	d11d      	bne.n	8003582 <send_cmd+0x1ea>
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003546:	4b25      	ldr	r3, [pc, #148]	; (80035dc <send_cmd+0x244>)
 8003548:	681b      	ldr	r3, [r3, #0]
 800354a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800354e:	d018      	beq.n	8003582 <send_cmd+0x1ea>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003550:	4b22      	ldr	r3, [pc, #136]	; (80035dc <send_cmd+0x244>)
 8003552:	689b      	ldr	r3, [r3, #8]
 8003554:	f013 0f02 	tst.w	r3, #2
 8003558:	d0fa      	beq.n	8003550 <send_cmd+0x1b8>
 800355a:	4b20      	ldr	r3, [pc, #128]	; (80035dc <send_cmd+0x244>)
 800355c:	689b      	ldr	r3, [r3, #8]
 800355e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003562:	d1f5      	bne.n	8003550 <send_cmd+0x1b8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003564:	22ff      	movs	r2, #255	; 0xff
 8003566:	4b1d      	ldr	r3, [pc, #116]	; (80035dc <send_cmd+0x244>)
 8003568:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 800356a:	4b1c      	ldr	r3, [pc, #112]	; (80035dc <send_cmd+0x244>)
 800356c:	689b      	ldr	r3, [r3, #8]
 800356e:	f013 0f01 	tst.w	r3, #1
 8003572:	d0fa      	beq.n	800356a <send_cmd+0x1d2>
 8003574:	4b19      	ldr	r3, [pc, #100]	; (80035dc <send_cmd+0x244>)
 8003576:	689b      	ldr	r3, [r3, #8]
 8003578:	f013 0f80 	tst.w	r3, #128	; 0x80
 800357c:	d1f5      	bne.n	800356a <send_cmd+0x1d2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 800357e:	4b17      	ldr	r3, [pc, #92]	; (80035dc <send_cmd+0x244>)
 8003580:	68db      	ldr	r3, [r3, #12]
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:241 (discriminator 2)
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 16));		/* Argument[23..16] */
	TM_SPI_Send(FATFS_SPI, (BYTE)(arg >> 8));		/* Argument[15..8] */
	TM_SPI_Send(FATFS_SPI, (BYTE)arg);				/* Argument[7..0] */
	n = 0x01;										/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;						/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;						/* Valid CRC for CMD8(0x1AA) */
 8003582:	220a      	movs	r2, #10
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398 (discriminator 2)
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003584:	4b15      	ldr	r3, [pc, #84]	; (80035dc <send_cmd+0x244>)
 8003586:	681b      	ldr	r3, [r3, #0]
 8003588:	f013 0f40 	tst.w	r3, #64	; 0x40
 800358c:	d01a      	beq.n	80035c4 <send_cmd+0x22c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 800358e:	4b13      	ldr	r3, [pc, #76]	; (80035dc <send_cmd+0x244>)
 8003590:	689b      	ldr	r3, [r3, #8]
 8003592:	f013 0f02 	tst.w	r3, #2
 8003596:	d0fa      	beq.n	800358e <send_cmd+0x1f6>
 8003598:	4b10      	ldr	r3, [pc, #64]	; (80035dc <send_cmd+0x244>)
 800359a:	689b      	ldr	r3, [r3, #8]
 800359c:	f013 0f80 	tst.w	r3, #128	; 0x80
 80035a0:	d1f5      	bne.n	800358e <send_cmd+0x1f6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80035a2:	21ff      	movs	r1, #255	; 0xff
 80035a4:	4b0d      	ldr	r3, [pc, #52]	; (80035dc <send_cmd+0x244>)
 80035a6:	7319      	strb	r1, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80035a8:	4b0c      	ldr	r3, [pc, #48]	; (80035dc <send_cmd+0x244>)
 80035aa:	689b      	ldr	r3, [r3, #8]
 80035ac:	f013 0f01 	tst.w	r3, #1
 80035b0:	d0fa      	beq.n	80035a8 <send_cmd+0x210>
 80035b2:	4b0a      	ldr	r3, [pc, #40]	; (80035dc <send_cmd+0x244>)
 80035b4:	689b      	ldr	r3, [r3, #8]
 80035b6:	f013 0f80 	tst.w	r3, #128	; 0x80
 80035ba:	d1f5      	bne.n	80035a8 <send_cmd+0x210>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 80035bc:	4b07      	ldr	r3, [pc, #28]	; (80035dc <send_cmd+0x244>)
 80035be:	68d8      	ldr	r0, [r3, #12]
 80035c0:	b2c0      	uxtb	r0, r0
 80035c2:	e000      	b.n	80035c6 <send_cmd+0x22e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 80035c4:	2000      	movs	r0, #0
send_cmd():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:252
	}
	
	n = 10;								/* Wait for response (10 bytes max) */
	do {
		res = TM_SPI_Send(FATFS_SPI, 0xFF);
	} while ((res & 0x80) && --n);
 80035c6:	f010 0f80 	tst.w	r0, #128	; 0x80
 80035ca:	d005      	beq.n	80035d8 <send_cmd+0x240>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:252 (discriminator 1)
 80035cc:	1e53      	subs	r3, r2, #1
 80035ce:	f013 02ff 	ands.w	r2, r3, #255	; 0xff
 80035d2:	d1d7      	bne.n	8003584 <send_cmd+0x1ec>
 80035d4:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:230
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
		deselect();
		if (!select()) return 0xFF;
 80035d6:	20ff      	movs	r0, #255	; 0xff
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:255
	do {
		res = TM_SPI_Send(FATFS_SPI, 0xFF);
	} while ((res & 0x80) && --n);

	return res;							/* Return received response */
}
 80035d8:	bd38      	pop	{r3, r4, r5, pc}
 80035da:	bf00      	nop
 80035dc:	40003800 	.word	0x40003800

080035e0 <TM_FATFS_InitPins>:
TM_FATFS_InitPins():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:257

void TM_FATFS_InitPins(void) {
 80035e0:	b500      	push	{lr}
 80035e2:	b083      	sub	sp, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:259
	/* CS pin */
	TM_GPIO_Init(FATFS_CS_PORT, FATFS_CS_PIN, TM_GPIO_Mode_OUT, TM_GPIO_OType_PP, TM_GPIO_PuPd_UP, TM_GPIO_Speed_Low);
 80035e4:	2300      	movs	r3, #0
 80035e6:	9301      	str	r3, [sp, #4]
 80035e8:	2201      	movs	r2, #1
 80035ea:	9200      	str	r2, [sp, #0]
 80035ec:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80035f0:	4802      	ldr	r0, [pc, #8]	; (80035fc <TM_FATFS_InitPins+0x1c>)
 80035f2:	f002 f98b 	bl	800590c <TM_GPIO_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:270

	/* Write protect pin */
#if FATFS_USE_WRITEPROTECT_PIN > 0
	TM_GPIO_Init(FATFS_WRITEPROTECT_PORT, FATFS_WRITEPROTECT_PIN, TM_GPIO_Mode_IN, TM_GPIO_OType_PP, TM_GPIO_PuPd_UP, TM_GPIO_Speed_Low);
#endif
}
 80035f6:	b003      	add	sp, #12
 80035f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80035fc:	40021000 	.word	0x40021000

08003600 <TM_FATFS_SD_disk_initialize>:
TM_FATFS_SD_disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:272

DSTATUS TM_FATFS_SD_disk_initialize (void) {
 8003600:	b530      	push	{r4, r5, lr}
 8003602:	b083      	sub	sp, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:276
	BYTE n, cmd, ty, ocr[4];
	
	//Initialize CS pin
	TM_FATFS_InitPins();
 8003604:	f7ff ffec 	bl	80035e0 <TM_FATFS_InitPins>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:277
	init_spi();
 8003608:	f7ff fd02 	bl	8003010 <init_spi>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:279
	
	if (!SDCARD_IsDetected()) {
 800360c:	f7ff fcfc 	bl	8003008 <SDCARD_IsDetected>
 8003610:	2800      	cmp	r0, #0
 8003612:	f000 80de 	beq.w	80037d2 <TM_FATFS_SD_disk_initialize+0x1d2>
 8003616:	240a      	movs	r4, #10
 8003618:	e01f      	b.n	800365a <TM_FATFS_SD_disk_initialize+0x5a>
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 800361a:	4b6f      	ldr	r3, [pc, #444]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 800361c:	681b      	ldr	r3, [r3, #0]
 800361e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003622:	d018      	beq.n	8003656 <TM_FATFS_SD_disk_initialize+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003624:	4b6c      	ldr	r3, [pc, #432]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 8003626:	689b      	ldr	r3, [r3, #8]
 8003628:	f013 0f02 	tst.w	r3, #2
 800362c:	d0fa      	beq.n	8003624 <TM_FATFS_SD_disk_initialize+0x24>
 800362e:	4b6a      	ldr	r3, [pc, #424]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 8003630:	689b      	ldr	r3, [r3, #8]
 8003632:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003636:	d1f5      	bne.n	8003624 <TM_FATFS_SD_disk_initialize+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003638:	22ff      	movs	r2, #255	; 0xff
 800363a:	4b67      	ldr	r3, [pc, #412]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 800363c:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 800363e:	4b66      	ldr	r3, [pc, #408]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 8003640:	689b      	ldr	r3, [r3, #8]
 8003642:	f013 0f01 	tst.w	r3, #1
 8003646:	d0fa      	beq.n	800363e <TM_FATFS_SD_disk_initialize+0x3e>
 8003648:	4b63      	ldr	r3, [pc, #396]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 800364a:	689b      	ldr	r3, [r3, #8]
 800364c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003650:	d1f5      	bne.n	800363e <TM_FATFS_SD_disk_initialize+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003652:	4b61      	ldr	r3, [pc, #388]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 8003654:	68db      	ldr	r3, [r3, #12]
TM_FATFS_SD_disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:283
		return STA_NODISK;
	}
	
	for (n = 10; n; n--) {
 8003656:	3c01      	subs	r4, #1
 8003658:	b2e4      	uxtb	r4, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:283 (discriminator 1)
 800365a:	2c00      	cmp	r4, #0
 800365c:	d1dd      	bne.n	800361a <TM_FATFS_SD_disk_initialize+0x1a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:287
		TM_SPI_Send(FATFS_SPI, 0xFF);
	}
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {				/* Put the card SPI/Idle state */
 800365e:	2100      	movs	r1, #0
 8003660:	4608      	mov	r0, r1
 8003662:	f7ff fe99 	bl	8003398 <send_cmd>
 8003666:	2801      	cmp	r0, #1
 8003668:	f040 8086 	bne.w	8003778 <TM_FATFS_SD_disk_initialize+0x178>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:288
		TM_DELAY_SetTime2(1000);				/* Initialization timeout = 1 sec */
 800366c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8003670:	4b5a      	ldr	r3, [pc, #360]	; (80037dc <TM_FATFS_SD_disk_initialize+0x1dc>)
 8003672:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:289
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 8003674:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8003678:	2008      	movs	r0, #8
 800367a:	f7ff fe8d 	bl	8003398 <send_cmd>
 800367e:	2801      	cmp	r0, #1
 8003680:	d15c      	bne.n	800373c <TM_FATFS_SD_disk_initialize+0x13c>
 8003682:	e028      	b.n	80036d6 <TM_FATFS_SD_disk_initialize+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:291 (discriminator 3)
			for (n = 0; n < 4; n++) {
				ocr[n] = TM_SPI_Send(FATFS_SPI, 0xFF);	/* Get 32 bit return value of R7 resp */
 8003684:	4611      	mov	r1, r2
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398 (discriminator 3)
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003686:	4b54      	ldr	r3, [pc, #336]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 8003688:	681b      	ldr	r3, [r3, #0]
 800368a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800368e:	d01a      	beq.n	80036c6 <TM_FATFS_SD_disk_initialize+0xc6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003690:	4b51      	ldr	r3, [pc, #324]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 8003692:	689b      	ldr	r3, [r3, #8]
 8003694:	f013 0f02 	tst.w	r3, #2
 8003698:	d0fa      	beq.n	8003690 <TM_FATFS_SD_disk_initialize+0x90>
 800369a:	4b4f      	ldr	r3, [pc, #316]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 800369c:	689b      	ldr	r3, [r3, #8]
 800369e:	f013 0f80 	tst.w	r3, #128	; 0x80
 80036a2:	d1f5      	bne.n	8003690 <TM_FATFS_SD_disk_initialize+0x90>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 80036a4:	20ff      	movs	r0, #255	; 0xff
 80036a6:	4b4c      	ldr	r3, [pc, #304]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 80036a8:	7318      	strb	r0, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 80036aa:	4b4b      	ldr	r3, [pc, #300]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 80036ac:	689b      	ldr	r3, [r3, #8]
 80036ae:	f013 0f01 	tst.w	r3, #1
 80036b2:	d0fa      	beq.n	80036aa <TM_FATFS_SD_disk_initialize+0xaa>
 80036b4:	4b48      	ldr	r3, [pc, #288]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 80036b6:	689b      	ldr	r3, [r3, #8]
 80036b8:	f013 0f80 	tst.w	r3, #128	; 0x80
 80036bc:	d1f5      	bne.n	80036aa <TM_FATFS_SD_disk_initialize+0xaa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 80036be:	4b46      	ldr	r3, [pc, #280]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 80036c0:	68db      	ldr	r3, [r3, #12]
 80036c2:	b2db      	uxtb	r3, r3
 80036c4:	e000      	b.n	80036c8 <TM_FATFS_SD_disk_initialize+0xc8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 80036c6:	2300      	movs	r3, #0
TM_FATFS_SD_disk_initialize():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:291
 80036c8:	a802      	add	r0, sp, #8
 80036ca:	4401      	add	r1, r0
 80036cc:	f801 3c04 	strb.w	r3, [r1, #-4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:290
	}
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {				/* Put the card SPI/Idle state */
		TM_DELAY_SetTime2(1000);				/* Initialization timeout = 1 sec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) {
 80036d0:	3201      	adds	r2, #1
 80036d2:	b2d2      	uxtb	r2, r2
 80036d4:	e000      	b.n	80036d8 <TM_FATFS_SD_disk_initialize+0xd8>
 80036d6:	4622      	mov	r2, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:290 (discriminator 1)
 80036d8:	2a03      	cmp	r2, #3
 80036da:	d9d3      	bls.n	8003684 <TM_FATFS_SD_disk_initialize+0x84>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:293
				ocr[n] = TM_SPI_Send(FATFS_SPI, 0xFF);	/* Get 32 bit return value of R7 resp */
			}
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Is the card supports vcc of 2.7-3.6V? */
 80036dc:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80036e0:	2b01      	cmp	r3, #1
 80036e2:	d14b      	bne.n	800377c <TM_FATFS_SD_disk_initialize+0x17c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:293 (discriminator 1)
 80036e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80036e8:	2baa      	cmp	r3, #170	; 0xaa
 80036ea:	d149      	bne.n	8003780 <TM_FATFS_SD_disk_initialize+0x180>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:294 (discriminator 2)
				while (TM_DELAY_Time2() && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
 80036ec:	4b3b      	ldr	r3, [pc, #236]	; (80037dc <TM_FATFS_SD_disk_initialize+0x1dc>)
 80036ee:	681b      	ldr	r3, [r3, #0]
 80036f0:	b133      	cbz	r3, 8003700 <TM_FATFS_SD_disk_initialize+0x100>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:294 (discriminator 1)
 80036f2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80036f6:	20a9      	movs	r0, #169	; 0xa9
 80036f8:	f7ff fe4e 	bl	8003398 <send_cmd>
 80036fc:	2800      	cmp	r0, #0
 80036fe:	d1f5      	bne.n	80036ec <TM_FATFS_SD_disk_initialize+0xec>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:295
				if (TM_DELAY_Time2() && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 8003700:	4b36      	ldr	r3, [pc, #216]	; (80037dc <TM_FATFS_SD_disk_initialize+0x1dc>)
 8003702:	681b      	ldr	r3, [r3, #0]
 8003704:	2b00      	cmp	r3, #0
 8003706:	d03d      	beq.n	8003784 <TM_FATFS_SD_disk_initialize+0x184>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:295 (discriminator 1)
 8003708:	2100      	movs	r1, #0
 800370a:	203a      	movs	r0, #58	; 0x3a
 800370c:	f7ff fe44 	bl	8003398 <send_cmd>
 8003710:	b158      	cbz	r0, 800372a <TM_FATFS_SD_disk_initialize+0x12a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:286
	}
	
	for (n = 10; n; n--) {
		TM_SPI_Send(FATFS_SPI, 0xFF);
	}
	ty = 0;
 8003712:	2400      	movs	r4, #0
 8003714:	e03d      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:297 (discriminator 3)
			}
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Is the card supports vcc of 2.7-3.6V? */
				while (TM_DELAY_Time2() && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
				if (TM_DELAY_Time2() && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) {
						ocr[n] = TM_SPI_Send(FATFS_SPI, 0xFF);
 8003716:	21ff      	movs	r1, #255	; 0xff
 8003718:	482f      	ldr	r0, [pc, #188]	; (80037d8 <TM_FATFS_SD_disk_initialize+0x1d8>)
 800371a:	f7ff fc5b 	bl	8002fd4 <TM_SPI_Send>
 800371e:	ab02      	add	r3, sp, #8
 8003720:	4423      	add	r3, r4
 8003722:	f803 0c04 	strb.w	r0, [r3, #-4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:296 (discriminator 3)
				ocr[n] = TM_SPI_Send(FATFS_SPI, 0xFF);	/* Get 32 bit return value of R7 resp */
			}
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Is the card supports vcc of 2.7-3.6V? */
				while (TM_DELAY_Time2() && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
				if (TM_DELAY_Time2() && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) {
 8003726:	3401      	adds	r4, #1
 8003728:	b2e4      	uxtb	r4, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:296 (discriminator 1)
 800372a:	2c03      	cmp	r4, #3
 800372c:	d9f3      	bls.n	8003716 <TM_FATFS_SD_disk_initialize+0x116>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:299
						ocr[n] = TM_SPI_Send(FATFS_SPI, 0xFF);
					}
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* Card id SDv2 */
 800372e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8003732:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003736:	d027      	beq.n	8003788 <TM_FATFS_SD_disk_initialize+0x188>
 8003738:	240c      	movs	r4, #12
 800373a:	e02a      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:303
				}
			}
		} else {	/* Not SDv2 card */
			if (send_cmd(ACMD41, 0) <= 1) 	{	/* SDv1 or MMC? */
 800373c:	2100      	movs	r1, #0
 800373e:	20a9      	movs	r0, #169	; 0xa9
 8003740:	f7ff fe2a 	bl	8003398 <send_cmd>
 8003744:	2801      	cmp	r0, #1
 8003746:	d802      	bhi.n	800374e <TM_FATFS_SD_disk_initialize+0x14e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:304
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 (ACMD41(0)) */
 8003748:	2402      	movs	r4, #2
 800374a:	25a9      	movs	r5, #169	; 0xa9
 800374c:	e001      	b.n	8003752 <TM_FATFS_SD_disk_initialize+0x152>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:306
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
 800374e:	2401      	movs	r4, #1
 8003750:	4625      	mov	r5, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:308 (discriminator 2)
			}
			while (TM_DELAY_Time2() && send_cmd(cmd, 0));			/* Wait for end of initialization */
 8003752:	4b22      	ldr	r3, [pc, #136]	; (80037dc <TM_FATFS_SD_disk_initialize+0x1dc>)
 8003754:	681b      	ldr	r3, [r3, #0]
 8003756:	b12b      	cbz	r3, 8003764 <TM_FATFS_SD_disk_initialize+0x164>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:308 (discriminator 1)
 8003758:	2100      	movs	r1, #0
 800375a:	4628      	mov	r0, r5
 800375c:	f7ff fe1c 	bl	8003398 <send_cmd>
 8003760:	2800      	cmp	r0, #0
 8003762:	d1f6      	bne.n	8003752 <TM_FATFS_SD_disk_initialize+0x152>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:309
			if (TM_DELAY_Time2() || send_cmd(CMD16, 512) != 0) {	/* Set block length: 512 */
 8003764:	4b1d      	ldr	r3, [pc, #116]	; (80037dc <TM_FATFS_SD_disk_initialize+0x1dc>)
 8003766:	681b      	ldr	r3, [r3, #0]
 8003768:	b983      	cbnz	r3, 800378c <TM_FATFS_SD_disk_initialize+0x18c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:309 (discriminator 1)
 800376a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800376e:	2010      	movs	r0, #16
 8003770:	f7ff fe12 	bl	8003398 <send_cmd>
 8003774:	b960      	cbnz	r0, 8003790 <TM_FATFS_SD_disk_initialize+0x190>
 8003776:	e00c      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:286
	}
	
	for (n = 10; n; n--) {
		TM_SPI_Send(FATFS_SPI, 0xFF);
	}
	ty = 0;
 8003778:	2400      	movs	r4, #0
 800377a:	e00a      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
 800377c:	2400      	movs	r4, #0
 800377e:	e008      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
 8003780:	2400      	movs	r4, #0
 8003782:	e006      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
 8003784:	2400      	movs	r4, #0
 8003786:	e004      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:299
				while (TM_DELAY_Time2() && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
				if (TM_DELAY_Time2() && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) {
						ocr[n] = TM_SPI_Send(FATFS_SPI, 0xFF);
					}
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* Card id SDv2 */
 8003788:	2404      	movs	r4, #4
 800378a:	e002      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:310
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
			}
			while (TM_DELAY_Time2() && send_cmd(cmd, 0));			/* Wait for end of initialization */
			if (TM_DELAY_Time2() || send_cmd(CMD16, 512) != 0) {	/* Set block length: 512 */
				ty = 0;
 800378c:	2400      	movs	r4, #0
 800378e:	e000      	b.n	8003792 <TM_FATFS_SD_disk_initialize+0x192>
 8003790:	2400      	movs	r4, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:314
			}
		}
	}
	TM_FATFS_SD_CardType = ty;	/* Card type */
 8003792:	4b13      	ldr	r3, [pc, #76]	; (80037e0 <TM_FATFS_SD_disk_initialize+0x1e0>)
 8003794:	701c      	strb	r4, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:315
	deselect();
 8003796:	f7ff fc95 	bl	80030c4 <deselect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:317

	if (ty) {			/* OK */
 800379a:	b12c      	cbz	r4, 80037a8 <TM_FATFS_SD_disk_initialize+0x1a8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:318
		TM_FATFS_SD_Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
 800379c:	4a11      	ldr	r2, [pc, #68]	; (80037e4 <TM_FATFS_SD_disk_initialize+0x1e4>)
 800379e:	7813      	ldrb	r3, [r2, #0]
 80037a0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 80037a4:	7013      	strb	r3, [r2, #0]
 80037a6:	e002      	b.n	80037ae <TM_FATFS_SD_disk_initialize+0x1ae>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:320
	} else {			/* Failed */
		TM_FATFS_SD_Stat = STA_NOINIT;
 80037a8:	2201      	movs	r2, #1
 80037aa:	4b0e      	ldr	r3, [pc, #56]	; (80037e4 <TM_FATFS_SD_disk_initialize+0x1e4>)
 80037ac:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:323
	}

	if (!SDCARD_IsWriteEnabled()) {
 80037ae:	f7ff fc2d 	bl	800300c <SDCARD_IsWriteEnabled>
 80037b2:	b928      	cbnz	r0, 80037c0 <TM_FATFS_SD_disk_initialize+0x1c0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:324
		TM_FATFS_SD_Stat |= STA_PROTECT;
 80037b4:	4a0b      	ldr	r2, [pc, #44]	; (80037e4 <TM_FATFS_SD_disk_initialize+0x1e4>)
 80037b6:	7813      	ldrb	r3, [r2, #0]
 80037b8:	f043 0304 	orr.w	r3, r3, #4
 80037bc:	7013      	strb	r3, [r2, #0]
 80037be:	e004      	b.n	80037ca <TM_FATFS_SD_disk_initialize+0x1ca>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:326
	} else {
		TM_FATFS_SD_Stat &= ~STA_PROTECT;
 80037c0:	4a08      	ldr	r2, [pc, #32]	; (80037e4 <TM_FATFS_SD_disk_initialize+0x1e4>)
 80037c2:	7813      	ldrb	r3, [r2, #0]
 80037c4:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80037c8:	7013      	strb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:329
	}
	
	return TM_FATFS_SD_Stat;
 80037ca:	4b06      	ldr	r3, [pc, #24]	; (80037e4 <TM_FATFS_SD_disk_initialize+0x1e4>)
 80037cc:	7818      	ldrb	r0, [r3, #0]
 80037ce:	b2c0      	uxtb	r0, r0
 80037d0:	e000      	b.n	80037d4 <TM_FATFS_SD_disk_initialize+0x1d4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:280
	//Initialize CS pin
	TM_FATFS_InitPins();
	init_spi();
	
	if (!SDCARD_IsDetected()) {
		return STA_NODISK;
 80037d2:	2002      	movs	r0, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:330
	} else {
		TM_FATFS_SD_Stat &= ~STA_PROTECT;
	}
	
	return TM_FATFS_SD_Stat;
}
 80037d4:	b003      	add	sp, #12
 80037d6:	bd30      	pop	{r4, r5, pc}
 80037d8:	40003800 	.word	0x40003800
 80037dc:	20001af4 	.word	0x20001af4
 80037e0:	20001a34 	.word	0x20001a34
 80037e4:	200000d8 	.word	0x200000d8

080037e8 <TM_FATFS_SD_disk_status>:
TM_FATFS_SD_disk_status():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:338

/*-----------------------------------------------------------------------*/
/* Get Disk Status                                                       */
/*-----------------------------------------------------------------------*/

DSTATUS TM_FATFS_SD_disk_status (void) {
 80037e8:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:340
	/* Check card detect pin if enabled */
	if (!SDCARD_IsDetected()) {
 80037ea:	f7ff fc0d 	bl	8003008 <SDCARD_IsDetected>
 80037ee:	b188      	cbz	r0, 8003814 <TM_FATFS_SD_disk_status+0x2c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:345
		return STA_NOINIT;
	}
	
	/* Check if write is enabled */
	if (!SDCARD_IsWriteEnabled()) {
 80037f0:	f7ff fc0c 	bl	800300c <SDCARD_IsWriteEnabled>
 80037f4:	b928      	cbnz	r0, 8003802 <TM_FATFS_SD_disk_status+0x1a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:346
		TM_FATFS_SD_Stat |= STA_PROTECT;
 80037f6:	4a08      	ldr	r2, [pc, #32]	; (8003818 <TM_FATFS_SD_disk_status+0x30>)
 80037f8:	7813      	ldrb	r3, [r2, #0]
 80037fa:	f043 0304 	orr.w	r3, r3, #4
 80037fe:	7013      	strb	r3, [r2, #0]
 8003800:	e004      	b.n	800380c <TM_FATFS_SD_disk_status+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:348
	} else {
		TM_FATFS_SD_Stat &= ~STA_PROTECT;
 8003802:	4a05      	ldr	r2, [pc, #20]	; (8003818 <TM_FATFS_SD_disk_status+0x30>)
 8003804:	7813      	ldrb	r3, [r2, #0]
 8003806:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 800380a:	7013      	strb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:351
	}
	
	return TM_FATFS_SD_Stat;	/* Return disk status */
 800380c:	4b02      	ldr	r3, [pc, #8]	; (8003818 <TM_FATFS_SD_disk_status+0x30>)
 800380e:	7818      	ldrb	r0, [r3, #0]
 8003810:	b2c0      	uxtb	r0, r0
 8003812:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:341
/*-----------------------------------------------------------------------*/

DSTATUS TM_FATFS_SD_disk_status (void) {
	/* Check card detect pin if enabled */
	if (!SDCARD_IsDetected()) {
		return STA_NOINIT;
 8003814:	2001      	movs	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:352
	} else {
		TM_FATFS_SD_Stat &= ~STA_PROTECT;
	}
	
	return TM_FATFS_SD_Stat;	/* Return disk status */
}
 8003816:	bd08      	pop	{r3, pc}
 8003818:	200000d8 	.word	0x200000d8

0800381c <TM_FATFS_SD_disk_read>:
TM_FATFS_SD_disk_read():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:363
DRESULT TM_FATFS_SD_disk_read (
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	UINT count		/* Number of sectors to read (1..128) */
)
{
 800381c:	b570      	push	{r4, r5, r6, lr}
 800381e:	4605      	mov	r5, r0
 8003820:	460e      	mov	r6, r1
 8003822:	4614      	mov	r4, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:364
	if (!SDCARD_IsDetected() || (TM_FATFS_SD_Stat & STA_NOINIT)) {
 8003824:	f7ff fbf0 	bl	8003008 <SDCARD_IsDetected>
 8003828:	b398      	cbz	r0, 8003892 <TM_FATFS_SD_disk_read+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:364 (discriminator 1)
 800382a:	4b1c      	ldr	r3, [pc, #112]	; (800389c <TM_FATFS_SD_disk_read+0x80>)
 800382c:	781b      	ldrb	r3, [r3, #0]
 800382e:	f013 0f01 	tst.w	r3, #1
 8003832:	d130      	bne.n	8003896 <TM_FATFS_SD_disk_read+0x7a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:368
		return RES_NOTRDY;
	}

	if (!(TM_FATFS_SD_CardType & CT_BLOCK)) {
 8003834:	4b1a      	ldr	r3, [pc, #104]	; (80038a0 <TM_FATFS_SD_disk_read+0x84>)
 8003836:	781b      	ldrb	r3, [r3, #0]
 8003838:	f013 0f08 	tst.w	r3, #8
 800383c:	d100      	bne.n	8003840 <TM_FATFS_SD_disk_read+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:369
		sector *= 512;	/* LBA ot BA conversion (byte addressing cards) */
 800383e:	0276      	lsls	r6, r6, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:372
	}

	if (count == 1) {	/* Single sector read */
 8003840:	2c01      	cmp	r4, #1
 8003842:	d10b      	bne.n	800385c <TM_FATFS_SD_disk_read+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:373
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
 8003844:	4631      	mov	r1, r6
 8003846:	2011      	movs	r0, #17
 8003848:	f7ff fda6 	bl	8003398 <send_cmd>
 800384c:	b9d8      	cbnz	r0, 8003886 <TM_FATFS_SD_disk_read+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:374
			&& rcvr_datablock(buff, 512))
 800384e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8003852:	4628      	mov	r0, r5
 8003854:	f7ff fd2c 	bl	80032b0 <rcvr_datablock>
 8003858:	b9a0      	cbnz	r0, 8003884 <TM_FATFS_SD_disk_read+0x68>
 800385a:	e014      	b.n	8003886 <TM_FATFS_SD_disk_read+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:377
			count = 0;
	} else {				/* Multiple sector read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
 800385c:	4631      	mov	r1, r6
 800385e:	2012      	movs	r0, #18
 8003860:	f7ff fd9a 	bl	8003398 <send_cmd>
 8003864:	b978      	cbnz	r0, 8003886 <TM_FATFS_SD_disk_read+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:379
			do {
				if (!rcvr_datablock(buff, 512)) {
 8003866:	f44f 7100 	mov.w	r1, #512	; 0x200
 800386a:	4628      	mov	r0, r5
 800386c:	f7ff fd20 	bl	80032b0 <rcvr_datablock>
 8003870:	b118      	cbz	r0, 800387a <TM_FATFS_SD_disk_read+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:382
					break;
				}
				buff += 512;
 8003872:	f505 7500 	add.w	r5, r5, #512	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:383
			} while (--count);
 8003876:	3c01      	subs	r4, #1
 8003878:	d1f5      	bne.n	8003866 <TM_FATFS_SD_disk_read+0x4a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:384
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
 800387a:	2100      	movs	r1, #0
 800387c:	200c      	movs	r0, #12
 800387e:	f7ff fd8b 	bl	8003398 <send_cmd>
 8003882:	e000      	b.n	8003886 <TM_FATFS_SD_disk_read+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:375
	}

	if (count == 1) {	/* Single sector read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
 8003884:	2400      	movs	r4, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:387
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
 8003886:	f7ff fc1d 	bl	80030c4 <deselect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:389

	return count ? RES_ERROR : RES_OK;	/* Return result */
 800388a:	1c20      	adds	r0, r4, #0
 800388c:	bf18      	it	ne
 800388e:	2001      	movne	r0, #1
 8003890:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:365
	DWORD sector,	/* Sector address (LBA) */
	UINT count		/* Number of sectors to read (1..128) */
)
{
	if (!SDCARD_IsDetected() || (TM_FATFS_SD_Stat & STA_NOINIT)) {
		return RES_NOTRDY;
 8003892:	2003      	movs	r0, #3
 8003894:	bd70      	pop	{r4, r5, r6, pc}
 8003896:	2003      	movs	r0, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:390
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;	/* Return result */
}
 8003898:	bd70      	pop	{r4, r5, r6, pc}
 800389a:	bf00      	nop
 800389c:	200000d8 	.word	0x200000d8
 80038a0:	20001a34 	.word	0x20001a34

080038a4 <TM_FATFS_SD_disk_write>:
TM_FATFS_SD_disk_write():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:404
DRESULT TM_FATFS_SD_disk_write (
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address (LBA) */
	UINT count			/* Number of sectors to write (1..128) */
)
{
 80038a4:	b570      	push	{r4, r5, r6, lr}
 80038a6:	4605      	mov	r5, r0
 80038a8:	460e      	mov	r6, r1
 80038aa:	4614      	mov	r4, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:405
	if (!SDCARD_IsDetected()) {
 80038ac:	f7ff fbac 	bl	8003008 <SDCARD_IsDetected>
 80038b0:	2800      	cmp	r0, #0
 80038b2:	d044      	beq.n	800393e <TM_FATFS_SD_disk_write+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:408
		return RES_ERROR;
	}
	if (!SDCARD_IsWriteEnabled()) {
 80038b4:	f7ff fbaa 	bl	800300c <SDCARD_IsWriteEnabled>
 80038b8:	2800      	cmp	r0, #0
 80038ba:	d042      	beq.n	8003942 <TM_FATFS_SD_disk_write+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:411
		return RES_WRPRT;
	}
	if (TM_FATFS_SD_Stat & STA_NOINIT) {
 80038bc:	4b24      	ldr	r3, [pc, #144]	; (8003950 <TM_FATFS_SD_disk_write+0xac>)
 80038be:	781b      	ldrb	r3, [r3, #0]
 80038c0:	f013 0f01 	tst.w	r3, #1
 80038c4:	d13f      	bne.n	8003946 <TM_FATFS_SD_disk_write+0xa2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:414
		return RES_NOTRDY;	/* Check drive status */
	}
	if (TM_FATFS_SD_Stat & STA_PROTECT) {
 80038c6:	4b22      	ldr	r3, [pc, #136]	; (8003950 <TM_FATFS_SD_disk_write+0xac>)
 80038c8:	781b      	ldrb	r3, [r3, #0]
 80038ca:	f013 0f04 	tst.w	r3, #4
 80038ce:	d13c      	bne.n	800394a <TM_FATFS_SD_disk_write+0xa6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:418
		return RES_WRPRT;	/* Check write protect */
	}

	if (!(TM_FATFS_SD_CardType & CT_BLOCK)) {
 80038d0:	4b20      	ldr	r3, [pc, #128]	; (8003954 <TM_FATFS_SD_disk_write+0xb0>)
 80038d2:	781b      	ldrb	r3, [r3, #0]
 80038d4:	f013 0f08 	tst.w	r3, #8
 80038d8:	d100      	bne.n	80038dc <TM_FATFS_SD_disk_write+0x38>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:419
		sector *= 512;	/* LBA ==> BA conversion (byte addressing cards) */
 80038da:	0276      	lsls	r6, r6, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:422
	}

	if (count == 1) {	/* Single sector write */
 80038dc:	2c01      	cmp	r4, #1
 80038de:	d10a      	bne.n	80038f6 <TM_FATFS_SD_disk_write+0x52>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:423
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
 80038e0:	4631      	mov	r1, r6
 80038e2:	2018      	movs	r0, #24
 80038e4:	f7ff fd58 	bl	8003398 <send_cmd>
 80038e8:	bb18      	cbnz	r0, 8003932 <TM_FATFS_SD_disk_write+0x8e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:424
			&& xmit_datablock(buff, 0xFE))
 80038ea:	21fe      	movs	r1, #254	; 0xfe
 80038ec:	4628      	mov	r0, r5
 80038ee:	f7ff fc45 	bl	800317c <xmit_datablock>
 80038f2:	b9d8      	cbnz	r0, 800392c <TM_FATFS_SD_disk_write+0x88>
 80038f4:	e01d      	b.n	8003932 <TM_FATFS_SD_disk_write+0x8e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:427
			count = 0;
	} else {				/* Multiple sector write */
		if (TM_FATFS_SD_CardType & CT_SDC) send_cmd(ACMD23, count);	/* Predefine number of sectors */
 80038f6:	f013 0f06 	tst.w	r3, #6
 80038fa:	d003      	beq.n	8003904 <TM_FATFS_SD_disk_write+0x60>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:427 (discriminator 1)
 80038fc:	4621      	mov	r1, r4
 80038fe:	2097      	movs	r0, #151	; 0x97
 8003900:	f7ff fd4a 	bl	8003398 <send_cmd>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:428
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
 8003904:	4631      	mov	r1, r6
 8003906:	2019      	movs	r0, #25
 8003908:	f7ff fd46 	bl	8003398 <send_cmd>
 800390c:	b988      	cbnz	r0, 8003932 <TM_FATFS_SD_disk_write+0x8e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:430
			do {
				if (!xmit_datablock(buff, 0xFC)) {
 800390e:	21fc      	movs	r1, #252	; 0xfc
 8003910:	4628      	mov	r0, r5
 8003912:	f7ff fc33 	bl	800317c <xmit_datablock>
 8003916:	b118      	cbz	r0, 8003920 <TM_FATFS_SD_disk_write+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:433
					break;
				}
				buff += 512;
 8003918:	f505 7500 	add.w	r5, r5, #512	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:434
			} while (--count);
 800391c:	3c01      	subs	r4, #1
 800391e:	d1f6      	bne.n	800390e <TM_FATFS_SD_disk_write+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:435
			if (!xmit_datablock(0, 0xFD)) {	/* STOP_TRAN token */
 8003920:	21fd      	movs	r1, #253	; 0xfd
 8003922:	2000      	movs	r0, #0
 8003924:	f7ff fc2a 	bl	800317c <xmit_datablock>
 8003928:	b110      	cbz	r0, 8003930 <TM_FATFS_SD_disk_write+0x8c>
 800392a:	e002      	b.n	8003932 <TM_FATFS_SD_disk_write+0x8e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:425
	}

	if (count == 1) {	/* Single sector write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
 800392c:	2400      	movs	r4, #0
 800392e:	e000      	b.n	8003932 <TM_FATFS_SD_disk_write+0x8e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:436
					break;
				}
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD)) {	/* STOP_TRAN token */
				count = 1;
 8003930:	2401      	movs	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:440
			}
		}
	}
	deselect();
 8003932:	f7ff fbc7 	bl	80030c4 <deselect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:442

	return count ? RES_ERROR : RES_OK;	/* Return result */
 8003936:	1c20      	adds	r0, r4, #0
 8003938:	bf18      	it	ne
 800393a:	2001      	movne	r0, #1
 800393c:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:406
	DWORD sector,		/* Sector address (LBA) */
	UINT count			/* Number of sectors to write (1..128) */
)
{
	if (!SDCARD_IsDetected()) {
		return RES_ERROR;
 800393e:	2001      	movs	r0, #1
 8003940:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:409
	}
	if (!SDCARD_IsWriteEnabled()) {
		return RES_WRPRT;
 8003942:	2002      	movs	r0, #2
 8003944:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:412
	}
	if (TM_FATFS_SD_Stat & STA_NOINIT) {
		return RES_NOTRDY;	/* Check drive status */
 8003946:	2003      	movs	r0, #3
 8003948:	bd70      	pop	{r4, r5, r6, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:415
	}
	if (TM_FATFS_SD_Stat & STA_PROTECT) {
		return RES_WRPRT;	/* Check write protect */
 800394a:	2002      	movs	r0, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:443
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;	/* Return result */
}
 800394c:	bd70      	pop	{r4, r5, r6, pc}
 800394e:	bf00      	nop
 8003950:	200000d8 	.word	0x200000d8
 8003954:	20001a34 	.word	0x20001a34

08003958 <TM_FATFS_SD_disk_ioctl>:
TM_FATFS_SD_disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:461
{
	DRESULT res;
	BYTE n, csd[16];
	DWORD *dp, st, ed, csize;

	if (TM_FATFS_SD_Stat & STA_NOINIT) {
 8003958:	4ba6      	ldr	r3, [pc, #664]	; (8003bf4 <TM_FATFS_SD_disk_ioctl+0x29c>)
 800395a:	781b      	ldrb	r3, [r3, #0]
 800395c:	f013 0f01 	tst.w	r3, #1
 8003960:	f040 8143 	bne.w	8003bea <TM_FATFS_SD_disk_ioctl+0x292>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:456
#if _USE_IOCTL
DRESULT TM_FATFS_SD_disk_ioctl (
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 8003964:	b530      	push	{r4, r5, lr}
 8003966:	b085      	sub	sp, #20
 8003968:	460d      	mov	r5, r1
 800396a:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:464
	DWORD *dp, st, ed, csize;

	if (TM_FATFS_SD_Stat & STA_NOINIT) {
		return RES_NOTRDY;	/* Check if drive is ready */
	}
	if (!SDCARD_IsDetected()) {
 800396c:	f7ff fb4c 	bl	8003008 <SDCARD_IsDetected>
 8003970:	2800      	cmp	r0, #0
 8003972:	f000 813c 	beq.w	8003bee <TM_FATFS_SD_disk_ioctl+0x296>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:470
		return RES_NOTRDY;
	}

	res = RES_ERROR;

	switch (cmd) {
 8003976:	2c04      	cmp	r4, #4
 8003978:	f200 8118 	bhi.w	8003bac <TM_FATFS_SD_disk_ioctl+0x254>
 800397c:	e8df f014 	tbh	[pc, r4, lsl #1]
 8003980:	000c0005 	.word	0x000c0005
 8003984:	00540116 	.word	0x00540116
 8003988:	00e5      	.short	0x00e5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:472
	case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
		if (select()) res = RES_OK;
 800398a:	f7ff fbc3 	bl	8003114 <select>
 800398e:	2800      	cmp	r0, #0
 8003990:	f040 810e 	bne.w	8003bb0 <TM_FATFS_SD_disk_ioctl+0x258>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:468
	}
	if (!SDCARD_IsDetected()) {
		return RES_NOTRDY;
	}

	res = RES_ERROR;
 8003994:	2401      	movs	r4, #1
 8003996:	e124      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:476
	case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
		if (select()) res = RES_OK;
		break;

	case GET_SECTOR_COUNT :	/* Get drive capacity in unit of sector (DWORD) */
		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
 8003998:	2100      	movs	r1, #0
 800399a:	2009      	movs	r0, #9
 800399c:	f7ff fcfc 	bl	8003398 <send_cmd>
 80039a0:	2800      	cmp	r0, #0
 80039a2:	f040 8107 	bne.w	8003bb4 <TM_FATFS_SD_disk_ioctl+0x25c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:476 (discriminator 1)
 80039a6:	2110      	movs	r1, #16
 80039a8:	4668      	mov	r0, sp
 80039aa:	f7ff fc81 	bl	80032b0 <rcvr_datablock>
 80039ae:	2800      	cmp	r0, #0
 80039b0:	f000 8102 	beq.w	8003bb8 <TM_FATFS_SD_disk_ioctl+0x260>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:477
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
 80039b4:	f89d 3000 	ldrb.w	r3, [sp]
 80039b8:	099b      	lsrs	r3, r3, #6
 80039ba:	2b01      	cmp	r3, #1
 80039bc:	d110      	bne.n	80039e0 <TM_FATFS_SD_disk_ioctl+0x88>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:478
				csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
 80039be:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80039c2:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80039c6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80039ca:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80039ce:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80039d2:	eb03 4302 	add.w	r3, r3, r2, lsl #16
 80039d6:	3301      	adds	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:479
				*(DWORD*)buff = csize << 10;
 80039d8:	029b      	lsls	r3, r3, #10
 80039da:	602b      	str	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:485
			} else {					/* SDC ver 1.XX or MMC ver 3 */
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
				*(DWORD*)buff = csize << (n - 9);
			}
			res = RES_OK;
 80039dc:	2400      	movs	r4, #0
 80039de:	e100      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:481
		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
				csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
				*(DWORD*)buff = csize << 10;
			} else {					/* SDC ver 1.XX or MMC ver 3 */
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 80039e0:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80039e4:	f89d 100a 	ldrb.w	r1, [sp, #10]
 80039e8:	f89d 2009 	ldrb.w	r2, [sp, #9]
 80039ec:	f003 030f 	and.w	r3, r3, #15
 80039f0:	eb03 13d1 	add.w	r3, r3, r1, lsr #7
 80039f4:	f002 0203 	and.w	r2, r2, #3
 80039f8:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80039fc:	3302      	adds	r3, #2
 80039fe:	b2db      	uxtb	r3, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:482
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8003a00:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8003a04:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003a08:	0092      	lsls	r2, r2, #2
 8003a0a:	eb02 1291 	add.w	r2, r2, r1, lsr #6
 8003a0e:	f89d 1006 	ldrb.w	r1, [sp, #6]
 8003a12:	f001 0103 	and.w	r1, r1, #3
 8003a16:	eb02 2281 	add.w	r2, r2, r1, lsl #10
 8003a1a:	3201      	adds	r2, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:483
				*(DWORD*)buff = csize << (n - 9);
 8003a1c:	3b09      	subs	r3, #9
 8003a1e:	fa02 f303 	lsl.w	r3, r2, r3
 8003a22:	602b      	str	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:485
			}
			res = RES_OK;
 8003a24:	2400      	movs	r4, #0
 8003a26:	e0dc      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:490
		}
		break;

	case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
		if (TM_FATFS_SD_CardType & CT_SD2) {	/* SDC ver 2.00 */
 8003a28:	4b73      	ldr	r3, [pc, #460]	; (8003bf8 <TM_FATFS_SD_disk_ioctl+0x2a0>)
 8003a2a:	781b      	ldrb	r3, [r3, #0]
 8003a2c:	f013 0f04 	tst.w	r3, #4
 8003a30:	d057      	beq.n	8003ae2 <TM_FATFS_SD_disk_ioctl+0x18a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:491
			if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
 8003a32:	2100      	movs	r1, #0
 8003a34:	208d      	movs	r0, #141	; 0x8d
 8003a36:	f7ff fcaf 	bl	8003398 <send_cmd>
 8003a3a:	2800      	cmp	r0, #0
 8003a3c:	f040 80be 	bne.w	8003bbc <TM_FATFS_SD_disk_ioctl+0x264>
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 8003a40:	4b6e      	ldr	r3, [pc, #440]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a42:	681b      	ldr	r3, [r3, #0]
 8003a44:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003a48:	d018      	beq.n	8003a7c <TM_FATFS_SD_disk_ioctl+0x124>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003a4a:	4b6c      	ldr	r3, [pc, #432]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a4c:	689b      	ldr	r3, [r3, #8]
 8003a4e:	f013 0f02 	tst.w	r3, #2
 8003a52:	d0fa      	beq.n	8003a4a <TM_FATFS_SD_disk_ioctl+0xf2>
 8003a54:	4b69      	ldr	r3, [pc, #420]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a56:	689b      	ldr	r3, [r3, #8]
 8003a58:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003a5c:	d1f5      	bne.n	8003a4a <TM_FATFS_SD_disk_ioctl+0xf2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003a5e:	22ff      	movs	r2, #255	; 0xff
 8003a60:	4b66      	ldr	r3, [pc, #408]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a62:	731a      	strb	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8003a64:	4b65      	ldr	r3, [pc, #404]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a66:	689b      	ldr	r3, [r3, #8]
 8003a68:	f013 0f01 	tst.w	r3, #1
 8003a6c:	d0fa      	beq.n	8003a64 <TM_FATFS_SD_disk_ioctl+0x10c>
 8003a6e:	4b63      	ldr	r3, [pc, #396]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a70:	689b      	ldr	r3, [r3, #8]
 8003a72:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003a76:	d1f5      	bne.n	8003a64 <TM_FATFS_SD_disk_ioctl+0x10c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003a78:	4b60      	ldr	r3, [pc, #384]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a7a:	68db      	ldr	r3, [r3, #12]
TM_FATFS_SD_disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:493
				TM_SPI_Send(FATFS_SPI, 0xFF);
				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
 8003a7c:	2110      	movs	r1, #16
 8003a7e:	4668      	mov	r0, sp
 8003a80:	f7ff fc16 	bl	80032b0 <rcvr_datablock>
 8003a84:	bb10      	cbnz	r0, 8003acc <TM_FATFS_SD_disk_ioctl+0x174>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:468
	}
	if (!SDCARD_IsDetected()) {
		return RES_NOTRDY;
	}

	res = RES_ERROR;
 8003a86:	2401      	movs	r4, #1
 8003a88:	e0ab      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
TM_SPI_Send():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:398
 * @param  data: 8-bit data size to send over SPI
 * @retval Received byte from slave device
 */
static __INLINE uint8_t TM_SPI_Send(SPI_TypeDef* SPIx, uint8_t data) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED_RESP(SPIx, 0);
 8003a8a:	4b5c      	ldr	r3, [pc, #368]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a8c:	681b      	ldr	r3, [r3, #0]
 8003a8e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003a92:	d018      	beq.n	8003ac6 <TM_FATFS_SD_disk_ioctl+0x16e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:401
	
	/* Wait for previous transmissions to complete if DMA TX enabled for SPI */
	SPI_WAIT_TX(SPIx);
 8003a94:	4b59      	ldr	r3, [pc, #356]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003a96:	689b      	ldr	r3, [r3, #8]
 8003a98:	f013 0f02 	tst.w	r3, #2
 8003a9c:	d0fa      	beq.n	8003a94 <TM_FATFS_SD_disk_ioctl+0x13c>
 8003a9e:	4b57      	ldr	r3, [pc, #348]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003aa0:	689b      	ldr	r3, [r3, #8]
 8003aa2:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003aa6:	d1f5      	bne.n	8003a94 <TM_FATFS_SD_disk_ioctl+0x13c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:404
	
	/* Fill output buffer with data */
	*(__IO uint8_t *)&SPIx->DR = data;
 8003aa8:	21ff      	movs	r1, #255	; 0xff
 8003aaa:	4b54      	ldr	r3, [pc, #336]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003aac:	7319      	strb	r1, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:407
	
	/* Wait for transmission to complete */
	SPI_WAIT_RX(SPIx);
 8003aae:	4b53      	ldr	r3, [pc, #332]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003ab0:	689b      	ldr	r3, [r3, #8]
 8003ab2:	f013 0f01 	tst.w	r3, #1
 8003ab6:	d0fa      	beq.n	8003aae <TM_FATFS_SD_disk_ioctl+0x156>
 8003ab8:	4b50      	ldr	r3, [pc, #320]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003aba:	689b      	ldr	r3, [r3, #8]
 8003abc:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003ac0:	d1f5      	bne.n	8003aae <TM_FATFS_SD_disk_ioctl+0x156>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/tm_stm32_spi.h:410
	
	/* Return data from buffer */
	return SPIx->DR;
 8003ac2:	4b4e      	ldr	r3, [pc, #312]	; (8003bfc <TM_FATFS_SD_disk_ioctl+0x2a4>)
 8003ac4:	68db      	ldr	r3, [r3, #12]
TM_FATFS_SD_disk_ioctl():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:494
	case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
		if (TM_FATFS_SD_CardType & CT_SD2) {	/* SDC ver 2.00 */
			if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
				TM_SPI_Send(FATFS_SPI, 0xFF);
				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
					for (n = 64 - 16; n; n--) TM_SPI_Send(FATFS_SPI, 0xFF);	/* Purge trailing data */
 8003ac6:	3a01      	subs	r2, #1
 8003ac8:	b2d2      	uxtb	r2, r2
 8003aca:	e000      	b.n	8003ace <TM_FATFS_SD_disk_ioctl+0x176>
 8003acc:	2230      	movs	r2, #48	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:494 (discriminator 1)
 8003ace:	2a00      	cmp	r2, #0
 8003ad0:	d1db      	bne.n	8003a8a <TM_FATFS_SD_disk_ioctl+0x132>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:495
					*(DWORD*)buff = 16UL << (csd[10] >> 4);
 8003ad2:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8003ad6:	091a      	lsrs	r2, r3, #4
 8003ad8:	2310      	movs	r3, #16
 8003ada:	4093      	lsls	r3, r2
 8003adc:	602b      	str	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:496
					res = RES_OK;
 8003ade:	2400      	movs	r4, #0
 8003ae0:	e07f      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:500
				}
			}
		} else {					/* SDC ver 1.XX or MMC */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
 8003ae2:	2100      	movs	r1, #0
 8003ae4:	2009      	movs	r0, #9
 8003ae6:	f7ff fc57 	bl	8003398 <send_cmd>
 8003aea:	2800      	cmp	r0, #0
 8003aec:	d168      	bne.n	8003bc0 <TM_FATFS_SD_disk_ioctl+0x268>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:500 (discriminator 1)
 8003aee:	2110      	movs	r1, #16
 8003af0:	4668      	mov	r0, sp
 8003af2:	f7ff fbdd 	bl	80032b0 <rcvr_datablock>
 8003af6:	2800      	cmp	r0, #0
 8003af8:	d064      	beq.n	8003bc4 <TM_FATFS_SD_disk_ioctl+0x26c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:501
				if (TM_FATFS_SD_CardType & CT_SD1) {	/* SDC ver 1.XX */
 8003afa:	4b3f      	ldr	r3, [pc, #252]	; (8003bf8 <TM_FATFS_SD_disk_ioctl+0x2a0>)
 8003afc:	781b      	ldrb	r3, [r3, #0]
 8003afe:	f013 0f02 	tst.w	r3, #2
 8003b02:	d011      	beq.n	8003b28 <TM_FATFS_SD_disk_ioctl+0x1d0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:502
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
 8003b04:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8003b08:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8003b0c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003b10:	09db      	lsrs	r3, r3, #7
 8003b12:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8003b16:	3301      	adds	r3, #1
 8003b18:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8003b1c:	0992      	lsrs	r2, r2, #6
 8003b1e:	3a01      	subs	r2, #1
 8003b20:	4093      	lsls	r3, r2
 8003b22:	602b      	str	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:506
				} else {					/* MMC */
					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
				}
				res = RES_OK;
 8003b24:	2400      	movs	r4, #0
 8003b26:	e05c      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:504
		} else {					/* SDC ver 1.XX or MMC */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
				if (TM_FATFS_SD_CardType & CT_SD1) {	/* SDC ver 1.XX */
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
				} else {					/* MMC */
					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
 8003b28:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8003b2c:	f3c3 0184 	ubfx	r1, r3, #2, #5
 8003b30:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003b34:	f003 0003 	and.w	r0, r3, #3
 8003b38:	095a      	lsrs	r2, r3, #5
 8003b3a:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 8003b3e:	1c53      	adds	r3, r2, #1
 8003b40:	fb01 3303 	mla	r3, r1, r3, r3
 8003b44:	602b      	str	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:506
				}
				res = RES_OK;
 8003b46:	2400      	movs	r4, #0
 8003b48:	e04b      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:512
			}
		}
		break;

	case CTRL_ERASE_SECTOR :	/* Erase a block of sectors (used when _USE_ERASE == 1) */
		if (!(TM_FATFS_SD_CardType & CT_SDC)) break;				/* Check if the card is SDC */
 8003b4a:	4b2b      	ldr	r3, [pc, #172]	; (8003bf8 <TM_FATFS_SD_disk_ioctl+0x2a0>)
 8003b4c:	781b      	ldrb	r3, [r3, #0]
 8003b4e:	f013 0f06 	tst.w	r3, #6
 8003b52:	d039      	beq.n	8003bc8 <TM_FATFS_SD_disk_ioctl+0x270>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:513
		if (TM_FATFS_SD_disk_ioctl(MMC_GET_CSD, csd)) break;	/* Get CSD */
 8003b54:	4669      	mov	r1, sp
 8003b56:	200b      	movs	r0, #11
 8003b58:	f7ff fefe 	bl	8003958 <TM_FATFS_SD_disk_ioctl>
 8003b5c:	bbb0      	cbnz	r0, 8003bcc <TM_FATFS_SD_disk_ioctl+0x274>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:514
		if (!(csd[0] >> 6) && !(csd[10] & 0x40)) break;	/* Check if sector erase can be applied to the card */
 8003b5e:	f89d 3000 	ldrb.w	r3, [sp]
 8003b62:	099b      	lsrs	r3, r3, #6
 8003b64:	d104      	bne.n	8003b70 <TM_FATFS_SD_disk_ioctl+0x218>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:514 (discriminator 1)
 8003b66:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8003b6a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003b6e:	d02f      	beq.n	8003bd0 <TM_FATFS_SD_disk_ioctl+0x278>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:515
		dp = buff; st = dp[0]; ed = dp[1];				/* Load sector block */
 8003b70:	6829      	ldr	r1, [r5, #0]
 8003b72:	686c      	ldr	r4, [r5, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:516
		if (!(TM_FATFS_SD_CardType & CT_BLOCK)) {
 8003b74:	4b20      	ldr	r3, [pc, #128]	; (8003bf8 <TM_FATFS_SD_disk_ioctl+0x2a0>)
 8003b76:	781b      	ldrb	r3, [r3, #0]
 8003b78:	f013 0f08 	tst.w	r3, #8
 8003b7c:	d101      	bne.n	8003b82 <TM_FATFS_SD_disk_ioctl+0x22a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:517
			st *= 512; ed *= 512;
 8003b7e:	0249      	lsls	r1, r1, #9
 8003b80:	0264      	lsls	r4, r4, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:519
		}
		if (send_cmd(CMD32, st) == 0 && send_cmd(CMD33, ed) == 0 && send_cmd(CMD38, 0) == 0 && wait_ready(30000))	/* Erase sector block */
 8003b82:	2020      	movs	r0, #32
 8003b84:	f7ff fc08 	bl	8003398 <send_cmd>
 8003b88:	bb20      	cbnz	r0, 8003bd4 <TM_FATFS_SD_disk_ioctl+0x27c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:519 (discriminator 1)
 8003b8a:	4621      	mov	r1, r4
 8003b8c:	2021      	movs	r0, #33	; 0x21
 8003b8e:	f7ff fc03 	bl	8003398 <send_cmd>
 8003b92:	bb08      	cbnz	r0, 8003bd8 <TM_FATFS_SD_disk_ioctl+0x280>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:519 (discriminator 2)
 8003b94:	2100      	movs	r1, #0
 8003b96:	2026      	movs	r0, #38	; 0x26
 8003b98:	f7ff fbfe 	bl	8003398 <send_cmd>
 8003b9c:	b9f0      	cbnz	r0, 8003bdc <TM_FATFS_SD_disk_ioctl+0x284>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:519 (discriminator 3)
 8003b9e:	f247 5030 	movw	r0, #30000	; 0x7530
 8003ba2:	f7ff fa5d 	bl	8003060 <wait_ready>
 8003ba6:	b9d8      	cbnz	r0, 8003be0 <TM_FATFS_SD_disk_ioctl+0x288>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:468
	}
	if (!SDCARD_IsDetected()) {
		return RES_NOTRDY;
	}

	res = RES_ERROR;
 8003ba8:	2401      	movs	r4, #1
 8003baa:	e01a      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:524
		if (send_cmd(CMD32, st) == 0 && send_cmd(CMD33, ed) == 0 && send_cmd(CMD38, 0) == 0 && wait_ready(30000))	/* Erase sector block */
			res = RES_OK;	/* FatFs does not check result of this command */
		break;

	default:
		res = RES_PARERR;
 8003bac:	2404      	movs	r4, #4
 8003bae:	e018      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:472

	res = RES_ERROR;

	switch (cmd) {
	case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
		if (select()) res = RES_OK;
 8003bb0:	2400      	movs	r4, #0
 8003bb2:	e016      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:468
	}
	if (!SDCARD_IsDetected()) {
		return RES_NOTRDY;
	}

	res = RES_ERROR;
 8003bb4:	2401      	movs	r4, #1
 8003bb6:	e014      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bb8:	2401      	movs	r4, #1
 8003bba:	e012      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bbc:	2401      	movs	r4, #1
 8003bbe:	e010      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bc0:	2401      	movs	r4, #1
 8003bc2:	e00e      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bc4:	2401      	movs	r4, #1
 8003bc6:	e00c      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bc8:	2401      	movs	r4, #1
 8003bca:	e00a      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bcc:	2401      	movs	r4, #1
 8003bce:	e008      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bd0:	2401      	movs	r4, #1
 8003bd2:	e006      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bd4:	2401      	movs	r4, #1
 8003bd6:	e004      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bd8:	2401      	movs	r4, #1
 8003bda:	e002      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
 8003bdc:	2401      	movs	r4, #1
 8003bde:	e000      	b.n	8003be2 <TM_FATFS_SD_disk_ioctl+0x28a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:520
		dp = buff; st = dp[0]; ed = dp[1];				/* Load sector block */
		if (!(TM_FATFS_SD_CardType & CT_BLOCK)) {
			st *= 512; ed *= 512;
		}
		if (send_cmd(CMD32, st) == 0 && send_cmd(CMD33, ed) == 0 && send_cmd(CMD38, 0) == 0 && wait_ready(30000))	/* Erase sector block */
			res = RES_OK;	/* FatFs does not check result of this command */
 8003be0:	2400      	movs	r4, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:527

	default:
		res = RES_PARERR;
	}

	deselect();
 8003be2:	f7ff fa6f 	bl	80030c4 <deselect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:529

	return res;
 8003be6:	4620      	mov	r0, r4
 8003be8:	e002      	b.n	8003bf0 <TM_FATFS_SD_disk_ioctl+0x298>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:462
	DRESULT res;
	BYTE n, csd[16];
	DWORD *dp, st, ed, csize;

	if (TM_FATFS_SD_Stat & STA_NOINIT) {
		return RES_NOTRDY;	/* Check if drive is ready */
 8003bea:	2003      	movs	r0, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:530
	}

	deselect();

	return res;
}
 8003bec:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:465

	if (TM_FATFS_SD_Stat & STA_NOINIT) {
		return RES_NOTRDY;	/* Check if drive is ready */
	}
	if (!SDCARD_IsDetected()) {
		return RES_NOTRDY;
 8003bee:	2003      	movs	r0, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/fatfs_sd.c:530
	}

	deselect();

	return res;
}
 8003bf0:	b005      	add	sp, #20
 8003bf2:	bd30      	pop	{r4, r5, pc}
 8003bf4:	200000d8 	.word	0x200000d8
 8003bf8:	20001a34 	.word	0x20001a34
 8003bfc:	40003800 	.word	0x40003800

08003c00 <mem_cpy>:
mem_cpy():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:518
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 8003c00:	e004      	b.n	8003c0c <mem_cpy+0xc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:519
		*d++ = *s++;
 8003c02:	780a      	ldrb	r2, [r1, #0]
 8003c04:	7002      	strb	r2, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:518
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 8003c06:	461a      	mov	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:519
		*d++ = *s++;
 8003c08:	3101      	adds	r1, #1
 8003c0a:	3001      	adds	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:518
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 8003c0c:	1e53      	subs	r3, r2, #1
 8003c0e:	2a00      	cmp	r2, #0
 8003c10:	d1f7      	bne.n	8003c02 <mem_cpy+0x2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:520
		*d++ = *s++;
}
 8003c12:	4770      	bx	lr

08003c14 <mem_set>:
mem_set():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:527
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003c14:	e002      	b.n	8003c1c <mem_set+0x8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:528
		*d++ = (BYTE)val;
 8003c16:	7001      	strb	r1, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:527
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003c18:	461a      	mov	r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:528
		*d++ = (BYTE)val;
 8003c1a:	3001      	adds	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:527
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003c1c:	1e53      	subs	r3, r2, #1
 8003c1e:	2a00      	cmp	r2, #0
 8003c20:	d1f9      	bne.n	8003c16 <mem_set+0x2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:529
		*d++ = (BYTE)val;
}
 8003c22:	4770      	bx	lr

08003c24 <mem_cmp>:
mem_cmp():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:533

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
 8003c24:	b470      	push	{r4, r5, r6}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:535
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;
 8003c26:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:537

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8003c28:	e001      	b.n	8003c2e <mem_cmp+0xa>
 8003c2a:	4629      	mov	r1, r5
 8003c2c:	4630      	mov	r0, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:537 (discriminator 2)
 8003c2e:	1e54      	subs	r4, r2, #1
 8003c30:	b132      	cbz	r2, 8003c40 <mem_cmp+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:537 (discriminator 1)
 8003c32:	1c46      	adds	r6, r0, #1
 8003c34:	7803      	ldrb	r3, [r0, #0]
 8003c36:	1c4d      	adds	r5, r1, #1
 8003c38:	7808      	ldrb	r0, [r1, #0]
 8003c3a:	4622      	mov	r2, r4
 8003c3c:	1a1b      	subs	r3, r3, r0
 8003c3e:	d0f4      	beq.n	8003c2a <mem_cmp+0x6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:539
	return r;
}
 8003c40:	4618      	mov	r0, r3
 8003c42:	bc70      	pop	{r4, r5, r6}
 8003c44:	4770      	bx	lr
 8003c46:	bf00      	nop

08003c48 <chk_chr>:
chk_chr():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:544

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8003c48:	e000      	b.n	8003c4c <chk_chr+0x4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:544 (discriminator 3)
 8003c4a:	3001      	adds	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:544 (discriminator 1)
 8003c4c:	7803      	ldrb	r3, [r0, #0]
 8003c4e:	b113      	cbz	r3, 8003c56 <chk_chr+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:544 (discriminator 2)
 8003c50:	b25a      	sxtb	r2, r3
 8003c52:	428a      	cmp	r2, r1
 8003c54:	d1f9      	bne.n	8003c4a <chk_chr+0x2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:546
	return *str;
}
 8003c56:	b258      	sxtb	r0, r3
 8003c58:	4770      	bx	lr
 8003c5a:	bf00      	nop

08003c5c <chk_lock>:
chk_lock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:593
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 8003c5c:	b430      	push	{r4, r5}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:597
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 8003c5e:	2500      	movs	r5, #0
 8003c60:	462b      	mov	r3, r5
 8003c62:	e01d      	b.n	8003ca0 <chk_lock+0x44>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:598
		if (Files[i].fs) {	/* Existing entry */
 8003c64:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8003c68:	00a2      	lsls	r2, r4, #2
 8003c6a:	4c1c      	ldr	r4, [pc, #112]	; (8003cdc <chk_lock+0x80>)
 8003c6c:	58a2      	ldr	r2, [r4, r2]
 8003c6e:	b1aa      	cbz	r2, 8003c9c <chk_lock+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:599
			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
 8003c70:	6804      	ldr	r4, [r0, #0]
 8003c72:	42a2      	cmp	r2, r4
 8003c74:	d113      	bne.n	8003c9e <chk_lock+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:600 (discriminator 1)
				Files[i].clu == dp->sclust &&
 8003c76:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8003c7a:	00a2      	lsls	r2, r4, #2
 8003c7c:	4c17      	ldr	r4, [pc, #92]	; (8003cdc <chk_lock+0x80>)
 8003c7e:	4422      	add	r2, r4
 8003c80:	6854      	ldr	r4, [r2, #4]
 8003c82:	6882      	ldr	r2, [r0, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:599 (discriminator 1)
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
 8003c84:	4294      	cmp	r4, r2
 8003c86:	d10a      	bne.n	8003c9e <chk_lock+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:601
				Files[i].clu == dp->sclust &&
				Files[i].idx == dp->index) break;
 8003c88:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8003c8c:	00a2      	lsls	r2, r4, #2
 8003c8e:	4c13      	ldr	r4, [pc, #76]	; (8003cdc <chk_lock+0x80>)
 8003c90:	4422      	add	r2, r4
 8003c92:	8914      	ldrh	r4, [r2, #8]
 8003c94:	88c2      	ldrh	r2, [r0, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:600

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
				Files[i].clu == dp->sclust &&
 8003c96:	4294      	cmp	r4, r2
 8003c98:	d101      	bne.n	8003c9e <chk_lock+0x42>
 8003c9a:	e003      	b.n	8003ca4 <chk_lock+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:603
				Files[i].idx == dp->index) break;
		} else {			/* Blank entry */
			be = 1;
 8003c9c:	2501      	movs	r5, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:597 (discriminator 2)
)
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 8003c9e:	3301      	adds	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:597 (discriminator 1)
 8003ca0:	2b09      	cmp	r3, #9
 8003ca2:	d9df      	bls.n	8003c64 <chk_lock+0x8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:606
				Files[i].idx == dp->index) break;
		} else {			/* Blank entry */
			be = 1;
		}
	}
	if (i == _FS_LOCK)	/* The object is not opened */
 8003ca4:	2b0a      	cmp	r3, #10
 8003ca6:	d104      	bne.n	8003cb2 <chk_lock+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:607
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 8003ca8:	b97d      	cbnz	r5, 8003cca <chk_lock+0x6e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:607 (discriminator 2)
 8003caa:	2902      	cmp	r1, #2
 8003cac:	d10f      	bne.n	8003cce <chk_lock+0x72>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:607
 8003cae:	2000      	movs	r0, #0
 8003cb0:	e012      	b.n	8003cd8 <chk_lock+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:610

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8003cb2:	b971      	cbnz	r1, 8003cd2 <chk_lock+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:610 (discriminator 2)
 8003cb4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003cb8:	009a      	lsls	r2, r3, #2
 8003cba:	4b08      	ldr	r3, [pc, #32]	; (8003cdc <chk_lock+0x80>)
 8003cbc:	441a      	add	r2, r3
 8003cbe:	8953      	ldrh	r3, [r2, #10]
 8003cc0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003cc4:	d107      	bne.n	8003cd6 <chk_lock+0x7a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:610
 8003cc6:	2010      	movs	r0, #16
 8003cc8:	e006      	b.n	8003cd8 <chk_lock+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:607
		} else {			/* Blank entry */
			be = 1;
		}
	}
	if (i == _FS_LOCK)	/* The object is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 8003cca:	2000      	movs	r0, #0
 8003ccc:	e004      	b.n	8003cd8 <chk_lock+0x7c>
 8003cce:	2012      	movs	r0, #18
 8003cd0:	e002      	b.n	8003cd8 <chk_lock+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:610

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8003cd2:	2010      	movs	r0, #16
 8003cd4:	e000      	b.n	8003cd8 <chk_lock+0x7c>
 8003cd6:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:611
}
 8003cd8:	bc30      	pop	{r4, r5}
 8003cda:	4770      	bx	lr
 8003cdc:	20001a38 	.word	0x20001a38

08003ce0 <enq_lock>:
enq_lock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:619
static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8003ce0:	2000      	movs	r0, #0
 8003ce2:	e000      	b.n	8003ce6 <enq_lock+0x6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:619 (discriminator 4)
 8003ce4:	3001      	adds	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:619 (discriminator 1)
 8003ce6:	2809      	cmp	r0, #9
 8003ce8:	d806      	bhi.n	8003cf8 <enq_lock+0x18>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:619 (discriminator 3)
 8003cea:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8003cee:	0093      	lsls	r3, r2, #2
 8003cf0:	4a03      	ldr	r2, [pc, #12]	; (8003d00 <enq_lock+0x20>)
 8003cf2:	58d3      	ldr	r3, [r2, r3]
 8003cf4:	2b00      	cmp	r3, #0
 8003cf6:	d1f5      	bne.n	8003ce4 <enq_lock+0x4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:621
	return (i == _FS_LOCK) ? 0 : 1;
}
 8003cf8:	380a      	subs	r0, #10
 8003cfa:	bf18      	it	ne
 8003cfc:	2001      	movne	r0, #1
 8003cfe:	4770      	bx	lr
 8003d00:	20001a38 	.word	0x20001a38

08003d04 <inc_lock>:
inc_lock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:629
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 8003d04:	b470      	push	{r4, r5, r6}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:633
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8003d06:	2300      	movs	r3, #0
 8003d08:	e01a      	b.n	8003d40 <inc_lock+0x3c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:634
		if (Files[i].fs == dp->fs &&
 8003d0a:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8003d0e:	00a2      	lsls	r2, r4, #2
 8003d10:	4c2c      	ldr	r4, [pc, #176]	; (8003dc4 <inc_lock+0xc0>)
 8003d12:	58a4      	ldr	r4, [r4, r2]
 8003d14:	6802      	ldr	r2, [r0, #0]
 8003d16:	4294      	cmp	r4, r2
 8003d18:	d111      	bne.n	8003d3e <inc_lock+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:635 (discriminator 1)
			Files[i].clu == dp->sclust &&
 8003d1a:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8003d1e:	00a2      	lsls	r2, r4, #2
 8003d20:	4c28      	ldr	r4, [pc, #160]	; (8003dc4 <inc_lock+0xc0>)
 8003d22:	4422      	add	r2, r4
 8003d24:	6854      	ldr	r4, [r2, #4]
 8003d26:	6882      	ldr	r2, [r0, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:634 (discriminator 1)
{
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->fs &&
 8003d28:	4294      	cmp	r4, r2
 8003d2a:	d108      	bne.n	8003d3e <inc_lock+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:636
			Files[i].clu == dp->sclust &&
			Files[i].idx == dp->index) break;
 8003d2c:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8003d30:	00a2      	lsls	r2, r4, #2
 8003d32:	4c24      	ldr	r4, [pc, #144]	; (8003dc4 <inc_lock+0xc0>)
 8003d34:	4422      	add	r2, r4
 8003d36:	8914      	ldrh	r4, [r2, #8]
 8003d38:	88c2      	ldrh	r2, [r0, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:635
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->fs &&
			Files[i].clu == dp->sclust &&
 8003d3a:	4294      	cmp	r4, r2
 8003d3c:	d002      	beq.n	8003d44 <inc_lock+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:633 (discriminator 2)
)
{
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8003d3e:	3301      	adds	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:633 (discriminator 1)
 8003d40:	2b09      	cmp	r3, #9
 8003d42:	d9e2      	bls.n	8003d0a <inc_lock+0x6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:639
		if (Files[i].fs == dp->fs &&
			Files[i].clu == dp->sclust &&
			Files[i].idx == dp->index) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 8003d44:	2b0a      	cmp	r3, #10
 8003d46:	d11b      	bne.n	8003d80 <inc_lock+0x7c>
 8003d48:	e001      	b.n	8003d4e <inc_lock+0x4a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:640 (discriminator 4)
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8003d4a:	3301      	adds	r3, #1
 8003d4c:	e000      	b.n	8003d50 <inc_lock+0x4c>
 8003d4e:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:640 (discriminator 1)
 8003d50:	2b09      	cmp	r3, #9
 8003d52:	d806      	bhi.n	8003d62 <inc_lock+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:640 (discriminator 3)
 8003d54:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8003d58:	00a2      	lsls	r2, r4, #2
 8003d5a:	4c1a      	ldr	r4, [pc, #104]	; (8003dc4 <inc_lock+0xc0>)
 8003d5c:	58a2      	ldr	r2, [r4, r2]
 8003d5e:	2a00      	cmp	r2, #0
 8003d60:	d1f3      	bne.n	8003d4a <inc_lock+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:641
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8003d62:	2b0a      	cmp	r3, #10
 8003d64:	d028      	beq.n	8003db8 <inc_lock+0xb4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:642
		Files[i].fs = dp->fs;
 8003d66:	6805      	ldr	r5, [r0, #0]
 8003d68:	4e16      	ldr	r6, [pc, #88]	; (8003dc4 <inc_lock+0xc0>)
 8003d6a:	005a      	lsls	r2, r3, #1
 8003d6c:	441a      	add	r2, r3
 8003d6e:	0094      	lsls	r4, r2, #2
 8003d70:	1932      	adds	r2, r6, r4
 8003d72:	5135      	str	r5, [r6, r4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:643
		Files[i].clu = dp->sclust;
 8003d74:	6884      	ldr	r4, [r0, #8]
 8003d76:	6054      	str	r4, [r2, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:644
		Files[i].idx = dp->index;
 8003d78:	88c0      	ldrh	r0, [r0, #6]
 8003d7a:	8110      	strh	r0, [r2, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:645
		Files[i].ctr = 0;
 8003d7c:	2000      	movs	r0, #0
 8003d7e:	8150      	strh	r0, [r2, #10]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:648
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8003d80:	b131      	cbz	r1, 8003d90 <inc_lock+0x8c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:648 (discriminator 1)
 8003d82:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 8003d86:	0082      	lsls	r2, r0, #2
 8003d88:	480e      	ldr	r0, [pc, #56]	; (8003dc4 <inc_lock+0xc0>)
 8003d8a:	4402      	add	r2, r0
 8003d8c:	8952      	ldrh	r2, [r2, #10]
 8003d8e:	b9aa      	cbnz	r2, 8003dbc <inc_lock+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:650

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8003d90:	b941      	cbnz	r1, 8003da4 <inc_lock+0xa0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:650 (discriminator 1)
 8003d92:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8003d96:	008a      	lsls	r2, r1, #2
 8003d98:	490a      	ldr	r1, [pc, #40]	; (8003dc4 <inc_lock+0xc0>)
 8003d9a:	440a      	add	r2, r1
 8003d9c:	8951      	ldrh	r1, [r2, #10]
 8003d9e:	3101      	adds	r1, #1
 8003da0:	b289      	uxth	r1, r1
 8003da2:	e001      	b.n	8003da8 <inc_lock+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:650
 8003da4:	f44f 7180 	mov.w	r1, #256	; 0x100
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:650 (discriminator 4)
 8003da8:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 8003dac:	0082      	lsls	r2, r0, #2
 8003dae:	4805      	ldr	r0, [pc, #20]	; (8003dc4 <inc_lock+0xc0>)
 8003db0:	4402      	add	r2, r0
 8003db2:	8151      	strh	r1, [r2, #10]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:652 (discriminator 4)

	return i + 1;
 8003db4:	1c58      	adds	r0, r3, #1
 8003db6:	e002      	b.n	8003dbe <inc_lock+0xba>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:641
			Files[i].idx == dp->index) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8003db8:	2000      	movs	r0, #0
 8003dba:	e000      	b.n	8003dbe <inc_lock+0xba>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:648
		Files[i].clu = dp->sclust;
		Files[i].idx = dp->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8003dbc:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:653

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */

	return i + 1;
}
 8003dbe:	bc70      	pop	{r4, r5, r6}
 8003dc0:	4770      	bx	lr
 8003dc2:	bf00      	nop
 8003dc4:	20001a38 	.word	0x20001a38

08003dc8 <dec_lock>:
dec_lock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:665
{
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8003dc8:	3801      	subs	r0, #1
 8003dca:	2809      	cmp	r0, #9
 8003dcc:	d819      	bhi.n	8003e02 <dec_lock+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:666
		n = Files[i].ctr;
 8003dce:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8003dd2:	0093      	lsls	r3, r2, #2
 8003dd4:	4a0d      	ldr	r2, [pc, #52]	; (8003e0c <dec_lock+0x44>)
 8003dd6:	4413      	add	r3, r2
 8003dd8:	895b      	ldrh	r3, [r3, #10]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:667
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8003dda:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003dde:	d100      	bne.n	8003de2 <dec_lock+0x1a>
 8003de0:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:668
		if (n) n--;					/* Decrement read mode open count */
 8003de2:	b10b      	cbz	r3, 8003de8 <dec_lock+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:668 (discriminator 1)
 8003de4:	3b01      	subs	r3, #1
 8003de6:	b29b      	uxth	r3, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:669
		Files[i].ctr = n;
 8003de8:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 8003dec:	008a      	lsls	r2, r1, #2
 8003dee:	4907      	ldr	r1, [pc, #28]	; (8003e0c <dec_lock+0x44>)
 8003df0:	440a      	add	r2, r1
 8003df2:	8153      	strh	r3, [r2, #10]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:670
		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8003df4:	b93b      	cbnz	r3, 8003e06 <dec_lock+0x3e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:670 (discriminator 1)
 8003df6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003dfa:	0083      	lsls	r3, r0, #2
 8003dfc:	2000      	movs	r0, #0
 8003dfe:	50c8      	str	r0, [r1, r3]
 8003e00:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:673
		res = FR_OK;
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 8003e02:	2002      	movs	r0, #2
 8003e04:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:671
		n = Files[i].ctr;
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
		if (n) n--;					/* Decrement read mode open count */
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
		res = FR_OK;
 8003e06:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:676
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
	}
	return res;
}
 8003e08:	4770      	bx	lr
 8003e0a:	bf00      	nop
 8003e0c:	20001a38 	.word	0x20001a38

08003e10 <clear_lock>:
clear_lock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:683

static
void clear_lock (	/* Clear lock entries of the volume */
	FATFS *fs
)
{
 8003e10:	b410      	push	{r4}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:686
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
 8003e12:	2300      	movs	r3, #0
 8003e14:	e00d      	b.n	8003e32 <clear_lock+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:687
		if (Files[i].fs == fs) Files[i].fs = 0;
 8003e16:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8003e1a:	008a      	lsls	r2, r1, #2
 8003e1c:	4907      	ldr	r1, [pc, #28]	; (8003e3c <clear_lock+0x2c>)
 8003e1e:	588a      	ldr	r2, [r1, r2]
 8003e20:	4282      	cmp	r2, r0
 8003e22:	d105      	bne.n	8003e30 <clear_lock+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:687 (discriminator 1)
 8003e24:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8003e28:	008a      	lsls	r2, r1, #2
 8003e2a:	2400      	movs	r4, #0
 8003e2c:	4903      	ldr	r1, [pc, #12]	; (8003e3c <clear_lock+0x2c>)
 8003e2e:	508c      	str	r4, [r1, r2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:686 (discriminator 2)
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
 8003e30:	3301      	adds	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:686 (discriminator 1)
 8003e32:	2b09      	cmp	r3, #9
 8003e34:	d9ef      	bls.n	8003e16 <clear_lock+0x6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:689
		if (Files[i].fs == fs) Files[i].fs = 0;
	}
}
 8003e36:	bc10      	pop	{r4}
 8003e38:	4770      	bx	lr
 8003e3a:	bf00      	nop
 8003e3c:	20001a38 	.word	0x20001a38

08003e40 <ld_clust>:
ld_clust():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1242
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
 8003e40:	7eca      	ldrb	r2, [r1, #27]
 8003e42:	7e8b      	ldrb	r3, [r1, #26]
 8003e44:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1243
	if (fs->fs_type == FS_FAT32)
 8003e48:	7802      	ldrb	r2, [r0, #0]
 8003e4a:	2a03      	cmp	r2, #3
 8003e4c:	d105      	bne.n	8003e5a <ld_clust+0x1a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1244
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
 8003e4e:	7d48      	ldrb	r0, [r1, #21]
 8003e50:	7d0a      	ldrb	r2, [r1, #20]
 8003e52:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8003e56:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1247

	return cl;
}
 8003e5a:	4618      	mov	r0, r3
 8003e5c:	4770      	bx	lr
 8003e5e:	bf00      	nop

08003e60 <st_clust>:
st_clust():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1257
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8003e60:	7681      	strb	r1, [r0, #26]
 8003e62:	f3c1 2307 	ubfx	r3, r1, #8, #8
 8003e66:	76c3      	strb	r3, [r0, #27]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1258
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8003e68:	0c09      	lsrs	r1, r1, #16
 8003e6a:	7501      	strb	r1, [r0, #20]
 8003e6c:	0a09      	lsrs	r1, r1, #8
 8003e6e:	7541      	strb	r1, [r0, #21]
 8003e70:	4770      	bx	lr
 8003e72:	bf00      	nop

08003e74 <fit_lfn>:
fit_lfn():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1347
	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer */
	BYTE* dir,				/* Pointer to the LFN entry to be processed */
	BYTE ord,				/* LFN order (1-20) */
	BYTE sum				/* Checksum of the corresponding SFN */
)
{
 8003e74:	b4f0      	push	{r4, r5, r6, r7}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1352
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set checksum */
 8003e76:	734b      	strb	r3, [r1, #13]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1353
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 8003e78:	230f      	movs	r3, #15
 8003e7a:	72cb      	strb	r3, [r1, #11]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1354
	dir[LDIR_Type] = 0;
 8003e7c:	2500      	movs	r5, #0
 8003e7e:	730d      	strb	r5, [r1, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1355
	ST_WORD(dir + LDIR_FstClusLO, 0);
 8003e80:	768d      	strb	r5, [r1, #26]
 8003e82:	76cd      	strb	r5, [r1, #27]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1357

	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 8003e84:	1e53      	subs	r3, r2, #1
 8003e86:	eb03 0643 	add.w	r6, r3, r3, lsl #1
 8003e8a:	eb03 0686 	add.w	r6, r3, r6, lsl #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1358
	s = wc = 0;
 8003e8e:	462b      	mov	r3, r5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1360
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8003e90:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8003e94:	42a3      	cmp	r3, r4
 8003e96:	d002      	beq.n	8003e9e <fit_lfn+0x2a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1360 (discriminator 1)
 8003e98:	f830 3016 	ldrh.w	r3, [r0, r6, lsl #1]
 8003e9c:	3601      	adds	r6, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1361
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8003e9e:	4c0c      	ldr	r4, [pc, #48]	; (8003ed0 <fit_lfn+0x5c>)
 8003ea0:	5d64      	ldrb	r4, [r4, r5]
 8003ea2:	550b      	strb	r3, [r1, r4]
 8003ea4:	3401      	adds	r4, #1
 8003ea6:	0a1f      	lsrs	r7, r3, #8
 8003ea8:	550f      	strb	r7, [r1, r4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1362
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
 8003eaa:	b90b      	cbnz	r3, 8003eb0 <fit_lfn+0x3c>
 8003eac:	f64f 73ff 	movw	r3, #65535	; 0xffff
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1363
	} while (++s < 13);
 8003eb0:	3501      	adds	r5, #1
 8003eb2:	2d0c      	cmp	r5, #12
 8003eb4:	d9ec      	bls.n	8003e90 <fit_lfn+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1364
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
 8003eb6:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8003eba:	42a3      	cmp	r3, r4
 8003ebc:	d002      	beq.n	8003ec4 <fit_lfn+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1364 (discriminator 2)
 8003ebe:	f830 3016 	ldrh.w	r3, [r0, r6, lsl #1]
 8003ec2:	b90b      	cbnz	r3, 8003ec8 <fit_lfn+0x54>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1364 (discriminator 3)
 8003ec4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1365
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 8003ec8:	700a      	strb	r2, [r1, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1366
}
 8003eca:	bcf0      	pop	{r4, r5, r6, r7}
 8003ecc:	4770      	bx	lr
 8003ece:	bf00      	nop
 8003ed0:	0800693c 	.word	0x0800693c

08003ed4 <gen_numname>:
gen_numname():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1385
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
 8003ed4:	b570      	push	{r4, r5, r6, lr}
 8003ed6:	b082      	sub	sp, #8
 8003ed8:	4605      	mov	r5, r0
 8003eda:	4616      	mov	r6, r2
 8003edc:	461c      	mov	r4, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1392
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
 8003ede:	220b      	movs	r2, #11
 8003ee0:	f7ff fe8e 	bl	8003c00 <mem_cpy>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1394

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 8003ee4:	2c05      	cmp	r4, #5
 8003ee6:	d812      	bhi.n	8003f0e <gen_numname+0x3a>
 8003ee8:	e014      	b.n	8003f14 <gen_numname+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1397
		sr = seq;
		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
 8003eea:	3602      	adds	r6, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1398
			for (i = 0; i < 16; i++) {
 8003eec:	2200      	movs	r2, #0
 8003eee:	e00c      	b.n	8003f0a <gen_numname+0x36>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1399
				sr = (sr << 1) + (wc & 1);
 8003ef0:	f003 0101 	and.w	r1, r3, #1
 8003ef4:	eb01 0444 	add.w	r4, r1, r4, lsl #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1400
				wc >>= 1;
 8003ef8:	085b      	lsrs	r3, r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1401
				if (sr & 0x10000) sr ^= 0x11021;
 8003efa:	f414 3f80 	tst.w	r4, #65536	; 0x10000
 8003efe:	d003      	beq.n	8003f08 <gen_numname+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1401 (discriminator 1)
 8003f00:	f484 3488 	eor.w	r4, r4, #69632	; 0x11000
 8003f04:	f084 0421 	eor.w	r4, r4, #33	; 0x21
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1398 (discriminator 2)

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 8003f08:	3201      	adds	r2, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1398 (discriminator 1)
 8003f0a:	2a0f      	cmp	r2, #15
 8003f0c:	d9f0      	bls.n	8003ef0 <gen_numname+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1396

	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
 8003f0e:	8833      	ldrh	r3, [r6, #0]
 8003f10:	2b00      	cmp	r3, #0
 8003f12:	d1ea      	bne.n	8003eea <gen_numname+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1398
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 8003f14:	2307      	movs	r3, #7
 8003f16:	e000      	b.n	8003f1a <gen_numname+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1412
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
 8003f18:	4613      	mov	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1410
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
 8003f1a:	f004 020f 	and.w	r2, r4, #15
 8003f1e:	f102 0130 	add.w	r1, r2, #48	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1411
		if (c > '9') c += 7;
 8003f22:	2939      	cmp	r1, #57	; 0x39
 8003f24:	d901      	bls.n	8003f2a <gen_numname+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1411 (discriminator 1)
 8003f26:	f102 0137 	add.w	r1, r2, #55	; 0x37
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1412
		ns[i--] = c;
 8003f2a:	1e5a      	subs	r2, r3, #1
 8003f2c:	a802      	add	r0, sp, #8
 8003f2e:	4403      	add	r3, r0
 8003f30:	f803 1c08 	strb.w	r1, [r3, #-8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1414
		seq /= 16;
	} while (seq);
 8003f34:	0924      	lsrs	r4, r4, #4
 8003f36:	d1ef      	bne.n	8003f18 <gen_numname+0x44>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1415
	ns[i] = '~';
 8003f38:	217e      	movs	r1, #126	; 0x7e
 8003f3a:	4603      	mov	r3, r0
 8003f3c:	4413      	add	r3, r2
 8003f3e:	f803 1c08 	strb.w	r1, [r3, #-8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1418

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8003f42:	2300      	movs	r3, #0
 8003f44:	e000      	b.n	8003f48 <gen_numname+0x74>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1418 (discriminator 2)
 8003f46:	3301      	adds	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1418 (discriminator 1)
 8003f48:	4293      	cmp	r3, r2
 8003f4a:	d202      	bcs.n	8003f52 <gen_numname+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1418 (discriminator 3)
 8003f4c:	5ce9      	ldrb	r1, [r5, r3]
 8003f4e:	2920      	cmp	r1, #32
 8003f50:	d1f9      	bne.n	8003f46 <gen_numname+0x72>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1425
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8003f52:	1c59      	adds	r1, r3, #1
 8003f54:	442b      	add	r3, r5
 8003f56:	2a07      	cmp	r2, #7
 8003f58:	d805      	bhi.n	8003f66 <gen_numname+0x92>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1425 (discriminator 1)
 8003f5a:	a802      	add	r0, sp, #8
 8003f5c:	4410      	add	r0, r2
 8003f5e:	f810 0c08 	ldrb.w	r0, [r0, #-8]
 8003f62:	3201      	adds	r2, #1
 8003f64:	e000      	b.n	8003f68 <gen_numname+0x94>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1425
 8003f66:	2020      	movs	r0, #32
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1425 (discriminator 4)
 8003f68:	7018      	strb	r0, [r3, #0]
 8003f6a:	460b      	mov	r3, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1426 (discriminator 4)
	} while (j < 8);
 8003f6c:	2907      	cmp	r1, #7
 8003f6e:	d9f0      	bls.n	8003f52 <gen_numname+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1427
}
 8003f70:	b002      	add	sp, #8
 8003f72:	bd70      	pop	{r4, r5, r6, pc}

08003f74 <sum_sfn>:
sum_sfn():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1443
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
	BYTE sum = 0;
	UINT n = 11;
 8003f74:	210b      	movs	r1, #11
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1442
static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
	BYTE sum = 0;
 8003f76:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1445 (discriminator 1)
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 8003f78:	01da      	lsls	r2, r3, #7
 8003f7a:	ea42 0353 	orr.w	r3, r2, r3, lsr #1
 8003f7e:	7802      	ldrb	r2, [r0, #0]
 8003f80:	fa52 f383 	uxtab	r3, r2, r3
 8003f84:	b2db      	uxtb	r3, r3
 8003f86:	3001      	adds	r0, #1
 8003f88:	3901      	subs	r1, #1
 8003f8a:	d1f5      	bne.n	8003f78 <sum_sfn+0x4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1447
	return sum;
}
 8003f8c:	4618      	mov	r0, r3
 8003f8e:	4770      	bx	lr

08003f90 <get_ldnumber>:
get_ldnumber():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2117

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8003f90:	b5f0      	push	{r4, r5, r6, r7, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2129
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8003f92:	f8d0 e000 	ldr.w	lr, [r0]
 8003f96:	f1be 0f00 	cmp.w	lr, #0
 8003f9a:	d104      	bne.n	8003fa6 <get_ldnumber+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2120
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 8003f9c:	f04f 30ff 	mov.w	r0, #4294967295
 8003fa0:	bdf0      	pop	{r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2130 (discriminator 4)
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8003fa2:	3601      	adds	r6, #1
 8003fa4:	e001      	b.n	8003faa <get_ldnumber+0x1a>
 8003fa6:	4684      	mov	ip, r0
 8003fa8:	4676      	mov	r6, lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2130 (discriminator 1)
 8003faa:	7833      	ldrb	r3, [r6, #0]
 8003fac:	b2da      	uxtb	r2, r3
 8003fae:	2a1f      	cmp	r2, #31
 8003fb0:	d902      	bls.n	8003fb8 <get_ldnumber+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2130 (discriminator 3)
 8003fb2:	b25a      	sxtb	r2, r3
 8003fb4:	2a3a      	cmp	r2, #58	; 0x3a
 8003fb6:	d1f4      	bne.n	8003fa2 <get_ldnumber+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2131
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 8003fb8:	b25b      	sxtb	r3, r3
 8003fba:	2b3a      	cmp	r3, #58	; 0x3a
 8003fbc:	d134      	bne.n	8004028 <get_ldnumber+0x98>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2133
			tp = *path;
			i = *tp++ - '0'; 
 8003fbe:	f10e 0301 	add.w	r3, lr, #1
 8003fc2:	f99e 0000 	ldrsb.w	r0, [lr]
 8003fc6:	3830      	subs	r0, #48	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2134
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8003fc8:	2809      	cmp	r0, #9
 8003fca:	d807      	bhi.n	8003fdc <get_ldnumber+0x4c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2134 (discriminator 1)
 8003fcc:	429e      	cmp	r6, r3
 8003fce:	d105      	bne.n	8003fdc <get_ldnumber+0x4c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2135
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8003fd0:	2808      	cmp	r0, #8
 8003fd2:	d82c      	bhi.n	800402e <get_ldnumber+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2137
					vol = (int)i;
					*path = ++tt;
 8003fd4:	3601      	adds	r6, #1
 8003fd6:	f8cc 6000 	str.w	r6, [ip]
 8003fda:	bdf0      	pop	{r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2142
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
 8003fdc:	3601      	adds	r6, #1
 8003fde:	2700      	movs	r7, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2144
				do {
					sp = str[i]; tp = *path;
 8003fe0:	4b16      	ldr	r3, [pc, #88]	; (800403c <get_ldnumber+0xac>)
 8003fe2:	f853 1027 	ldr.w	r1, [r3, r7, lsl #2]
 8003fe6:	4672      	mov	r2, lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2146
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
 8003fe8:	1c48      	adds	r0, r1, #1
 8003fea:	780c      	ldrb	r4, [r1, #0]
 8003fec:	1c55      	adds	r5, r2, #1
 8003fee:	7813      	ldrb	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2147
						if (IsLower(tc)) tc -= 0x20;
 8003ff0:	b2d9      	uxtb	r1, r3
 8003ff2:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 8003ff6:	b2d2      	uxtb	r2, r2
 8003ff8:	2a19      	cmp	r2, #25
 8003ffa:	d802      	bhi.n	8004002 <get_ldnumber+0x72>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2147 (discriminator 1)
 8003ffc:	f1a1 0320 	sub.w	r3, r1, #32
 8004000:	b2db      	uxtb	r3, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2148
					} while (c && (TCHAR)c == tc);
 8004002:	b12c      	cbz	r4, 8004010 <get_ldnumber+0x80>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2146 (discriminator 1)
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
 8004004:	462a      	mov	r2, r5
 8004006:	4601      	mov	r1, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2148 (discriminator 1)
						if (IsLower(tc)) tc -= 0x20;
					} while (c && (TCHAR)c == tc);
 8004008:	b25b      	sxtb	r3, r3
 800400a:	b260      	sxtb	r0, r4
 800400c:	4283      	cmp	r3, r0
 800400e:	d0eb      	beq.n	8003fe8 <get_ldnumber+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2149
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
 8004010:	b90c      	cbnz	r4, 8004016 <get_ldnumber+0x86>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2149 (discriminator 2)
 8004012:	42ae      	cmp	r6, r5
 8004014:	d002      	beq.n	800401c <get_ldnumber+0x8c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2149 (discriminator 3)
 8004016:	3701      	adds	r7, #1
 8004018:	2f08      	cmp	r7, #8
 800401a:	d9e1      	bls.n	8003fe0 <get_ldnumber+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2150
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800401c:	2f08      	cmp	r7, #8
 800401e:	d809      	bhi.n	8004034 <get_ldnumber+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2151
					vol = (int)i;
 8004020:	4638      	mov	r0, r7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2152
					*path = tt;
 8004022:	f8cc 6000 	str.w	r6, [ip]
 8004026:	bdf0      	pop	{r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2159
			}
#endif
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
 8004028:	4b05      	ldr	r3, [pc, #20]	; (8004040 <get_ldnumber+0xb0>)
 800402a:	7818      	ldrb	r0, [r3, #0]
 800402c:	bdf0      	pop	{r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2120
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 800402e:	f04f 30ff 	mov.w	r0, #4294967295
 8004032:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004034:	f04f 30ff 	mov.w	r0, #4294967295
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2165
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8004038:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800403a:	bf00      	nop
 800403c:	0800694c 	.word	0x0800694c
 8004040:	20001a35 	.word	0x20001a35

08004044 <sync_window>:
sync_window():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:703
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
 8004044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:709
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004046:	7903      	ldrb	r3, [r0, #4]
 8004048:	b303      	cbz	r3, 800408c <sync_window+0x48>
 800404a:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:710
		wsect = fs->winsect;	/* Current sector number */
 800404c:	6b06      	ldr	r6, [r0, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:711
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800404e:	f100 0734 	add.w	r7, r0, #52	; 0x34
 8004052:	2301      	movs	r3, #1
 8004054:	4632      	mov	r2, r6
 8004056:	4639      	mov	r1, r7
 8004058:	7840      	ldrb	r0, [r0, #1]
 800405a:	f7fe ff8f 	bl	8002f7c <disk_write>
 800405e:	b9b8      	cbnz	r0, 8004090 <sync_window+0x4c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:714
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
 8004060:	2300      	movs	r3, #0
 8004062:	7123      	strb	r3, [r4, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:715
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8004064:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004066:	1af3      	subs	r3, r6, r3
 8004068:	69e2      	ldr	r2, [r4, #28]
 800406a:	4293      	cmp	r3, r2
 800406c:	d212      	bcs.n	8004094 <sync_window+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:716
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800406e:	78e5      	ldrb	r5, [r4, #3]
 8004070:	e008      	b.n	8004084 <sync_window+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:717 (discriminator 3)
					wsect += fs->fsize;
 8004072:	69e3      	ldr	r3, [r4, #28]
 8004074:	441e      	add	r6, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:718 (discriminator 3)
					disk_write(fs->drv, fs->win, wsect, 1);
 8004076:	2301      	movs	r3, #1
 8004078:	4632      	mov	r2, r6
 800407a:	4639      	mov	r1, r7
 800407c:	7860      	ldrb	r0, [r4, #1]
 800407e:	f7fe ff7d 	bl	8002f7c <disk_write>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:716 (discriminator 3)
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004082:	3d01      	subs	r5, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:716 (discriminator 1)
 8004084:	2d01      	cmp	r5, #1
 8004086:	d8f4      	bhi.n	8004072 <sync_window+0x2e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:706
	FATFS* fs		/* File system object */
)
{
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 8004088:	2000      	movs	r0, #0
 800408a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800408c:	2000      	movs	r0, #0
 800408e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:712


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
 8004090:	2001      	movs	r0, #1
 8004092:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:706
	FATFS* fs		/* File system object */
)
{
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 8004094:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:724
				}
			}
		}
	}
	return res;
}
 8004096:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004098 <move_window>:
move_window():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:733
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
 8004098:	b570      	push	{r4, r5, r6, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:737
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
 800409a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800409c:	428b      	cmp	r3, r1
 800409e:	d012      	beq.n	80040c6 <move_window+0x2e>
 80040a0:	4604      	mov	r4, r0
 80040a2:	460d      	mov	r5, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:739
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 80040a4:	f7ff ffce 	bl	8004044 <sync_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:741
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 80040a8:	4606      	mov	r6, r0
 80040aa:	b968      	cbnz	r0, 80040c8 <move_window+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:742
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80040ac:	2301      	movs	r3, #1
 80040ae:	462a      	mov	r2, r5
 80040b0:	f104 0134 	add.w	r1, r4, #52	; 0x34
 80040b4:	7860      	ldrb	r0, [r4, #1]
 80040b6:	f7fe ff49 	bl	8002f4c <disk_read>
 80040ba:	b110      	cbz	r0, 80040c2 <move_window+0x2a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:744
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
 80040bc:	2601      	movs	r6, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:743
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
 80040be:	f04f 35ff 	mov.w	r5, #4294967295
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:746
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
 80040c2:	6325      	str	r5, [r4, #48]	; 0x30
 80040c4:	e000      	b.n	80040c8 <move_window+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:734
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
	FRESULT res = FR_OK;
 80040c6:	2600      	movs	r6, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:750
			}
			fs->winsect = sector;
		}
	}
	return res;
}
 80040c8:	4630      	mov	r0, r6
 80040ca:	bd70      	pop	{r4, r5, r6, pc}

080040cc <check_fs>:
check_fs():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2179
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 80040cc:	b510      	push	{r4, lr}
 80040ce:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2180
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 80040d0:	2300      	movs	r3, #0
 80040d2:	7103      	strb	r3, [r0, #4]
 80040d4:	f04f 33ff 	mov.w	r3, #4294967295
 80040d8:	6303      	str	r3, [r0, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2181
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 80040da:	f7ff ffdd 	bl	8004098 <move_window>
 80040de:	bb80      	cbnz	r0, 8004142 <check_fs+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2184
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 80040e0:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
 80040e4:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
 80040e8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80040ec:	b21b      	sxth	r3, r3
 80040ee:	4a19      	ldr	r2, [pc, #100]	; (8004154 <check_fs+0x88>)
 80040f0:	4293      	cmp	r3, r2
 80040f2:	d128      	bne.n	8004146 <check_fs+0x7a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2187
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 80040f4:	f894 206d 	ldrb.w	r2, [r4, #109]	; 0x6d
 80040f8:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
 80040fc:	041b      	lsls	r3, r3, #16
 80040fe:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004102:	f894 206b 	ldrb.w	r2, [r4, #107]	; 0x6b
 8004106:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800410a:	f894 206a 	ldrb.w	r2, [r4, #106]	; 0x6a
 800410e:	4313      	orrs	r3, r2
 8004110:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004114:	4a10      	ldr	r2, [pc, #64]	; (8004158 <check_fs+0x8c>)
 8004116:	4293      	cmp	r3, r2
 8004118:	d017      	beq.n	800414a <check_fs+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2189
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 800411a:	f894 2089 	ldrb.w	r2, [r4, #137]	; 0x89
 800411e:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
 8004122:	041b      	lsls	r3, r3, #16
 8004124:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004128:	f894 2087 	ldrb.w	r2, [r4, #135]	; 0x87
 800412c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004130:	f894 2086 	ldrb.w	r2, [r4, #134]	; 0x86
 8004134:	4313      	orrs	r3, r2
 8004136:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800413a:	4a07      	ldr	r2, [pc, #28]	; (8004158 <check_fs+0x8c>)
 800413c:	4293      	cmp	r3, r2
 800413e:	d106      	bne.n	800414e <check_fs+0x82>
 8004140:	bd10      	pop	{r4, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2182
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
		return 3;
 8004142:	2003      	movs	r0, #3
 8004144:	bd10      	pop	{r4, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2185

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
 8004146:	2002      	movs	r0, #2
 8004148:	bd10      	pop	{r4, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2188

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
		return 0;
 800414a:	2000      	movs	r0, #0
 800414c:	bd10      	pop	{r4, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2192
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
 800414e:	2001      	movs	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2193
}
 8004150:	bd10      	pop	{r4, pc}
 8004152:	bf00      	nop
 8004154:	ffffaa55 	.word	0xffffaa55
 8004158:	00544146 	.word	0x00544146

0800415c <validate>:
validate():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2379
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 800415c:	b180      	cbz	r0, 8004180 <validate+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2375 (discriminator 1)

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
 800415e:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2379 (discriminator 1)
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 8004160:	6803      	ldr	r3, [r0, #0]
 8004162:	b17b      	cbz	r3, 8004184 <validate+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2379 (discriminator 2)
 8004164:	7819      	ldrb	r1, [r3, #0]
 8004166:	b179      	cbz	r1, 8004188 <validate+0x2c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2379 (discriminator 3)
 8004168:	88d9      	ldrh	r1, [r3, #6]
 800416a:	8882      	ldrh	r2, [r0, #4]
 800416c:	4291      	cmp	r1, r2
 800416e:	d10d      	bne.n	800418c <validate+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2379 (discriminator 4)
 8004170:	7858      	ldrb	r0, [r3, #1]
 8004172:	f7fe fedd 	bl	8002f30 <disk_status>
 8004176:	f010 0f01 	tst.w	r0, #1
 800417a:	d109      	bne.n	8004190 <validate+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2384
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
 800417c:	2000      	movs	r0, #0
 800417e:	bd08      	pop	{r3, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2380
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
		return FR_INVALID_OBJECT;
 8004180:	2009      	movs	r0, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2385

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
 8004182:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2380
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
		return FR_INVALID_OBJECT;
 8004184:	2009      	movs	r0, #9
 8004186:	bd08      	pop	{r3, pc}
 8004188:	2009      	movs	r0, #9
 800418a:	bd08      	pop	{r3, pc}
 800418c:	2009      	movs	r0, #9
 800418e:	bd08      	pop	{r3, pc}
 8004190:	2009      	movs	r0, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2385

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
 8004192:	bd08      	pop	{r3, pc}

08004194 <find_volume>:
find_volume():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2208
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8004194:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004196:	b085      	sub	sp, #20
 8004198:	4606      	mov	r6, r0
 800419a:	4617      	mov	r7, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2219
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
 800419c:	2300      	movs	r3, #0
 800419e:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2220
	vol = get_ldnumber(path);
 80041a0:	4608      	mov	r0, r1
 80041a2:	f7ff fef5 	bl	8003f90 <get_ldnumber>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2221
	if (vol < 0) return FR_INVALID_DRIVE;
 80041a6:	1e05      	subs	r5, r0, #0
 80041a8:	f2c0 8182 	blt.w	80044b0 <find_volume+0x31c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2224

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 80041ac:	4bcd      	ldr	r3, [pc, #820]	; (80044e4 <find_volume+0x350>)
 80041ae:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2225
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80041b2:	2c00      	cmp	r4, #0
 80041b4:	f000 817e 	beq.w	80044b4 <find_volume+0x320>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2228

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 80041b8:	6034      	str	r4, [r6, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2230

	if (fs->fs_type) {					/* If the volume has been mounted */
 80041ba:	7823      	ldrb	r3, [r4, #0]
 80041bc:	b173      	cbz	r3, 80041dc <find_volume+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2231
		stat = disk_status(fs->drv);
 80041be:	7860      	ldrb	r0, [r4, #1]
 80041c0:	f7fe feb6 	bl	8002f30 <disk_status>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2232
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 80041c4:	f010 0f01 	tst.w	r0, #1
 80041c8:	d108      	bne.n	80041dc <find_volume+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2233
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 80041ca:	2f00      	cmp	r7, #0
 80041cc:	f000 8174 	beq.w	80044b8 <find_volume+0x324>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2233 (discriminator 1)
 80041d0:	f010 0f04 	tst.w	r0, #4
 80041d4:	f040 8172 	bne.w	80044bc <find_volume+0x328>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2235
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
 80041d8:	2000      	movs	r0, #0
 80041da:	e198      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2242
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 80041dc:	2300      	movs	r3, #0
 80041de:	7023      	strb	r3, [r4, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2243
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 80041e0:	b2e8      	uxtb	r0, r5
 80041e2:	7060      	strb	r0, [r4, #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2244
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 80041e4:	f7fe fe96 	bl	8002f14 <disk_initialize>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2245
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 80041e8:	f010 0f01 	tst.w	r0, #1
 80041ec:	f040 8168 	bne.w	80044c0 <find_volume+0x32c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2247
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 80041f0:	b11f      	cbz	r7, 80041fa <find_volume+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2247 (discriminator 1)
 80041f2:	f010 0f04 	tst.w	r0, #4
 80041f6:	f040 8165 	bne.w	80044c4 <find_volume+0x330>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2255
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 80041fa:	2100      	movs	r1, #0
 80041fc:	4620      	mov	r0, r4
 80041fe:	f7ff ff65 	bl	80040cc <check_fs>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2256
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 8004202:	2801      	cmp	r0, #1
 8004204:	d01c      	beq.n	8004240 <find_volume+0xac>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2254
#if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
 8004206:	2600      	movs	r6, #0
 8004208:	e02e      	b.n	8004268 <find_volume+0xd4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2258
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
 800420a:	f104 0334 	add.w	r3, r4, #52	; 0x34
 800420e:	010a      	lsls	r2, r1, #4
 8004210:	f502 72df 	add.w	r2, r2, #446	; 0x1be
 8004214:	4413      	add	r3, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2259
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 8004216:	791a      	ldrb	r2, [r3, #4]
 8004218:	b152      	cbz	r2, 8004230 <find_volume+0x9c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2259 (discriminator 1)
 800421a:	7ad8      	ldrb	r0, [r3, #11]
 800421c:	7a9a      	ldrb	r2, [r3, #10]
 800421e:	0412      	lsls	r2, r2, #16
 8004220:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8004224:	7a58      	ldrb	r0, [r3, #9]
 8004226:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 800422a:	7a1b      	ldrb	r3, [r3, #8]
 800422c:	431a      	orrs	r2, r3
 800422e:	e000      	b.n	8004232 <find_volume+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2259
 8004230:	2200      	movs	r2, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2259 (discriminator 4)
 8004232:	ab04      	add	r3, sp, #16
 8004234:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8004238:	f843 2c10 	str.w	r2, [r3, #-16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2257 (discriminator 4)
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
 800423c:	3101      	adds	r1, #1
 800423e:	e000      	b.n	8004242 <find_volume+0xae>
 8004240:	2100      	movs	r1, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2257 (discriminator 2)
 8004242:	2903      	cmp	r1, #3
 8004244:	d9e1      	bls.n	800420a <find_volume+0x76>
 8004246:	2500      	movs	r5, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2264
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
 8004248:	ab04      	add	r3, sp, #16
 800424a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 800424e:	f853 6c10 	ldr.w	r6, [r3, #-16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2265
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8004252:	b126      	cbz	r6, 800425e <find_volume+0xca>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2265 (discriminator 1)
 8004254:	4631      	mov	r1, r6
 8004256:	4620      	mov	r0, r4
 8004258:	f7ff ff38 	bl	80040cc <check_fs>
 800425c:	e000      	b.n	8004260 <find_volume+0xcc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2265
 800425e:	2002      	movs	r0, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2266 (discriminator 4)
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8004260:	b110      	cbz	r0, 8004268 <find_volume+0xd4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2266 (discriminator 1)
 8004262:	3501      	adds	r5, #1
 8004264:	2d03      	cmp	r5, #3
 8004266:	d9ef      	bls.n	8004248 <find_volume+0xb4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2268
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8004268:	2803      	cmp	r0, #3
 800426a:	f000 812d 	beq.w	80044c8 <find_volume+0x334>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2269
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 800426e:	2800      	cmp	r0, #0
 8004270:	f040 812c 	bne.w	80044cc <find_volume+0x338>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2273

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8004274:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8004278:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 800427c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004280:	b21b      	sxth	r3, r3
 8004282:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004286:	f040 8123 	bne.w	80044d0 <find_volume+0x33c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2276
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
 800428a:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 800428e:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2277
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
 8004292:	ea53 2101 	orrs.w	r1, r3, r1, lsl #8
 8004296:	d10d      	bne.n	80042b4 <find_volume+0x120>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2277 (discriminator 1)
 8004298:	f894 205b 	ldrb.w	r2, [r4, #91]	; 0x5b
 800429c:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
 80042a0:	041b      	lsls	r3, r3, #16
 80042a2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80042a6:	f894 1059 	ldrb.w	r1, [r4, #89]	; 0x59
 80042aa:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80042ae:	f894 1058 	ldrb.w	r1, [r4, #88]	; 0x58
 80042b2:	4319      	orrs	r1, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2278
	fs->fsize = fasize;
 80042b4:	61e1      	str	r1, [r4, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2280

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 80042b6:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 80042ba:	70e2      	strb	r2, [r4, #3]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2281
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 80042bc:	1e53      	subs	r3, r2, #1
 80042be:	b2db      	uxtb	r3, r3
 80042c0:	2b01      	cmp	r3, #1
 80042c2:	f200 8107 	bhi.w	80044d4 <find_volume+0x340>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2283
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 80042c6:	fb01 f702 	mul.w	r7, r1, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2285

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 80042ca:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80042ce:	70a3      	strb	r3, [r4, #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2286
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 80042d0:	2b00      	cmp	r3, #0
 80042d2:	f000 8101 	beq.w	80044d8 <find_volume+0x344>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2286 (discriminator 1)
 80042d6:	1e5a      	subs	r2, r3, #1
 80042d8:	4213      	tst	r3, r2
 80042da:	f040 80ff 	bne.w	80044dc <find_volume+0x348>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2289
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 80042de:	f894 e046 	ldrb.w	lr, [r4, #70]	; 0x46
 80042e2:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 80042e6:	ea42 2e0e 	orr.w	lr, r2, lr, lsl #8
 80042ea:	f8a4 e008 	strh.w	lr, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2290
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 80042ee:	f01e 0f0f 	tst.w	lr, #15
 80042f2:	f040 80f5 	bne.w	80044e0 <find_volume+0x34c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2293
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
 80042f6:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
 80042fa:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2294
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
 80042fe:	ea52 2200 	orrs.w	r2, r2, r0, lsl #8
 8004302:	d10d      	bne.n	8004320 <find_volume+0x18c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2294 (discriminator 1)
 8004304:	f894 0057 	ldrb.w	r0, [r4, #87]	; 0x57
 8004308:	f894 2056 	ldrb.w	r2, [r4, #86]	; 0x56
 800430c:	0412      	lsls	r2, r2, #16
 800430e:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8004312:	f894 0055 	ldrb.w	r0, [r4, #85]	; 0x55
 8004316:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 800431a:	f894 2054 	ldrb.w	r2, [r4, #84]	; 0x54
 800431e:	4302      	orrs	r2, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2296

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 8004320:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
 8004324:	f894 0042 	ldrb.w	r0, [r4, #66]	; 0x42
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2297
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 8004328:	ea50 2005 	orrs.w	r0, r0, r5, lsl #8
 800432c:	f000 80e4 	beq.w	80044f8 <find_volume+0x364>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2300

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
 8004330:	eb07 0c00 	add.w	ip, r7, r0
 8004334:	eb0c 1c1e 	add.w	ip, ip, lr, lsr #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2301
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8004338:	4562      	cmp	r2, ip
 800433a:	f0c0 80df 	bcc.w	80044fc <find_volume+0x368>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2302
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 800433e:	ebcc 0202 	rsb	r2, ip, r2
 8004342:	fbb2 f3f3 	udiv	r3, r2, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2303
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8004346:	2b00      	cmp	r3, #0
 8004348:	f000 80da 	beq.w	8004500 <find_volume+0x36c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2305
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 800434c:	f640 72f5 	movw	r2, #4085	; 0xff5
 8004350:	4293      	cmp	r3, r2
 8004352:	d801      	bhi.n	8004358 <find_volume+0x1c4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2304
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
 8004354:	2501      	movs	r5, #1
 8004356:	e000      	b.n	800435a <find_volume+0x1c6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2305
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8004358:	2502      	movs	r5, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2306
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 800435a:	f64f 72f5 	movw	r2, #65525	; 0xfff5
 800435e:	4293      	cmp	r3, r2
 8004360:	d900      	bls.n	8004364 <find_volume+0x1d0>
 8004362:	2503      	movs	r5, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2309

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004364:	3302      	adds	r3, #2
 8004366:	61a3      	str	r3, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2310
	fs->volbase = bsect;								/* Volume start sector */
 8004368:	6226      	str	r6, [r4, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2311
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800436a:	1832      	adds	r2, r6, r0
 800436c:	6262      	str	r2, [r4, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2312
	fs->database = bsect + sysect;						/* Data start sector */
 800436e:	eb06 000c 	add.w	r0, r6, ip
 8004372:	62e0      	str	r0, [r4, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2313
	if (fmt == FS_FAT32) {
 8004374:	2d03      	cmp	r5, #3
 8004376:	d114      	bne.n	80043a2 <find_volume+0x20e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2314
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8004378:	f1be 0f00 	cmp.w	lr, #0
 800437c:	f040 80c2 	bne.w	8004504 <find_volume+0x370>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2315
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
 8004380:	f894 0063 	ldrb.w	r0, [r4, #99]	; 0x63
 8004384:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
 8004388:	0412      	lsls	r2, r2, #16
 800438a:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 800438e:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
 8004392:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8004396:	f894 0060 	ldrb.w	r0, [r4, #96]	; 0x60
 800439a:	4302      	orrs	r2, r0
 800439c:	62a2      	str	r2, [r4, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2316
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
 800439e:	009b      	lsls	r3, r3, #2
 80043a0:	e00f      	b.n	80043c2 <find_volume+0x22e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2318
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 80043a2:	f1be 0f00 	cmp.w	lr, #0
 80043a6:	f000 80af 	beq.w	8004508 <find_volume+0x374>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2319
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 80043aa:	443a      	add	r2, r7
 80043ac:	62a2      	str	r2, [r4, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2321
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 80043ae:	2d02      	cmp	r5, #2
 80043b0:	d101      	bne.n	80043b6 <find_volume+0x222>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2321 (discriminator 1)
 80043b2:	005b      	lsls	r3, r3, #1
 80043b4:	e005      	b.n	80043c2 <find_volume+0x22e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2321 (discriminator 2)
 80043b6:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 80043ba:	f003 0301 	and.w	r3, r3, #1
 80043be:	eb03 0352 	add.w	r3, r3, r2, lsr #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2323
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
 80043c2:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 80043c6:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
 80043ca:	f0c0 809f 	bcc.w	800450c <find_volume+0x378>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2328
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 80043ce:	f04f 33ff 	mov.w	r3, #4294967295
 80043d2:	6123      	str	r3, [r4, #16]
 80043d4:	60e3      	str	r3, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2331

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 80043d6:	2380      	movs	r3, #128	; 0x80
 80043d8:	7163      	strb	r3, [r4, #5]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2333
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
 80043da:	2d03      	cmp	r5, #3
 80043dc:	d15a      	bne.n	8004494 <find_volume+0x300>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2334
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
 80043de:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
 80043e2:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 80043e6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80043ea:	b21b      	sxth	r3, r3
 80043ec:	2b01      	cmp	r3, #1
 80043ee:	d151      	bne.n	8004494 <find_volume+0x300>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2335
		&& move_window(fs, bsect + 1) == FR_OK)
 80043f0:	1c71      	adds	r1, r6, #1
 80043f2:	4620      	mov	r0, r4
 80043f4:	f7ff fe50 	bl	8004098 <move_window>
 80043f8:	2800      	cmp	r0, #0
 80043fa:	d14b      	bne.n	8004494 <find_volume+0x300>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2337
	{
		fs->fsi_flag = 0;
 80043fc:	2300      	movs	r3, #0
 80043fe:	7163      	strb	r3, [r4, #5]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2338
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8004400:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
 8004404:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
 8004408:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800440c:	b21b      	sxth	r3, r3
 800440e:	4a36      	ldr	r2, [pc, #216]	; (80044e8 <find_volume+0x354>)
 8004410:	4293      	cmp	r3, r2
 8004412:	d13f      	bne.n	8004494 <find_volume+0x300>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2339
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
 8004414:	f894 2037 	ldrb.w	r2, [r4, #55]	; 0x37
 8004418:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 800441c:	041b      	lsls	r3, r3, #16
 800441e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004422:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8004426:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800442a:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 800442e:	4313      	orrs	r3, r2
 8004430:	4a2e      	ldr	r2, [pc, #184]	; (80044ec <find_volume+0x358>)
 8004432:	4293      	cmp	r3, r2
 8004434:	d12e      	bne.n	8004494 <find_volume+0x300>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2340
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
 8004436:	f894 221b 	ldrb.w	r2, [r4, #539]	; 0x21b
 800443a:	f894 321a 	ldrb.w	r3, [r4, #538]	; 0x21a
 800443e:	041b      	lsls	r3, r3, #16
 8004440:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004444:	f894 2219 	ldrb.w	r2, [r4, #537]	; 0x219
 8004448:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800444c:	f894 2218 	ldrb.w	r2, [r4, #536]	; 0x218
 8004450:	4313      	orrs	r3, r2
 8004452:	4a27      	ldr	r2, [pc, #156]	; (80044f0 <find_volume+0x35c>)
 8004454:	4293      	cmp	r3, r2
 8004456:	d11d      	bne.n	8004494 <find_volume+0x300>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2343
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
 8004458:	f894 221f 	ldrb.w	r2, [r4, #543]	; 0x21f
 800445c:	f894 321e 	ldrb.w	r3, [r4, #542]	; 0x21e
 8004460:	041b      	lsls	r3, r3, #16
 8004462:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004466:	f894 221d 	ldrb.w	r2, [r4, #541]	; 0x21d
 800446a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800446e:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
 8004472:	4313      	orrs	r3, r2
 8004474:	6123      	str	r3, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2346
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
 8004476:	f894 2223 	ldrb.w	r2, [r4, #547]	; 0x223
 800447a:	f894 3222 	ldrb.w	r3, [r4, #546]	; 0x222
 800447e:	041b      	lsls	r3, r3, #16
 8004480:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004484:	f894 2221 	ldrb.w	r2, [r4, #545]	; 0x221
 8004488:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800448c:	f894 2220 	ldrb.w	r2, [r4, #544]	; 0x220
 8004490:	4313      	orrs	r3, r2
 8004492:	60e3      	str	r3, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2352
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
 8004494:	7025      	strb	r5, [r4, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2353
	fs->id = ++Fsid;	/* File system mount ID */
 8004496:	4a17      	ldr	r2, [pc, #92]	; (80044f4 <find_volume+0x360>)
 8004498:	8813      	ldrh	r3, [r2, #0]
 800449a:	3301      	adds	r3, #1
 800449c:	b29b      	uxth	r3, r3
 800449e:	8013      	strh	r3, [r2, #0]
 80044a0:	80e3      	strh	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2355
#if _FS_RPATH
	fs->cdir = 0;		/* Set current directory to root */
 80044a2:	2500      	movs	r5, #0
 80044a4:	6165      	str	r5, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2358
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
 80044a6:	4620      	mov	r0, r4
 80044a8:	f7ff fcb2 	bl	8003e10 <clear_lock>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2361
#endif

	return FR_OK;
 80044ac:	4628      	mov	r0, r5
 80044ae:	e02e      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2221


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 80044b0:	200b      	movs	r0, #11
 80044b2:	e02c      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2225

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80044b4:	200c      	movs	r0, #12
 80044b6:	e02a      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2235
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
 80044b8:	2000      	movs	r0, #0
 80044ba:	e028      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2234

	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
 80044bc:	200a      	movs	r0, #10
 80044be:	e026      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2246

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 80044c0:	2003      	movs	r0, #3
 80044c2:	e024      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2248
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
 80044c4:	200a      	movs	r0, #10
 80044c6:	e022      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2268
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80044c8:	2001      	movs	r0, #1
 80044ca:	e020      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2269
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 80044cc:	200d      	movs	r0, #13
 80044ce:	e01e      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2274

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
 80044d0:	200d      	movs	r0, #13
 80044d2:	e01c      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2282
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
 80044d4:	200d      	movs	r0, #13
 80044d6:	e01a      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2287
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
		return FR_NO_FILESYSTEM;
 80044d8:	200d      	movs	r0, #13
 80044da:	e018      	b.n	800450e <find_volume+0x37a>
 80044dc:	200d      	movs	r0, #13
 80044de:	e016      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2291

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
		return FR_NO_FILESYSTEM;
 80044e0:	200d      	movs	r0, #13
 80044e2:	e014      	b.n	800450e <find_volume+0x37a>
 80044e4:	20001ab4 	.word	0x20001ab4
 80044e8:	ffffaa55 	.word	0xffffaa55
 80044ec:	41615252 	.word	0x41615252
 80044f0:	61417272 	.word	0x61417272
 80044f4:	20001ab0 	.word	0x20001ab0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2297

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 80044f8:	200d      	movs	r0, #13
 80044fa:	e008      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2301

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 80044fc:	200d      	movs	r0, #13
 80044fe:	e006      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2303
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8004500:	200d      	movs	r0, #13
 8004502:	e004      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2314
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	fs->database = bsect + sysect;						/* Data start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8004504:	200d      	movs	r0, #13
 8004506:	e002      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2318
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8004508:	200d      	movs	r0, #13
 800450a:	e000      	b.n	800450e <find_volume+0x37a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2324
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
		return FR_NO_FILESYSTEM;
 800450c:	200d      	movs	r0, #13
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2362
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
 800450e:	b005      	add	sp, #20
 8004510:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004512:	bf00      	nop

08004514 <create_name>:
create_name():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1847
static
FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
 8004514:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004518:	b083      	sub	sp, #12
 800451a:	4606      	mov	r6, r0
 800451c:	4688      	mov	r8, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1855
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 800451e:	680f      	ldr	r7, [r1, #0]
 8004520:	e000      	b.n	8004524 <create_name+0x10>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1855 (discriminator 5)
 8004522:	3701      	adds	r7, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1855 (discriminator 1)
 8004524:	783b      	ldrb	r3, [r7, #0]
 8004526:	b25a      	sxtb	r2, r3
 8004528:	2a2f      	cmp	r2, #47	; 0x2f
 800452a:	d0fa      	beq.n	8004522 <create_name+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1855 (discriminator 4)
 800452c:	2a5c      	cmp	r2, #92	; 0x5c
 800452e:	d0f8      	beq.n	8004522 <create_name+0xe>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1856
	lfn = dp->lfn;
 8004530:	6a35      	ldr	r5, [r6, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1857
	si = di = 0;
 8004532:	2400      	movs	r4, #0
 8004534:	4623      	mov	r3, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1859
	for (;;) {
		w = p[si++];					/* Get a character */
 8004536:	f103 0901 	add.w	r9, r3, #1
 800453a:	56f8      	ldrsb	r0, [r7, r3]
 800453c:	b280      	uxth	r0, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1860
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 800453e:	281f      	cmp	r0, #31
 8004540:	d91c      	bls.n	800457c <create_name+0x68>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1860 (discriminator 1)
 8004542:	282f      	cmp	r0, #47	; 0x2f
 8004544:	d01a      	beq.n	800457c <create_name+0x68>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1860 (discriminator 2)
 8004546:	285c      	cmp	r0, #92	; 0x5c
 8004548:	d018      	beq.n	800457c <create_name+0x68>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1861
		if (di >= _MAX_LFN)				/* Reject too long name */
 800454a:	2cfe      	cmp	r4, #254	; 0xfe
 800454c:	f200 8112 	bhi.w	8004774 <create_name+0x260>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1871
			b = (BYTE)p[si++];			/* Get 2nd byte */
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 8004550:	2101      	movs	r1, #1
 8004552:	b2c0      	uxtb	r0, r0
 8004554:	f001 fbc4 	bl	8005ce0 <ff_convert>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1872
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8004558:	4682      	mov	sl, r0
 800455a:	2800      	cmp	r0, #0
 800455c:	f000 810c 	beq.w	8004778 <create_name+0x264>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1874
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
 8004560:	287f      	cmp	r0, #127	; 0x7f
 8004562:	d806      	bhi.n	8004572 <create_name+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1874 (discriminator 1)
 8004564:	4601      	mov	r1, r0
 8004566:	4888      	ldr	r0, [pc, #544]	; (8004788 <create_name+0x274>)
 8004568:	f7ff fb6e 	bl	8003c48 <chk_chr>
 800456c:	2800      	cmp	r0, #0
 800456e:	f040 8105 	bne.w	800477c <create_name+0x268>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1876
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
 8004572:	f825 a014 	strh.w	sl, [r5, r4, lsl #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1859
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
 8004576:	464b      	mov	r3, r9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1876
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
 8004578:	3401      	adds	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1877
	}
 800457a:	e7dc      	b.n	8004536 <create_name+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1878
	*path = &p[si];						/* Return pointer to the next segment */
 800457c:	444f      	add	r7, r9
 800457e:	f8c8 7000 	str.w	r7, [r8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1879
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004582:	281f      	cmp	r0, #31
 8004584:	d802      	bhi.n	800458c <create_name+0x78>
 8004586:	f04f 0804 	mov.w	r8, #4
 800458a:	e001      	b.n	8004590 <create_name+0x7c>
 800458c:	f04f 0800 	mov.w	r8, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1881 (discriminator 4)
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') ||
 8004590:	2c01      	cmp	r4, #1
 8004592:	d106      	bne.n	80045a2 <create_name+0x8e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1881 (discriminator 1)
 8004594:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
 8004598:	3b01      	subs	r3, #1
 800459a:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 800459e:	2b2e      	cmp	r3, #46	; 0x2e
 80045a0:	d00f      	beq.n	80045c2 <create_name+0xae>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1881 (discriminator 3)
 80045a2:	2c02      	cmp	r4, #2
 80045a4:	d12d      	bne.n	8004602 <create_name+0xee>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1882
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot entry? */
 80045a6:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
 80045aa:	3b01      	subs	r3, #1
 80045ac:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 80045b0:	2b2e      	cmp	r3, #46	; 0x2e
 80045b2:	d126      	bne.n	8004602 <create_name+0xee>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1882 (discriminator 1)
 80045b4:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
 80045b8:	3b02      	subs	r3, #2
 80045ba:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 80045be:	2b2e      	cmp	r3, #46	; 0x2e
 80045c0:	d11f      	bne.n	8004602 <create_name+0xee>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1883
		lfn[di] = 0;
 80045c2:	2300      	movs	r3, #0
 80045c4:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1884
		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
 80045c8:	e008      	b.n	80045dc <create_name+0xc8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1885
			dp->fn[i] = (i < di) ? '.' : ' ';
 80045ca:	69b2      	ldr	r2, [r6, #24]
 80045cc:	441a      	add	r2, r3
 80045ce:	42a3      	cmp	r3, r4
 80045d0:	d201      	bcs.n	80045d6 <create_name+0xc2>
 80045d2:	212e      	movs	r1, #46	; 0x2e
 80045d4:	e000      	b.n	80045d8 <create_name+0xc4>
 80045d6:	2120      	movs	r1, #32
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1885 (discriminator 4)
 80045d8:	7011      	strb	r1, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1884 (discriminator 4)
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') ||
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot entry? */
		lfn[di] = 0;
		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
 80045da:	3301      	adds	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1884 (discriminator 2)
 80045dc:	2b0a      	cmp	r3, #10
 80045de:	d9f4      	bls.n	80045ca <create_name+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1886
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 80045e0:	69b2      	ldr	r2, [r6, #24]
 80045e2:	f048 0820 	orr.w	r8, r8, #32
 80045e6:	f802 8003 	strb.w	r8, [r2, r3]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1887
		return FR_OK;
 80045ea:	2000      	movs	r0, #0
 80045ec:	e0c9      	b.n	8004782 <create_name+0x26e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1891
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
		w = lfn[di - 1];
 80045ee:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
 80045f2:	3b01      	subs	r3, #1
 80045f4:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1892
		if (w != ' ' && w != '.') break;
 80045f8:	2b20      	cmp	r3, #32
 80045fa:	d001      	beq.n	8004600 <create_name+0xec>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1892 (discriminator 1)
 80045fc:	2b2e      	cmp	r3, #46	; 0x2e
 80045fe:	d102      	bne.n	8004606 <create_name+0xf2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1893
		di--;
 8004600:	3c01      	subs	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1890
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8004602:	2c00      	cmp	r4, #0
 8004604:	d1f3      	bne.n	80045ee <create_name+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1895
		w = lfn[di - 1];
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
 8004606:	2c00      	cmp	r4, #0
 8004608:	f000 80ba 	beq.w	8004780 <create_name+0x26c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1896
	lfn[di] = 0;						/* LFN is created */
 800460c:	2700      	movs	r7, #0
 800460e:	f825 7014 	strh.w	r7, [r5, r4, lsl #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1899

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 8004612:	220b      	movs	r2, #11
 8004614:	2120      	movs	r1, #32
 8004616:	69b0      	ldr	r0, [r6, #24]
 8004618:	f7ff fafc 	bl	8003c14 <mem_set>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1900
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800461c:	463b      	mov	r3, r7
 800461e:	e000      	b.n	8004622 <create_name+0x10e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1900 (discriminator 5)
 8004620:	3301      	adds	r3, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1900 (discriminator 1)
 8004622:	f835 2013 	ldrh.w	r2, [r5, r3, lsl #1]
 8004626:	2a20      	cmp	r2, #32
 8004628:	d0fa      	beq.n	8004620 <create_name+0x10c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1900 (discriminator 4)
 800462a:	2a2e      	cmp	r2, #46	; 0x2e
 800462c:	d0f8      	beq.n	8004620 <create_name+0x10c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1901
	if (si) cf |= NS_LOSS | NS_LFN;
 800462e:	b11b      	cbz	r3, 8004638 <create_name+0x124>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1901 (discriminator 1)
 8004630:	f048 0803 	orr.w	r8, r8, #3
 8004634:	e000      	b.n	8004638 <create_name+0x124>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1902 (discriminator 3)
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 8004636:	3c01      	subs	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1902 (discriminator 1)
 8004638:	b16c      	cbz	r4, 8004656 <create_name+0x142>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1902 (discriminator 2)
 800463a:	f104 4200 	add.w	r2, r4, #2147483648	; 0x80000000
 800463e:	3a01      	subs	r2, #1
 8004640:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8004644:	2a2e      	cmp	r2, #46	; 0x2e
 8004646:	d1f6      	bne.n	8004636 <create_name+0x122>
 8004648:	f04f 0b08 	mov.w	fp, #8
 800464c:	f04f 0a00 	mov.w	sl, #0
 8004650:	f8cd a004 	str.w	sl, [sp, #4]
 8004654:	e005      	b.n	8004662 <create_name+0x14e>
 8004656:	f04f 0b08 	mov.w	fp, #8
 800465a:	f04f 0a00 	mov.w	sl, #0
 800465e:	f8cd a004 	str.w	sl, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1906

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 8004662:	f103 0901 	add.w	r9, r3, #1
 8004666:	f835 7013 	ldrh.w	r7, [r5, r3, lsl #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1907
		if (!w) break;					/* Break on end of the LFN */
 800466a:	2f00      	cmp	r7, #0
 800466c:	d057      	beq.n	800471e <create_name+0x20a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1908
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 800466e:	2f20      	cmp	r7, #32
 8004670:	d003      	beq.n	800467a <create_name+0x166>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1908 (discriminator 1)
 8004672:	2f2e      	cmp	r7, #46	; 0x2e
 8004674:	d105      	bne.n	8004682 <create_name+0x16e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1908 (discriminator 2)
 8004676:	454c      	cmp	r4, r9
 8004678:	d003      	beq.n	8004682 <create_name+0x16e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1909
			cf |= NS_LOSS | NS_LFN; continue;
 800467a:	f048 0803 	orr.w	r8, r8, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1906
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 800467e:	464b      	mov	r3, r9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1909
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
 8004680:	e7ef      	b.n	8004662 <create_name+0x14e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1912
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8004682:	45da      	cmp	sl, fp
 8004684:	d201      	bcs.n	800468a <create_name+0x176>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1912 (discriminator 1)
 8004686:	454c      	cmp	r4, r9
 8004688:	d115      	bne.n	80046b6 <create_name+0x1a2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1913
			if (ni == 11) {				/* Long extension */
 800468a:	f1bb 0f0b 	cmp.w	fp, #11
 800468e:	d102      	bne.n	8004696 <create_name+0x182>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1914
				cf |= NS_LOSS | NS_LFN; break;
 8004690:	f048 0803 	orr.w	r8, r8, #3
 8004694:	e043      	b.n	800471e <create_name+0x20a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1916
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 8004696:	454c      	cmp	r4, r9
 8004698:	d001      	beq.n	800469e <create_name+0x18a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1916 (discriminator 1)
 800469a:	f048 0803 	orr.w	r8, r8, #3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1917
			if (si > di) break;			/* No extension */
 800469e:	454c      	cmp	r4, r9
 80046a0:	d33d      	bcc.n	800471e <create_name+0x20a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1919
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
 80046a2:	9b01      	ldr	r3, [sp, #4]
 80046a4:	009b      	lsls	r3, r3, #2
 80046a6:	b2db      	uxtb	r3, r3
 80046a8:	9301      	str	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1918
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 80046aa:	4623      	mov	r3, r4
 80046ac:	f04f 0b0b 	mov.w	fp, #11
 80046b0:	f04f 0a08 	mov.w	sl, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1919
			b <<= 2; continue;
 80046b4:	e7d5      	b.n	8004662 <create_name+0x14e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1922
		}

		if (w >= 0x80) {				/* Non ASCII character */
 80046b6:	2f7f      	cmp	r7, #127	; 0x7f
 80046b8:	d90b      	bls.n	80046d2 <create_name+0x1be>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1924
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 80046ba:	2100      	movs	r1, #0
 80046bc:	4638      	mov	r0, r7
 80046be:	f001 fb0f 	bl	8005ce0 <ff_convert>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1925
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 80046c2:	4607      	mov	r7, r0
 80046c4:	b118      	cbz	r0, 80046ce <create_name+0x1ba>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1925 (discriminator 1)
 80046c6:	f1a0 0780 	sub.w	r7, r0, #128	; 0x80
 80046ca:	4b30      	ldr	r3, [pc, #192]	; (800478c <create_name+0x278>)
 80046cc:	5ddf      	ldrb	r7, [r3, r7]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1929
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 80046ce:	f048 0802 	orr.w	r8, r8, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1938
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 80046d2:	b127      	cbz	r7, 80046de <create_name+0x1ca>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1938 (discriminator 1)
 80046d4:	4639      	mov	r1, r7
 80046d6:	482e      	ldr	r0, [pc, #184]	; (8004790 <create_name+0x27c>)
 80046d8:	f7ff fab6 	bl	8003c48 <chk_chr>
 80046dc:	b118      	cbz	r0, 80046e6 <create_name+0x1d2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1939
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 80046de:	f048 0803 	orr.w	r8, r8, #3
 80046e2:	275f      	movs	r7, #95	; 0x5f
 80046e4:	e014      	b.n	8004710 <create_name+0x1fc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1941
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 80046e6:	f1a7 0341 	sub.w	r3, r7, #65	; 0x41
 80046ea:	b29b      	uxth	r3, r3
 80046ec:	2b19      	cmp	r3, #25
 80046ee:	d804      	bhi.n	80046fa <create_name+0x1e6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1942
					b |= 2;
 80046f0:	9b01      	ldr	r3, [sp, #4]
 80046f2:	f043 0302 	orr.w	r3, r3, #2
 80046f6:	9301      	str	r3, [sp, #4]
 80046f8:	e00a      	b.n	8004710 <create_name+0x1fc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1944
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 80046fa:	f1a7 0361 	sub.w	r3, r7, #97	; 0x61
 80046fe:	b29b      	uxth	r3, r3
 8004700:	2b19      	cmp	r3, #25
 8004702:	d805      	bhi.n	8004710 <create_name+0x1fc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1945
						b |= 1; w -= 0x20;
 8004704:	9b01      	ldr	r3, [sp, #4]
 8004706:	f043 0301 	orr.w	r3, r3, #1
 800470a:	9301      	str	r3, [sp, #4]
 800470c:	3f20      	subs	r7, #32
 800470e:	b2bf      	uxth	r7, r7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1950
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 8004710:	69b3      	ldr	r3, [r6, #24]
 8004712:	f803 700a 	strb.w	r7, [r3, sl]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1906
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 8004716:	464b      	mov	r3, r9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1950
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 8004718:	f10a 0a01 	add.w	sl, sl, #1
 800471c:	e7a1      	b.n	8004662 <create_name+0x14e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1953
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800471e:	69b3      	ldr	r3, [r6, #24]
 8004720:	781a      	ldrb	r2, [r3, #0]
 8004722:	2ae5      	cmp	r2, #229	; 0xe5
 8004724:	d101      	bne.n	800472a <create_name+0x216>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1953 (discriminator 1)
 8004726:	2205      	movs	r2, #5
 8004728:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1955

	if (ni == 8) b <<= 2;
 800472a:	f1bb 0f08 	cmp.w	fp, #8
 800472e:	d103      	bne.n	8004738 <create_name+0x224>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1955 (discriminator 1)
 8004730:	9b01      	ldr	r3, [sp, #4]
 8004732:	009b      	lsls	r3, r3, #2
 8004734:	b2db      	uxtb	r3, r3
 8004736:	9301      	str	r3, [sp, #4]
 8004738:	9901      	ldr	r1, [sp, #4]
 800473a:	f001 020c 	and.w	r2, r1, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1956
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
 800473e:	2a0c      	cmp	r2, #12
 8004740:	d003      	beq.n	800474a <create_name+0x236>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1956 (discriminator 1)
 8004742:	f001 0303 	and.w	r3, r1, #3
 8004746:	2b03      	cmp	r3, #3
 8004748:	d101      	bne.n	800474e <create_name+0x23a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1957
		cf |= NS_LFN;
 800474a:	f048 0802 	orr.w	r8, r8, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1958
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800474e:	f018 0f02 	tst.w	r8, #2
 8004752:	d10a      	bne.n	800476a <create_name+0x256>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1959
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 8004754:	9b01      	ldr	r3, [sp, #4]
 8004756:	f003 0303 	and.w	r3, r3, #3
 800475a:	2b01      	cmp	r3, #1
 800475c:	d101      	bne.n	8004762 <create_name+0x24e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1959 (discriminator 1)
 800475e:	f048 0810 	orr.w	r8, r8, #16
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1960
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8004762:	2a04      	cmp	r2, #4
 8004764:	d101      	bne.n	800476a <create_name+0x256>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1960 (discriminator 1)
 8004766:	f048 0808 	orr.w	r8, r8, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1963
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800476a:	69b3      	ldr	r3, [r6, #24]
 800476c:	f883 800b 	strb.w	r8, [r3, #11]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1965

	return FR_OK;
 8004770:	2000      	movs	r0, #0
 8004772:	e006      	b.n	8004782 <create_name+0x26e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1862
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
		if (di >= _MAX_LFN)				/* Reject too long name */
			return FR_INVALID_NAME;
 8004774:	2006      	movs	r0, #6
 8004776:	e004      	b.n	8004782 <create_name+0x26e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1872
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8004778:	2006      	movs	r0, #6
 800477a:	e002      	b.n	8004782 <create_name+0x26e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1875
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
 800477c:	2006      	movs	r0, #6
 800477e:	e000      	b.n	8004782 <create_name+0x26e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1895
	while (di) {						/* Snip off trailing spaces and dots if exist */
		w = lfn[di - 1];
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
 8004780:	2006      	movs	r0, #6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2042

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */

	return FR_OK;
#endif
}
 8004782:	b003      	add	sp, #12
 8004784:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004788:	0800689c 	.word	0x0800689c
 800478c:	0800681c 	.word	0x0800681c
 8004790:	080068a8 	.word	0x080068a8

08004794 <cmp_lfn>:
cmp_lfn():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1283
{
	UINT i, s;
	WCHAR wc, uc;


	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 8004794:	7eca      	ldrb	r2, [r1, #27]
 8004796:	7e8b      	ldrb	r3, [r1, #26]
 8004798:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 800479c:	d139      	bne.n	8004812 <cmp_lfn+0x7e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1278
static
int cmp_lfn (			/* 1:matched, 0:not matched */
	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer to be compared */
	BYTE* dir			/* Pointer to the directory entry containing the part of LFN */
)
{
 800479e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80047a2:	460f      	mov	r7, r1
 80047a4:	4680      	mov	r8, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1285
	WCHAR wc, uc;


	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80047a6:	780e      	ldrb	r6, [r1, #0]
 80047a8:	f006 063f 	and.w	r6, r6, #63	; 0x3f
 80047ac:	1e73      	subs	r3, r6, #1
 80047ae:	eb03 0643 	add.w	r6, r3, r3, lsl #1
 80047b2:	eb03 0686 	add.w	r6, r3, r6, lsl #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1287

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 80047b6:	2101      	movs	r1, #1
 80047b8:	2500      	movs	r5, #0
 80047ba:	e01d      	b.n	80047f8 <cmp_lfn+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1288
		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character */
 80047bc:	4b1f      	ldr	r3, [pc, #124]	; (800483c <cmp_lfn+0xa8>)
 80047be:	5d5b      	ldrb	r3, [r3, r5]
 80047c0:	1c5a      	adds	r2, r3, #1
 80047c2:	5cbc      	ldrb	r4, [r7, r2]
 80047c4:	5cfb      	ldrb	r3, [r7, r3]
 80047c6:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1289
		if (wc) {
 80047ca:	b181      	cbz	r1, 80047ee <cmp_lfn+0x5a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1290
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 80047cc:	2efe      	cmp	r6, #254	; 0xfe
 80047ce:	d822      	bhi.n	8004816 <cmp_lfn+0x82>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1290 (discriminator 1)
 80047d0:	4620      	mov	r0, r4
 80047d2:	f001 faa3 	bl	8005d1c <ff_wtoupper>
 80047d6:	4681      	mov	r9, r0
 80047d8:	f106 0a01 	add.w	sl, r6, #1
 80047dc:	f838 0016 	ldrh.w	r0, [r8, r6, lsl #1]
 80047e0:	f001 fa9c 	bl	8005d1c <ff_wtoupper>
 80047e4:	4581      	cmp	r9, r0
 80047e6:	d119      	bne.n	800481c <cmp_lfn+0x88>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1292
				return 0;					/* Not matched */
			wc = uc;
 80047e8:	4621      	mov	r1, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1290
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character */
		if (wc) {
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 80047ea:	4656      	mov	r6, sl
 80047ec:	e003      	b.n	80047f6 <cmp_lfn+0x62>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1294
				return 0;					/* Not matched */
			wc = uc;
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 80047ee:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80047f2:	429c      	cmp	r4, r3
 80047f4:	d115      	bne.n	8004822 <cmp_lfn+0x8e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1287 (discriminator 2)

	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 80047f6:	3501      	adds	r5, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1287 (discriminator 1)
 80047f8:	2d0c      	cmp	r5, #12
 80047fa:	d9df      	bls.n	80047bc <cmp_lfn+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1298
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
 80047fc:	783b      	ldrb	r3, [r7, #0]
 80047fe:	f013 0f40 	tst.w	r3, #64	; 0x40
 8004802:	d011      	beq.n	8004828 <cmp_lfn+0x94>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1298 (discriminator 1)
 8004804:	b199      	cbz	r1, 800482e <cmp_lfn+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1298 (discriminator 2)
 8004806:	f838 3016 	ldrh.w	r3, [r8, r6, lsl #1]
 800480a:	b99b      	cbnz	r3, 8004834 <cmp_lfn+0xa0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1301
		return 0;

	return 1;		/* The part of LFN matched */
 800480c:	2001      	movs	r0, #1
 800480e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1283
{
	UINT i, s;
	WCHAR wc, uc;


	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 8004812:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1302

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
		return 0;

	return 1;		/* The part of LFN matched */
}
 8004814:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1291

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character */
		if (wc) {
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;					/* Not matched */
 8004816:	2000      	movs	r0, #0
 8004818:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800481c:	2000      	movs	r0, #0
 800481e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1294
			wc = uc;
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004822:	2000      	movs	r0, #0
 8004824:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1301
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
		return 0;

	return 1;		/* The part of LFN matched */
 8004828:	2001      	movs	r0, #1
 800482a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800482e:	2001      	movs	r0, #1
 8004830:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1299
			if (uc != 0xFFFF) return 0;		/* Check filler */
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
		return 0;
 8004834:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1302

	return 1;		/* The part of LFN matched */
}
 8004836:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800483a:	bf00      	nop
 800483c:	0800693c 	.word	0x0800693c

08004840 <sync_fs>:
sync_fs():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:763
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
 8004840:	b570      	push	{r4, r5, r6, lr}
 8004842:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:767
	FRESULT res;


	res = sync_window(fs);
 8004844:	f7ff fbfe 	bl	8004044 <sync_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:768
	if (res == FR_OK) {
 8004848:	4605      	mov	r5, r0
 800484a:	2800      	cmp	r0, #0
 800484c:	d154      	bne.n	80048f8 <sync_fs+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:770
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 800484e:	7823      	ldrb	r3, [r4, #0]
 8004850:	2b03      	cmp	r3, #3
 8004852:	d14a      	bne.n	80048ea <sync_fs+0xaa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:770 (discriminator 1)
 8004854:	7963      	ldrb	r3, [r4, #5]
 8004856:	2b01      	cmp	r3, #1
 8004858:	d147      	bne.n	80048ea <sync_fs+0xaa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:772
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
 800485a:	f104 0634 	add.w	r6, r4, #52	; 0x34
 800485e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004862:	2100      	movs	r1, #0
 8004864:	4630      	mov	r0, r6
 8004866:	f7ff f9d5 	bl	8003c14 <mem_set>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:773
			ST_WORD(fs->win + BS_55AA, 0xAA55);
 800486a:	2355      	movs	r3, #85	; 0x55
 800486c:	f884 3232 	strb.w	r3, [r4, #562]	; 0x232
 8004870:	23aa      	movs	r3, #170	; 0xaa
 8004872:	f884 3233 	strb.w	r3, [r4, #563]	; 0x233
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:774
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
 8004876:	2352      	movs	r3, #82	; 0x52
 8004878:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800487c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 8004880:	2361      	movs	r3, #97	; 0x61
 8004882:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
 8004886:	2241      	movs	r2, #65	; 0x41
 8004888:	f884 2037 	strb.w	r2, [r4, #55]	; 0x37
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:775
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
 800488c:	2172      	movs	r1, #114	; 0x72
 800488e:	f884 1218 	strb.w	r1, [r4, #536]	; 0x218
 8004892:	f884 1219 	strb.w	r1, [r4, #537]	; 0x219
 8004896:	f884 221a 	strb.w	r2, [r4, #538]	; 0x21a
 800489a:	f884 321b 	strb.w	r3, [r4, #539]	; 0x21b
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:776
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
 800489e:	6923      	ldr	r3, [r4, #16]
 80048a0:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
 80048a4:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80048a8:	f884 221d 	strb.w	r2, [r4, #541]	; 0x21d
 80048ac:	f3c3 4207 	ubfx	r2, r3, #16, #8
 80048b0:	f884 221e 	strb.w	r2, [r4, #542]	; 0x21e
 80048b4:	0e1b      	lsrs	r3, r3, #24
 80048b6:	f884 321f 	strb.w	r3, [r4, #543]	; 0x21f
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:777
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
 80048ba:	68e3      	ldr	r3, [r4, #12]
 80048bc:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
 80048c0:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80048c4:	f884 2221 	strb.w	r2, [r4, #545]	; 0x221
 80048c8:	f3c3 4207 	ubfx	r2, r3, #16, #8
 80048cc:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
 80048d0:	0e1b      	lsrs	r3, r3, #24
 80048d2:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:779
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
 80048d6:	6a22      	ldr	r2, [r4, #32]
 80048d8:	3201      	adds	r2, #1
 80048da:	6322      	str	r2, [r4, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:780
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 80048dc:	2301      	movs	r3, #1
 80048de:	4631      	mov	r1, r6
 80048e0:	7860      	ldrb	r0, [r4, #1]
 80048e2:	f7fe fb4b 	bl	8002f7c <disk_write>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:781
			fs->fsi_flag = 0;
 80048e6:	2300      	movs	r3, #0
 80048e8:	7163      	strb	r3, [r4, #5]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:784
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 80048ea:	2200      	movs	r2, #0
 80048ec:	4611      	mov	r1, r2
 80048ee:	7860      	ldrb	r0, [r4, #1]
 80048f0:	f7fe fb5c 	bl	8002fac <disk_ioctl>
 80048f4:	b100      	cbz	r0, 80048f8 <sync_fs+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:785
			res = FR_DISK_ERR;
 80048f6:	2501      	movs	r5, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:789
	}

	return res;
}
 80048f8:	4628      	mov	r0, r5
 80048fa:	bd70      	pop	{r4, r5, r6, pc}

080048fc <clust2sect>:
clust2sect():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:805
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 80048fc:	3902      	subs	r1, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:806
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80048fe:	6983      	ldr	r3, [r0, #24]
 8004900:	3b02      	subs	r3, #2
 8004902:	4299      	cmp	r1, r3
 8004904:	d204      	bcs.n	8004910 <clust2sect+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:807
	return clst * fs->csize + fs->database;
 8004906:	7883      	ldrb	r3, [r0, #2]
 8004908:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800490a:	fb01 0003 	mla	r0, r1, r3, r0
 800490e:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:806
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004910:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:808
	return clst * fs->csize + fs->database;
}
 8004912:	4770      	bx	lr

08004914 <get_fat>:
get_fat():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:828
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8004914:	2901      	cmp	r1, #1
 8004916:	d960      	bls.n	80049da <get_fat+0xc6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:822 (discriminator 1)

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
 8004918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:828 (discriminator 1)
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800491a:	6983      	ldr	r3, [r0, #24]
 800491c:	4299      	cmp	r1, r3
 800491e:	d25e      	bcs.n	80049de <get_fat+0xca>
 8004920:	460c      	mov	r4, r1
 8004922:	4606      	mov	r6, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:834
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
 8004924:	7803      	ldrb	r3, [r0, #0]
 8004926:	2b02      	cmp	r3, #2
 8004928:	d029      	beq.n	800497e <get_fat+0x6a>
 800492a:	2b03      	cmp	r3, #3
 800492c:	d03a      	beq.n	80049a4 <get_fat+0x90>
 800492e:	2b01      	cmp	r3, #1
 8004930:	d157      	bne.n	80049e2 <get_fat+0xce>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:836
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8004932:	eb01 0551 	add.w	r5, r1, r1, lsr #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:837
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8004936:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8004938:	eb01 2155 	add.w	r1, r1, r5, lsr #9
 800493c:	f7ff fbac 	bl	8004098 <move_window>
 8004940:	2800      	cmp	r0, #0
 8004942:	d150      	bne.n	80049e6 <get_fat+0xd2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:838
			wc = fs->win[bc++ % SS(fs)];
 8004944:	1c6f      	adds	r7, r5, #1
 8004946:	f3c5 0508 	ubfx	r5, r5, #0, #9
 800494a:	4435      	add	r5, r6
 800494c:	f895 5034 	ldrb.w	r5, [r5, #52]	; 0x34
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:839
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8004950:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8004952:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 8004956:	4630      	mov	r0, r6
 8004958:	f7ff fb9e 	bl	8004098 <move_window>
 800495c:	2800      	cmp	r0, #0
 800495e:	d145      	bne.n	80049ec <get_fat+0xd8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:840
			wc |= fs->win[bc % SS(fs)] << 8;
 8004960:	f3c7 0008 	ubfx	r0, r7, #0, #9
 8004964:	4430      	add	r0, r6
 8004966:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 800496a:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:841
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
 800496e:	f014 0f01 	tst.w	r4, #1
 8004972:	d001      	beq.n	8004978 <get_fat+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:841 (discriminator 1)
 8004974:	0900      	lsrs	r0, r0, #4
 8004976:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:841 (discriminator 2)
 8004978:	f3c0 000b 	ubfx	r0, r0, #0, #12
 800497c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:845
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800497e:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8004980:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 8004984:	f7ff fb88 	bl	8004098 <move_window>
 8004988:	bb98      	cbnz	r0, 80049f2 <get_fat+0xde>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:846
			p = &fs->win[clst * 2 % SS(fs)];
 800498a:	0061      	lsls	r1, r4, #1
 800498c:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
 8004990:	f101 0330 	add.w	r3, r1, #48	; 0x30
 8004994:	4433      	add	r3, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:847
			val = LD_WORD(p);
 8004996:	7958      	ldrb	r0, [r3, #5]
 8004998:	440e      	add	r6, r1
 800499a:	f896 3034 	ldrb.w	r3, [r6, #52]	; 0x34
 800499e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:848
			break;
 80049a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:851

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80049a4:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80049a6:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 80049aa:	f7ff fb75 	bl	8004098 <move_window>
 80049ae:	bb18      	cbnz	r0, 80049f8 <get_fat+0xe4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:852
			p = &fs->win[clst * 4 % SS(fs)];
 80049b0:	00a1      	lsls	r1, r4, #2
 80049b2:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 80049b6:	f101 0230 	add.w	r2, r1, #48	; 0x30
 80049ba:	4432      	add	r2, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:853
			val = LD_DWORD(p) & 0x0FFFFFFF;
 80049bc:	79d0      	ldrb	r0, [r2, #7]
 80049be:	7993      	ldrb	r3, [r2, #6]
 80049c0:	041b      	lsls	r3, r3, #16
 80049c2:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 80049c6:	7950      	ldrb	r0, [r2, #5]
 80049c8:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80049cc:	1870      	adds	r0, r6, r1
 80049ce:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 80049d2:	4318      	orrs	r0, r3
 80049d4:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:854
			break;
 80049d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:829
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		val = 1;	/* Internal error */
 80049da:	2001      	movs	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:862
			val = 1;	/* Internal error */
		}
	}

	return val;
}
 80049dc:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:829
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		val = 1;	/* Internal error */
 80049de:	2001      	movs	r0, #1
 80049e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:857
			p = &fs->win[clst * 4 % SS(fs)];
			val = LD_DWORD(p) & 0x0FFFFFFF;
			break;

		default:
			val = 1;	/* Internal error */
 80049e2:	2001      	movs	r0, #1
 80049e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:832

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80049e6:	f04f 30ff 	mov.w	r0, #4294967295
 80049ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80049ec:	f04f 30ff 	mov.w	r0, #4294967295
 80049f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80049f2:	f04f 30ff 	mov.w	r0, #4294967295
 80049f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80049f8:	f04f 30ff 	mov.w	r0, #4294967295
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:862
			val = 1;	/* Internal error */
		}
	}

	return val;
}
 80049fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80049fe:	bf00      	nop

08004a00 <dir_sdi>:
dir_sdi():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1084
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
 8004a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a02:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1089
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
 8004a04:	80c1      	strh	r1, [r0, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1090
	clst = dp->sclust;		/* Table start cluster (0:root) */
 8004a06:	6884      	ldr	r4, [r0, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1091
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8004a08:	2c01      	cmp	r4, #1
 8004a0a:	d035      	beq.n	8004a78 <dir_sdi+0x78>
 8004a0c:	460e      	mov	r6, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1091 (discriminator 1)
 8004a0e:	6803      	ldr	r3, [r0, #0]
 8004a10:	699a      	ldr	r2, [r3, #24]
 8004a12:	4294      	cmp	r4, r2
 8004a14:	d232      	bcs.n	8004a7c <dir_sdi+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1093
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 8004a16:	b91c      	cbnz	r4, 8004a20 <dir_sdi+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1093 (discriminator 1)
 8004a18:	781a      	ldrb	r2, [r3, #0]
 8004a1a:	2a03      	cmp	r2, #3
 8004a1c:	d100      	bne.n	8004a20 <dir_sdi+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1094
		clst = dp->fs->dirbase;
 8004a1e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1096

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8004a20:	b924      	cbnz	r4, 8004a2c <dir_sdi+0x2c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1097
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
 8004a22:	891a      	ldrh	r2, [r3, #8]
 8004a24:	4296      	cmp	r6, r2
 8004a26:	d22b      	bcs.n	8004a80 <dir_sdi+0x80>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1099
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
 8004a28:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8004a2a:	e017      	b.n	8004a5c <dir_sdi+0x5c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1102
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
 8004a2c:	789f      	ldrb	r7, [r3, #2]
 8004a2e:	013f      	lsls	r7, r7, #4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1103
		while (idx >= ic) {	/* Follow cluster chain */
 8004a30:	e00e      	b.n	8004a50 <dir_sdi+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1104
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 8004a32:	4621      	mov	r1, r4
 8004a34:	6828      	ldr	r0, [r5, #0]
 8004a36:	f7ff ff6d 	bl	8004914 <get_fat>
 8004a3a:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1105
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8004a3c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004a40:	d020      	beq.n	8004a84 <dir_sdi+0x84>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1106
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
 8004a42:	2801      	cmp	r0, #1
 8004a44:	d920      	bls.n	8004a88 <dir_sdi+0x88>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1106 (discriminator 1)
 8004a46:	682b      	ldr	r3, [r5, #0]
 8004a48:	699b      	ldr	r3, [r3, #24]
 8004a4a:	4298      	cmp	r0, r3
 8004a4c:	d21e      	bcs.n	8004a8c <dir_sdi+0x8c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1108
				return FR_INT_ERR;
			idx -= ic;
 8004a4e:	1bf6      	subs	r6, r6, r7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1103
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 8004a50:	42be      	cmp	r6, r7
 8004a52:	d2ee      	bcs.n	8004a32 <dir_sdi+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1110
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
 8004a54:	4621      	mov	r1, r4
 8004a56:	6828      	ldr	r0, [r5, #0]
 8004a58:	f7ff ff50 	bl	80048fc <clust2sect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1112
	}
	dp->clust = clst;	/* Current cluster# */
 8004a5c:	60ec      	str	r4, [r5, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1113
	if (!sect) return FR_INT_ERR;
 8004a5e:	b1b8      	cbz	r0, 8004a90 <dir_sdi+0x90>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1114
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
 8004a60:	eb00 1016 	add.w	r0, r0, r6, lsr #4
 8004a64:	6128      	str	r0, [r5, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1115
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 8004a66:	682b      	ldr	r3, [r5, #0]
 8004a68:	3334      	adds	r3, #52	; 0x34
 8004a6a:	f006 060f 	and.w	r6, r6, #15
 8004a6e:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 8004a72:	616e      	str	r6, [r5, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1117

	return FR_OK;
 8004a74:	2000      	movs	r0, #0
 8004a76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1092


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
 8004a78:	2002      	movs	r0, #2
 8004a7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004a7c:	2002      	movs	r0, #2
 8004a7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1098
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dp->fs->dirbase;

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
			return FR_INT_ERR;
 8004a80:	2002      	movs	r0, #2
 8004a82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1105
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8004a84:	2001      	movs	r0, #1
 8004a86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1107
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
 8004a88:	2002      	movs	r0, #2
 8004a8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004a8c:	2002      	movs	r0, #2
 8004a8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1113
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
 8004a90:	2002      	movs	r0, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1118
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */

	return FR_OK;
}
 8004a92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004a94 <put_fat>:
put_fat():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:884
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8004a94:	2901      	cmp	r1, #1
 8004a96:	f240 8088 	bls.w	8004baa <put_fat+0x116>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:884 (discriminator 1)
 8004a9a:	6983      	ldr	r3, [r0, #24]
 8004a9c:	4299      	cmp	r1, r3
 8004a9e:	f080 8087 	bcs.w	8004bb0 <put_fat+0x11c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:878
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
 8004aa2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004aa6:	4616      	mov	r6, r2
 8004aa8:	460c      	mov	r4, r1
 8004aaa:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:888

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 8004aac:	7803      	ldrb	r3, [r0, #0]
 8004aae:	2b02      	cmp	r3, #2
 8004ab0:	d042      	beq.n	8004b38 <put_fat+0xa4>
 8004ab2:	2b03      	cmp	r3, #3
 8004ab4:	d056      	beq.n	8004b64 <put_fat+0xd0>
 8004ab6:	2b01      	cmp	r3, #1
 8004ab8:	d17c      	bne.n	8004bb4 <put_fat+0x120>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:890
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8004aba:	eb01 0751 	add.w	r7, r1, r1, lsr #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:891
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8004abe:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8004ac0:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 8004ac4:	f7ff fae8 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:892
			if (res != FR_OK) break;
 8004ac8:	4603      	mov	r3, r0
 8004aca:	2800      	cmp	r0, #0
 8004acc:	d173      	bne.n	8004bb6 <put_fat+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:893
			p = &fs->win[bc++ % SS(fs)];
 8004ace:	f107 0801 	add.w	r8, r7, #1
 8004ad2:	f3c7 0708 	ubfx	r7, r7, #0, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:894
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8004ad6:	f014 0401 	ands.w	r4, r4, #1
 8004ada:	d009      	beq.n	8004af0 <put_fat+0x5c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:894 (discriminator 1)
 8004adc:	19eb      	adds	r3, r5, r7
 8004ade:	f893 2034 	ldrb.w	r2, [r3, #52]	; 0x34
 8004ae2:	b2f3      	uxtb	r3, r6
 8004ae4:	f002 020f 	and.w	r2, r2, #15
 8004ae8:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 8004aec:	b2db      	uxtb	r3, r3
 8004aee:	e000      	b.n	8004af2 <put_fat+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:894 (discriminator 2)
 8004af0:	b2f3      	uxtb	r3, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:894 (discriminator 4)
 8004af2:	442f      	add	r7, r5
 8004af4:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:895 (discriminator 4)
			fs->wflag = 1;
 8004af8:	2301      	movs	r3, #1
 8004afa:	712b      	strb	r3, [r5, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:896 (discriminator 4)
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8004afc:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8004afe:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 8004b02:	4628      	mov	r0, r5
 8004b04:	f7ff fac8 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:897 (discriminator 4)
			if (res != FR_OK) break;
 8004b08:	4603      	mov	r3, r0
 8004b0a:	2800      	cmp	r0, #0
 8004b0c:	d153      	bne.n	8004bb6 <put_fat+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:898
			p = &fs->win[bc % SS(fs)];
 8004b0e:	f3c8 0808 	ubfx	r8, r8, #0, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:899
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8004b12:	b114      	cbz	r4, 8004b1a <put_fat+0x86>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:899 (discriminator 1)
 8004b14:	f3c6 1207 	ubfx	r2, r6, #4, #8
 8004b18:	e008      	b.n	8004b2c <put_fat+0x98>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:899 (discriminator 2)
 8004b1a:	eb05 0208 	add.w	r2, r5, r8
 8004b1e:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
 8004b22:	f022 010f 	bic.w	r1, r2, #15
 8004b26:	f3c6 2203 	ubfx	r2, r6, #8, #4
 8004b2a:	430a      	orrs	r2, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:899 (discriminator 4)
 8004b2c:	44a8      	add	r8, r5
 8004b2e:	f888 2034 	strb.w	r2, [r8, #52]	; 0x34
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:900 (discriminator 4)
			fs->wflag = 1;
 8004b32:	2201      	movs	r2, #1
 8004b34:	712a      	strb	r2, [r5, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:901 (discriminator 4)
			break;
 8004b36:	e03e      	b.n	8004bb6 <put_fat+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:904

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8004b38:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8004b3a:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 8004b3e:	f7ff faab 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:905
			if (res != FR_OK) break;
 8004b42:	4603      	mov	r3, r0
 8004b44:	bbb8      	cbnz	r0, 8004bb6 <put_fat+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:906
			p = &fs->win[clst * 2 % SS(fs)];
 8004b46:	0061      	lsls	r1, r4, #1
 8004b48:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
 8004b4c:	f101 0030 	add.w	r0, r1, #48	; 0x30
 8004b50:	4428      	add	r0, r5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:907
			ST_WORD(p, (WORD)val);
 8004b52:	4429      	add	r1, r5
 8004b54:	f881 6034 	strb.w	r6, [r1, #52]	; 0x34
 8004b58:	f3c6 2207 	ubfx	r2, r6, #8, #8
 8004b5c:	7142      	strb	r2, [r0, #5]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:908
			fs->wflag = 1;
 8004b5e:	2201      	movs	r2, #1
 8004b60:	712a      	strb	r2, [r5, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:909
			break;
 8004b62:	e028      	b.n	8004bb6 <put_fat+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:912

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8004b64:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8004b66:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8004b6a:	f7ff fa95 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:913
			if (res != FR_OK) break;
 8004b6e:	4603      	mov	r3, r0
 8004b70:	bb08      	cbnz	r0, 8004bb6 <put_fat+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:914
			p = &fs->win[clst * 4 % SS(fs)];
 8004b72:	00a1      	lsls	r1, r4, #2
 8004b74:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 8004b78:	f101 0030 	add.w	r0, r1, #48	; 0x30
 8004b7c:	4428      	add	r0, r5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:915
			val |= LD_DWORD(p) & 0xF0000000;
 8004b7e:	79c4      	ldrb	r4, [r0, #7]
 8004b80:	7982      	ldrb	r2, [r0, #6]
 8004b82:	0412      	lsls	r2, r2, #16
 8004b84:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
 8004b88:	4429      	add	r1, r5
 8004b8a:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8004b8e:	4332      	orrs	r2, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:916
			ST_DWORD(p, val);
 8004b90:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
 8004b94:	f3c2 2107 	ubfx	r1, r2, #8, #8
 8004b98:	7141      	strb	r1, [r0, #5]
 8004b9a:	f3c2 4107 	ubfx	r1, r2, #16, #8
 8004b9e:	7181      	strb	r1, [r0, #6]
 8004ba0:	0e12      	lsrs	r2, r2, #24
 8004ba2:	71c2      	strb	r2, [r0, #7]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:917
			fs->wflag = 1;
 8004ba4:	2201      	movs	r2, #1
 8004ba6:	712a      	strb	r2, [r5, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:918
			break;
 8004ba8:	e005      	b.n	8004bb6 <put_fat+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:885
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;
 8004baa:	2302      	movs	r3, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:926
			res = FR_INT_ERR;
		}
	}

	return res;
}
 8004bac:	4618      	mov	r0, r3
 8004bae:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:885
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;
 8004bb0:	2302      	movs	r3, #2
 8004bb2:	e7fb      	b.n	8004bac <put_fat+0x118>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:921
			ST_DWORD(p, val);
			fs->wflag = 1;
			break;

		default :
			res = FR_INT_ERR;
 8004bb4:	2302      	movs	r3, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:926
		}
	}

	return res;
}
 8004bb6:	4618      	mov	r0, r3
 8004bb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08004bbc <create_chain>:
create_chain():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:994
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
 8004bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004bbe:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:999
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
 8004bc0:	460f      	mov	r7, r1
 8004bc2:	b929      	cbnz	r1, 8004bd0 <create_chain+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1000
		scl = fs->last_clust;			/* Get suggested start point */
 8004bc4:	68c6      	ldr	r6, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1001
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8004bc6:	b17e      	cbz	r6, 8004be8 <create_chain+0x2c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1001 (discriminator 2)
 8004bc8:	6983      	ldr	r3, [r0, #24]
 8004bca:	429e      	cmp	r6, r3
 8004bcc:	d20e      	bcs.n	8004bec <create_chain+0x30>
 8004bce:	e00e      	b.n	8004bee <create_chain+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1004
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
 8004bd0:	f7ff fea0 	bl	8004914 <get_fat>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1005
		if (cs < 2) return 1;			/* Invalid value */
 8004bd4:	2801      	cmp	r0, #1
 8004bd6:	d941      	bls.n	8004c5c <create_chain+0xa0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1006
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8004bd8:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004bdc:	d049      	beq.n	8004c72 <create_chain+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1007
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8004bde:	69ab      	ldr	r3, [r5, #24]
 8004be0:	4298      	cmp	r0, r3
 8004be2:	d346      	bcc.n	8004c72 <create_chain+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1008
		scl = clst;
 8004be4:	463e      	mov	r6, r7
 8004be6:	e002      	b.n	8004bee <create_chain+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1001
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8004be8:	2601      	movs	r6, #1
 8004bea:	e000      	b.n	8004bee <create_chain+0x32>
 8004bec:	2601      	movs	r6, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1011
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
 8004bee:	4634      	mov	r4, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1013
	for (;;) {
		ncl++;							/* Next cluster */
 8004bf0:	3401      	adds	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1014
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 8004bf2:	69ab      	ldr	r3, [r5, #24]
 8004bf4:	429c      	cmp	r4, r3
 8004bf6:	d302      	bcc.n	8004bfe <create_chain+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1016
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 8004bf8:	2e01      	cmp	r6, #1
 8004bfa:	d931      	bls.n	8004c60 <create_chain+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1015

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
 8004bfc:	2402      	movs	r4, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1018
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 8004bfe:	4621      	mov	r1, r4
 8004c00:	4628      	mov	r0, r5
 8004c02:	f7ff fe87 	bl	8004914 <get_fat>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1019
		if (cs == 0) break;				/* Found a free cluster */
 8004c06:	b138      	cbz	r0, 8004c18 <create_chain+0x5c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1020
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 8004c08:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004c0c:	d02a      	beq.n	8004c64 <create_chain+0xa8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1020 (discriminator 1)
 8004c0e:	2801      	cmp	r0, #1
 8004c10:	d029      	beq.n	8004c66 <create_chain+0xaa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1022
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 8004c12:	42b4      	cmp	r4, r6
 8004c14:	d1ec      	bne.n	8004bf0 <create_chain+0x34>
 8004c16:	e027      	b.n	8004c68 <create_chain+0xac>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1025
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 8004c18:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8004c1c:	4621      	mov	r1, r4
 8004c1e:	4628      	mov	r0, r5
 8004c20:	f7ff ff38 	bl	8004a94 <put_fat>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1026
	if (res == FR_OK && clst != 0) {
 8004c24:	4603      	mov	r3, r0
 8004c26:	b930      	cbnz	r0, 8004c36 <create_chain+0x7a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1026 (discriminator 1)
 8004c28:	b12f      	cbz	r7, 8004c36 <create_chain+0x7a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1027
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 8004c2a:	4622      	mov	r2, r4
 8004c2c:	4639      	mov	r1, r7
 8004c2e:	4628      	mov	r0, r5
 8004c30:	f7ff ff30 	bl	8004a94 <put_fat>
 8004c34:	4603      	mov	r3, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1029
	}
	if (res == FR_OK) {
 8004c36:	b963      	cbnz	r3, 8004c52 <create_chain+0x96>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1030
		fs->last_clust = ncl;			/* Update FSINFO */
 8004c38:	60ec      	str	r4, [r5, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1031
		if (fs->free_clust != 0xFFFFFFFF) {
 8004c3a:	692b      	ldr	r3, [r5, #16]
 8004c3c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004c40:	d014      	beq.n	8004c6c <create_chain+0xb0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1032
			fs->free_clust--;
 8004c42:	3b01      	subs	r3, #1
 8004c44:	612b      	str	r3, [r5, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1033
			fs->fsi_flag |= 1;
 8004c46:	796b      	ldrb	r3, [r5, #5]
 8004c48:	f043 0301 	orr.w	r3, r3, #1
 8004c4c:	716b      	strb	r3, [r5, #5]
 8004c4e:	4620      	mov	r0, r4
 8004c50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1036
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 8004c52:	2b01      	cmp	r3, #1
 8004c54:	d10c      	bne.n	8004c70 <create_chain+0xb4>
 8004c56:	f04f 30ff 	mov.w	r0, #4294967295
 8004c5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1005
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* Invalid value */
 8004c5c:	2001      	movs	r0, #1
 8004c5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1016
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 8004c60:	2000      	movs	r0, #0
 8004c62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004c64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1022
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 8004c68:	2000      	movs	r0, #0
 8004c6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004c6c:	4620      	mov	r0, r4
 8004c6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1036
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 8004c70:	2001      	movs	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1040
	}

	return ncl;		/* Return new cluster number or error code */
}
 8004c72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004c74 <dir_next>:
dir_next():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1132
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8004c74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1140
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
 8004c78:	88c4      	ldrh	r4, [r0, #6]
 8004c7a:	3401      	adds	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1141
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8004c7c:	b2a3      	uxth	r3, r4
 8004c7e:	2b00      	cmp	r3, #0
 8004c80:	d066      	beq.n	8004d50 <dir_next+0xdc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1141 (discriminator 1)
 8004c82:	6903      	ldr	r3, [r0, #16]
 8004c84:	2b00      	cmp	r3, #0
 8004c86:	d066      	beq.n	8004d56 <dir_next+0xe2>
 8004c88:	460e      	mov	r6, r1
 8004c8a:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1144
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
 8004c8c:	f014 070f 	ands.w	r7, r4, #15
 8004c90:	d155      	bne.n	8004d3e <dir_next+0xca>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1145
		dp->sect++;					/* Next sector */
 8004c92:	3301      	adds	r3, #1
 8004c94:	6103      	str	r3, [r0, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1147

		if (!dp->clust) {		/* Static table */
 8004c96:	68c1      	ldr	r1, [r0, #12]
 8004c98:	b921      	cbnz	r1, 8004ca4 <dir_next+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1148
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 8004c9a:	6803      	ldr	r3, [r0, #0]
 8004c9c:	891b      	ldrh	r3, [r3, #8]
 8004c9e:	429c      	cmp	r4, r3
 8004ca0:	d25c      	bcs.n	8004d5c <dir_next+0xe8>
 8004ca2:	e04c      	b.n	8004d3e <dir_next+0xca>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1152
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8004ca4:	6800      	ldr	r0, [r0, #0]
 8004ca6:	7883      	ldrb	r3, [r0, #2]
 8004ca8:	3b01      	subs	r3, #1
 8004caa:	ea13 1314 	ands.w	r3, r3, r4, lsr #4
 8004cae:	d146      	bne.n	8004d3e <dir_next+0xca>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1153
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 8004cb0:	f7ff fe30 	bl	8004914 <get_fat>
 8004cb4:	4680      	mov	r8, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1154
				if (clst <= 1) return FR_INT_ERR;
 8004cb6:	2801      	cmp	r0, #1
 8004cb8:	d953      	bls.n	8004d62 <dir_next+0xee>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1155
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8004cba:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004cbe:	d053      	beq.n	8004d68 <dir_next+0xf4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1156
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
 8004cc0:	6828      	ldr	r0, [r5, #0]
 8004cc2:	6983      	ldr	r3, [r0, #24]
 8004cc4:	4598      	cmp	r8, r3
 8004cc6:	d333      	bcc.n	8004d30 <dir_next+0xbc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1158
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 8004cc8:	2e00      	cmp	r6, #0
 8004cca:	d050      	beq.n	8004d6e <dir_next+0xfa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1159
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
 8004ccc:	68e9      	ldr	r1, [r5, #12]
 8004cce:	f7ff ff75 	bl	8004bbc <create_chain>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1160
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8004cd2:	4680      	mov	r8, r0
 8004cd4:	2800      	cmp	r0, #0
 8004cd6:	d04d      	beq.n	8004d74 <dir_next+0x100>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1161
					if (clst == 1) return FR_INT_ERR;
 8004cd8:	2801      	cmp	r0, #1
 8004cda:	d04e      	beq.n	8004d7a <dir_next+0x106>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1162
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8004cdc:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004ce0:	d04e      	beq.n	8004d80 <dir_next+0x10c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1164
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 8004ce2:	6828      	ldr	r0, [r5, #0]
 8004ce4:	f7ff f9ae 	bl	8004044 <sync_window>
 8004ce8:	2800      	cmp	r0, #0
 8004cea:	d14c      	bne.n	8004d86 <dir_next+0x112>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1165
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
 8004cec:	6828      	ldr	r0, [r5, #0]
 8004cee:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004cf2:	2100      	movs	r1, #0
 8004cf4:	3034      	adds	r0, #52	; 0x34
 8004cf6:	f7fe ff8d 	bl	8003c14 <mem_set>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1166
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 8004cfa:	682e      	ldr	r6, [r5, #0]
 8004cfc:	4641      	mov	r1, r8
 8004cfe:	4630      	mov	r0, r6
 8004d00:	f7ff fdfc 	bl	80048fc <clust2sect>
 8004d04:	6330      	str	r0, [r6, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1167
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8004d06:	2600      	movs	r6, #0
 8004d08:	e00b      	b.n	8004d22 <dir_next+0xae>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1168
						dp->fs->wflag = 1;
 8004d0a:	2201      	movs	r2, #1
 8004d0c:	711a      	strb	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1169
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 8004d0e:	6828      	ldr	r0, [r5, #0]
 8004d10:	f7ff f998 	bl	8004044 <sync_window>
 8004d14:	2800      	cmp	r0, #0
 8004d16:	d139      	bne.n	8004d8c <dir_next+0x118>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1170 (discriminator 2)
						dp->fs->winsect++;
 8004d18:	682a      	ldr	r2, [r5, #0]
 8004d1a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004d1c:	3301      	adds	r3, #1
 8004d1e:	6313      	str	r3, [r2, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1167 (discriminator 2)
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8004d20:	3601      	adds	r6, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1167 (discriminator 1)
 8004d22:	682b      	ldr	r3, [r5, #0]
 8004d24:	789a      	ldrb	r2, [r3, #2]
 8004d26:	4296      	cmp	r6, r2
 8004d28:	d3ef      	bcc.n	8004d0a <dir_next+0x96>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1172
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
 8004d2a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004d2c:	1b92      	subs	r2, r2, r6
 8004d2e:	631a      	str	r2, [r3, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1178
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
 8004d30:	f8c5 800c 	str.w	r8, [r5, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1179
				dp->sect = clust2sect(dp->fs, clst);
 8004d34:	4641      	mov	r1, r8
 8004d36:	6828      	ldr	r0, [r5, #0]
 8004d38:	f7ff fde0 	bl	80048fc <clust2sect>
 8004d3c:	6128      	str	r0, [r5, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1184
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
 8004d3e:	80ec      	strh	r4, [r5, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1185
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
 8004d40:	682b      	ldr	r3, [r5, #0]
 8004d42:	3334      	adds	r3, #52	; 0x34
 8004d44:	eb03 1347 	add.w	r3, r3, r7, lsl #5
 8004d48:	616b      	str	r3, [r5, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1187

	return FR_OK;
 8004d4a:	2000      	movs	r0, #0
 8004d4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1142
#endif


	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
 8004d50:	2004      	movs	r0, #4
 8004d52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004d56:	2004      	movs	r0, #4
 8004d58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1149
	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
				return FR_NO_FILE;
 8004d5c:	2004      	movs	r0, #4
 8004d5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1154
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
 8004d62:	2002      	movs	r0, #2
 8004d64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1155
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8004d68:	2001      	movs	r0, #1
 8004d6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1158
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 8004d6e:	2004      	movs	r0, #4
 8004d70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1160
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8004d74:	2007      	movs	r0, #7
 8004d76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1161
					if (clst == 1) return FR_INT_ERR;
 8004d7a:	2002      	movs	r0, #2
 8004d7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1162
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8004d80:	2001      	movs	r0, #1
 8004d82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1164
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 8004d86:	2001      	movs	r0, #1
 8004d88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1169
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 8004d8c:	2001      	movs	r0, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1188

	dp->index = (WORD)i;	/* Current index */
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */

	return FR_OK;
}
 8004d8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004d92:	bf00      	nop

08004d94 <dir_find>:
dir_find():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1461

static
FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp			/* Pointer to the directory object linked to the file name */
)
{
 8004d94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004d98:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1468
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004d9a:	2100      	movs	r1, #0
 8004d9c:	f7ff fe30 	bl	8004a00 <dir_sdi>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1469
	if (res != FR_OK) return res;
 8004da0:	2800      	cmp	r0, #0
 8004da2:	d15b      	bne.n	8004e5c <dir_find+0xc8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1472

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8004da4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004da8:	84a3      	strh	r3, [r4, #36]	; 0x24
 8004daa:	f04f 08ff 	mov.w	r8, #255	; 0xff
 8004dae:	4647      	mov	r7, r8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1475
#endif
	do {
		res = move_window(dp->fs, dp->sect);
 8004db0:	6921      	ldr	r1, [r4, #16]
 8004db2:	6820      	ldr	r0, [r4, #0]
 8004db4:	f7ff f970 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1476
		if (res != FR_OK) break;
 8004db8:	4606      	mov	r6, r0
 8004dba:	2800      	cmp	r0, #0
 8004dbc:	d150      	bne.n	8004e60 <dir_find+0xcc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1477
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8004dbe:	6965      	ldr	r5, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1478
		c = dir[DIR_Name];
 8004dc0:	782b      	ldrb	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1479
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004dc2:	2b00      	cmp	r3, #0
 8004dc4:	d04e      	beq.n	8004e64 <dir_find+0xd0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1481
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 8004dc6:	7aea      	ldrb	r2, [r5, #11]
 8004dc8:	f002 013f 	and.w	r1, r2, #63	; 0x3f
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1482
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8004dcc:	2be5      	cmp	r3, #229	; 0xe5
 8004dce:	d004      	beq.n	8004dda <dir_find+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1482 (discriminator 1)
 8004dd0:	f012 0f08 	tst.w	r2, #8
 8004dd4:	d006      	beq.n	8004de4 <dir_find+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1482 (discriminator 2)
 8004dd6:	290f      	cmp	r1, #15
 8004dd8:	d004      	beq.n	8004de4 <dir_find+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1483
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8004dda:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004dde:	84a3      	strh	r3, [r4, #36]	; 0x24
 8004de0:	27ff      	movs	r7, #255	; 0xff
 8004de2:	e033      	b.n	8004e4c <dir_find+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1485
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 8004de4:	290f      	cmp	r1, #15
 8004de6:	d117      	bne.n	8004e18 <dir_find+0x84>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1486
				if (dp->lfn) {
 8004de8:	6a20      	ldr	r0, [r4, #32]
 8004dea:	b378      	cbz	r0, 8004e4c <dir_find+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1487
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 8004dec:	f013 0f40 	tst.w	r3, #64	; 0x40
 8004df0:	d006      	beq.n	8004e00 <dir_find+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1488
						sum = dir[LDIR_Chksum];
 8004df2:	f895 800d 	ldrb.w	r8, [r5, #13]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1489
						c &= ~LLEF; ord = c;	/* LFN start order */
 8004df6:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1490
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 8004dfa:	88e2      	ldrh	r2, [r4, #6]
 8004dfc:	84a2      	strh	r2, [r4, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1489
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dp->lfn) {
					if (c & LLEF) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
 8004dfe:	461f      	mov	r7, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1493
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8004e00:	42bb      	cmp	r3, r7
 8004e02:	d11e      	bne.n	8004e42 <dir_find+0xae>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1493 (discriminator 1)
 8004e04:	7b6b      	ldrb	r3, [r5, #13]
 8004e06:	4598      	cmp	r8, r3
 8004e08:	d11d      	bne.n	8004e46 <dir_find+0xb2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1493 (discriminator 3)
 8004e0a:	4629      	mov	r1, r5
 8004e0c:	f7ff fcc2 	bl	8004794 <cmp_lfn>
 8004e10:	b1d8      	cbz	r0, 8004e4a <dir_find+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1493 (discriminator 5)
 8004e12:	3f01      	subs	r7, #1
 8004e14:	b2ff      	uxtb	r7, r7
 8004e16:	e019      	b.n	8004e4c <dir_find+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1496
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 8004e18:	b927      	cbnz	r7, 8004e24 <dir_find+0x90>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1496 (discriminator 1)
 8004e1a:	4628      	mov	r0, r5
 8004e1c:	f7ff f8aa 	bl	8003f74 <sum_sfn>
 8004e20:	4580      	cmp	r8, r0
 8004e22:	d022      	beq.n	8004e6a <dir_find+0xd6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1497
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
 8004e24:	69a1      	ldr	r1, [r4, #24]
 8004e26:	7acb      	ldrb	r3, [r1, #11]
 8004e28:	f013 0f01 	tst.w	r3, #1
 8004e2c:	d104      	bne.n	8004e38 <dir_find+0xa4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1497 (discriminator 1)
 8004e2e:	220b      	movs	r2, #11
 8004e30:	4628      	mov	r0, r5
 8004e32:	f7fe fef7 	bl	8003c24 <mem_cmp>
 8004e36:	b1d8      	cbz	r0, 8004e70 <dir_find+0xdc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1498
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8004e38:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004e3c:	84a3      	strh	r3, [r4, #36]	; 0x24
 8004e3e:	27ff      	movs	r7, #255	; 0xff
 8004e40:	e004      	b.n	8004e4c <dir_find+0xb8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1493
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8004e42:	27ff      	movs	r7, #255	; 0xff
 8004e44:	e002      	b.n	8004e4c <dir_find+0xb8>
 8004e46:	27ff      	movs	r7, #255	; 0xff
 8004e48:	e000      	b.n	8004e4c <dir_find+0xb8>
 8004e4a:	27ff      	movs	r7, #255	; 0xff
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1505
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
 8004e4c:	2100      	movs	r1, #0
 8004e4e:	4620      	mov	r0, r4
 8004e50:	f7ff ff10 	bl	8004c74 <dir_next>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1506
	} while (res == FR_OK);
 8004e54:	2800      	cmp	r0, #0
 8004e56:	d0ab      	beq.n	8004db0 <dir_find+0x1c>
 8004e58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004e5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004e60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1479
	do {
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004e64:	2004      	movs	r0, #4
 8004e66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1475

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
 8004e6a:	4630      	mov	r0, r6
 8004e6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004e70:	4630      	mov	r0, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1509
#endif
		res = dir_next(dp, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
 8004e72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004e76:	bf00      	nop

08004e78 <follow_path>:
follow_path():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2056
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8004e78:	b530      	push	{r4, r5, lr}
 8004e7a:	b083      	sub	sp, #12
 8004e7c:	4604      	mov	r4, r0
 8004e7e:	9101      	str	r1, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2062
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
 8004e80:	780b      	ldrb	r3, [r1, #0]
 8004e82:	b25a      	sxtb	r2, r3
 8004e84:	2a2f      	cmp	r2, #47	; 0x2f
 8004e86:	d001      	beq.n	8004e8c <follow_path+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2062 (discriminator 1)
 8004e88:	2a5c      	cmp	r2, #92	; 0x5c
 8004e8a:	d104      	bne.n	8004e96 <follow_path+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2063
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
 8004e8c:	3101      	adds	r1, #1
 8004e8e:	9101      	str	r1, [sp, #4]
 8004e90:	2300      	movs	r3, #0
 8004e92:	60a3      	str	r3, [r4, #8]
 8004e94:	e002      	b.n	8004e9c <follow_path+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2065
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
 8004e96:	6803      	ldr	r3, [r0, #0]
 8004e98:	695b      	ldr	r3, [r3, #20]
 8004e9a:	6083      	str	r3, [r0, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2073
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
		path++;
	dp->sclust = 0;							/* Always start from the root directory */
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8004e9c:	9b01      	ldr	r3, [sp, #4]
 8004e9e:	781b      	ldrb	r3, [r3, #0]
 8004ea0:	2b1f      	cmp	r3, #31
 8004ea2:	d807      	bhi.n	8004eb4 <follow_path+0x3c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2074
		res = dir_sdi(dp, 0);
 8004ea4:	2100      	movs	r1, #0
 8004ea6:	4620      	mov	r0, r4
 8004ea8:	f7ff fdaa 	bl	8004a00 <dir_sdi>
 8004eac:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2075
		dp->dir = 0;
 8004eae:	2300      	movs	r3, #0
 8004eb0:	6163      	str	r3, [r4, #20]
 8004eb2:	e030      	b.n	8004f16 <follow_path+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2078
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8004eb4:	a901      	add	r1, sp, #4
 8004eb6:	4620      	mov	r0, r4
 8004eb8:	f7ff fb2c 	bl	8004514 <create_name>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2079
			if (res != FR_OK) break;
 8004ebc:	4605      	mov	r5, r0
 8004ebe:	bb50      	cbnz	r0, 8004f16 <follow_path+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2080
			res = dir_find(dp);				/* Find an object with the sagment name */
 8004ec0:	4620      	mov	r0, r4
 8004ec2:	f7ff ff67 	bl	8004d94 <dir_find>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2081
			ns = dp->fn[NSFLAG];
 8004ec6:	69a3      	ldr	r3, [r4, #24]
 8004ec8:	7adb      	ldrb	r3, [r3, #11]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2082
			if (res != FR_OK) {				/* Failed to find the object */
 8004eca:	b180      	cbz	r0, 8004eee <follow_path+0x76>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2083
				if (res == FR_NO_FILE) {	/* Object is not found */
 8004ecc:	2804      	cmp	r0, #4
 8004ece:	d11b      	bne.n	8004f08 <follow_path+0x90>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2084
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
 8004ed0:	f013 0f20 	tst.w	r3, #32
 8004ed4:	d006      	beq.n	8004ee4 <follow_path+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2085
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
 8004ed6:	2200      	movs	r2, #0
 8004ed8:	60a2      	str	r2, [r4, #8]
 8004eda:	6162      	str	r2, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2086
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
 8004edc:	f013 0f04 	tst.w	r3, #4
 8004ee0:	d0e8      	beq.n	8004eb4 <follow_path+0x3c>
 8004ee2:	e018      	b.n	8004f16 <follow_path+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2089
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004ee4:	f013 0f04 	tst.w	r3, #4
 8004ee8:	d010      	beq.n	8004f0c <follow_path+0x94>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2080
		dp->dir = 0;
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
 8004eea:	4605      	mov	r5, r0
 8004eec:	e013      	b.n	8004f16 <follow_path+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2094
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8004eee:	f013 0f04 	tst.w	r3, #4
 8004ef2:	d10d      	bne.n	8004f10 <follow_path+0x98>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2095
			dir = dp->dir;						/* Follow the sub-directory */
 8004ef4:	6961      	ldr	r1, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2096
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8004ef6:	7acb      	ldrb	r3, [r1, #11]
 8004ef8:	f013 0f10 	tst.w	r3, #16
 8004efc:	d00a      	beq.n	8004f14 <follow_path+0x9c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2099
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
 8004efe:	6820      	ldr	r0, [r4, #0]
 8004f00:	f7fe ff9e 	bl	8003e40 <ld_clust>
 8004f04:	60a0      	str	r0, [r4, #8]
 8004f06:	e7d5      	b.n	8004eb4 <follow_path+0x3c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2080
		dp->dir = 0;
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
 8004f08:	4605      	mov	r5, r0
 8004f0a:	e004      	b.n	8004f16 <follow_path+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2089
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004f0c:	2505      	movs	r5, #5
 8004f0e:	e002      	b.n	8004f16 <follow_path+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2080
		dp->dir = 0;
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
 8004f10:	4605      	mov	r5, r0
 8004f12:	e000      	b.n	8004f16 <follow_path+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2097
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
 8004f14:	2505      	movs	r5, #5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2104
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
}
 8004f16:	4628      	mov	r0, r5
 8004f18:	b003      	add	sp, #12
 8004f1a:	bd30      	pop	{r4, r5, pc}

08004f1c <dir_alloc>:
dir_alloc():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1203
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
 8004f1c:	b570      	push	{r4, r5, r6, lr}
 8004f1e:	4604      	mov	r4, r0
 8004f20:	460e      	mov	r6, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1208
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
 8004f22:	2100      	movs	r1, #0
 8004f24:	f7ff fd6c 	bl	8004a00 <dir_sdi>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1209
	if (res == FR_OK) {
 8004f28:	4602      	mov	r2, r0
 8004f2a:	b9b8      	cbnz	r0, 8004f5c <dir_alloc+0x40>
 8004f2c:	2500      	movs	r5, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1212
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
 8004f2e:	6921      	ldr	r1, [r4, #16]
 8004f30:	6820      	ldr	r0, [r4, #0]
 8004f32:	f7ff f8b1 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1213
			if (res != FR_OK) break;
 8004f36:	4602      	mov	r2, r0
 8004f38:	b980      	cbnz	r0, 8004f5c <dir_alloc+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1214
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
 8004f3a:	6963      	ldr	r3, [r4, #20]
 8004f3c:	781b      	ldrb	r3, [r3, #0]
 8004f3e:	2be5      	cmp	r3, #229	; 0xe5
 8004f40:	d000      	beq.n	8004f44 <dir_alloc+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1214 (discriminator 1)
 8004f42:	b91b      	cbnz	r3, 8004f4c <dir_alloc+0x30>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1215
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 8004f44:	3501      	adds	r5, #1
 8004f46:	42b5      	cmp	r5, r6
 8004f48:	d101      	bne.n	8004f4e <dir_alloc+0x32>
 8004f4a:	e007      	b.n	8004f5c <dir_alloc+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1217
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 8004f4c:	2500      	movs	r5, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1219
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 8004f4e:	2101      	movs	r1, #1
 8004f50:	4620      	mov	r0, r4
 8004f52:	f7ff fe8f 	bl	8004c74 <dir_next>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1220
		} while (res == FR_OK);
 8004f56:	4602      	mov	r2, r0
 8004f58:	2800      	cmp	r0, #0
 8004f5a:	d0e8      	beq.n	8004f2e <dir_alloc+0x12>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1222
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8004f5c:	2a04      	cmp	r2, #4
 8004f5e:	d100      	bne.n	8004f62 <dir_alloc+0x46>
 8004f60:	2207      	movs	r2, #7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1224
	return res;
}
 8004f62:	4610      	mov	r0, r2
 8004f64:	bd70      	pop	{r4, r5, r6, pc}
 8004f66:	bf00      	nop

08004f68 <dir_register>:
dir_register():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1581
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8004f68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004f6c:	b084      	sub	sp, #16
 8004f6e:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1589
	UINT n, nent;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
 8004f70:	6987      	ldr	r7, [r0, #24]
 8004f72:	f8d0 8020 	ldr.w	r8, [r0, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1590
	mem_cpy(sn, fn, 12);
 8004f76:	220c      	movs	r2, #12
 8004f78:	4639      	mov	r1, r7
 8004f7a:	a801      	add	r0, sp, #4
 8004f7c:	f7fe fe40 	bl	8003c00 <mem_cpy>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1592

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
 8004f80:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004f84:	f013 0f20 	tst.w	r3, #32
 8004f88:	d177      	bne.n	800507a <dir_register+0x112>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1595
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8004f8a:	f013 0f01 	tst.w	r3, #1
 8004f8e:	d01b      	beq.n	8004fc8 <dir_register+0x60>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1596
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
 8004f90:	2300      	movs	r3, #0
 8004f92:	72fb      	strb	r3, [r7, #11]
 8004f94:	622b      	str	r3, [r5, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1597
		for (n = 1; n < 100; n++) {
 8004f96:	2401      	movs	r4, #1
 8004f98:	e00b      	b.n	8004fb2 <dir_register+0x4a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1598
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
 8004f9a:	4623      	mov	r3, r4
 8004f9c:	4642      	mov	r2, r8
 8004f9e:	a901      	add	r1, sp, #4
 8004fa0:	4638      	mov	r0, r7
 8004fa2:	f7fe ff97 	bl	8003ed4 <gen_numname>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1599
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 8004fa6:	4628      	mov	r0, r5
 8004fa8:	f7ff fef4 	bl	8004d94 <dir_find>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1600
			if (res != FR_OK) break;
 8004fac:	4606      	mov	r6, r0
 8004fae:	b910      	cbnz	r0, 8004fb6 <dir_register+0x4e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1597 (discriminator 2)
	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
 8004fb0:	3401      	adds	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1597 (discriminator 1)
 8004fb2:	2c63      	cmp	r4, #99	; 0x63
 8004fb4:	d9f1      	bls.n	8004f9a <dir_register+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1602
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8004fb6:	2c64      	cmp	r4, #100	; 0x64
 8004fb8:	d061      	beq.n	800507e <dir_register+0x116>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1603
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8004fba:	2e04      	cmp	r6, #4
 8004fbc:	d161      	bne.n	8005082 <dir_register+0x11a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1604
		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
 8004fbe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004fc2:	72fb      	strb	r3, [r7, #11]
 8004fc4:	f8c5 8020 	str.w	r8, [r5, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1607
	}

	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
 8004fc8:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004fcc:	f013 0f02 	tst.w	r3, #2
 8004fd0:	d103      	bne.n	8004fda <dir_register+0x72>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1611
		for (n = 0; lfn[n]; n++) ;
		nent = (n + 25) / 13;
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
 8004fd2:	2401      	movs	r4, #1
 8004fd4:	e00b      	b.n	8004fee <dir_register+0x86>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1608 (discriminator 3)
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
	}

	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
		for (n = 0; lfn[n]; n++) ;
 8004fd6:	3301      	adds	r3, #1
 8004fd8:	e000      	b.n	8004fdc <dir_register+0x74>
 8004fda:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1608 (discriminator 1)
 8004fdc:	f838 2013 	ldrh.w	r2, [r8, r3, lsl #1]
 8004fe0:	2a00      	cmp	r2, #0
 8004fe2:	d1f8      	bne.n	8004fd6 <dir_register+0x6e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1609
		nent = (n + 25) / 13;
 8004fe4:	3319      	adds	r3, #25
 8004fe6:	4c2a      	ldr	r4, [pc, #168]	; (8005090 <dir_register+0x128>)
 8004fe8:	fba4 3403 	umull	r3, r4, r4, r3
 8004fec:	08a4      	lsrs	r4, r4, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1613
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */
 8004fee:	4621      	mov	r1, r4
 8004ff0:	4628      	mov	r0, r5
 8004ff2:	f7ff ff93 	bl	8004f1c <dir_alloc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1615

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 8004ff6:	4606      	mov	r6, r0
 8004ff8:	bb18      	cbnz	r0, 8005042 <dir_register+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1615 (discriminator 1)
 8004ffa:	3c01      	subs	r4, #1
 8004ffc:	d021      	beq.n	8005042 <dir_register+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1616
		res = dir_sdi(dp, dp->index - nent);
 8004ffe:	88e9      	ldrh	r1, [r5, #6]
 8005000:	1b09      	subs	r1, r1, r4
 8005002:	4628      	mov	r0, r5
 8005004:	f7ff fcfc 	bl	8004a00 <dir_sdi>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1617
		if (res == FR_OK) {
 8005008:	4606      	mov	r6, r0
 800500a:	b9d0      	cbnz	r0, 8005042 <dir_register+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1618
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 800500c:	69a8      	ldr	r0, [r5, #24]
 800500e:	f7fe ffb1 	bl	8003f74 <sum_sfn>
 8005012:	4607      	mov	r7, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1620
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
 8005014:	6929      	ldr	r1, [r5, #16]
 8005016:	6828      	ldr	r0, [r5, #0]
 8005018:	f7ff f83e 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1621
				if (res != FR_OK) break;
 800501c:	4606      	mov	r6, r0
 800501e:	b980      	cbnz	r0, 8005042 <dir_register+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1622
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 8005020:	463b      	mov	r3, r7
 8005022:	b2e2      	uxtb	r2, r4
 8005024:	6969      	ldr	r1, [r5, #20]
 8005026:	6a28      	ldr	r0, [r5, #32]
 8005028:	f7fe ff24 	bl	8003e74 <fit_lfn>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1623
				dp->fs->wflag = 1;
 800502c:	682b      	ldr	r3, [r5, #0]
 800502e:	2201      	movs	r2, #1
 8005030:	711a      	strb	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1624
				res = dir_next(dp, 0);	/* Next entry */
 8005032:	2100      	movs	r1, #0
 8005034:	4628      	mov	r0, r5
 8005036:	f7ff fe1d 	bl	8004c74 <dir_next>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1625
			} while (res == FR_OK && --nent);
 800503a:	4606      	mov	r6, r0
 800503c:	b908      	cbnz	r0, 8005042 <dir_register+0xda>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1625 (discriminator 1)
 800503e:	3c01      	subs	r4, #1
 8005040:	d1e8      	bne.n	8005014 <dir_register+0xac>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1632
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
 8005042:	bb06      	cbnz	r6, 8005086 <dir_register+0x11e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1633
		res = move_window(dp->fs, dp->sect);
 8005044:	6929      	ldr	r1, [r5, #16]
 8005046:	6828      	ldr	r0, [r5, #0]
 8005048:	f7ff f826 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1634
		if (res == FR_OK) {
 800504c:	4606      	mov	r6, r0
 800504e:	b9e0      	cbnz	r0, 800508a <dir_register+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1635
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
 8005050:	2220      	movs	r2, #32
 8005052:	2100      	movs	r1, #0
 8005054:	6968      	ldr	r0, [r5, #20]
 8005056:	f7fe fddd 	bl	8003c14 <mem_set>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1636
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
 800505a:	220b      	movs	r2, #11
 800505c:	69a9      	ldr	r1, [r5, #24]
 800505e:	6968      	ldr	r0, [r5, #20]
 8005060:	f7fe fdce 	bl	8003c00 <mem_cpy>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1638
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8005064:	696a      	ldr	r2, [r5, #20]
 8005066:	69ab      	ldr	r3, [r5, #24]
 8005068:	7adb      	ldrb	r3, [r3, #11]
 800506a:	f003 0318 	and.w	r3, r3, #24
 800506e:	7313      	strb	r3, [r2, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1640
#endif
			dp->fs->wflag = 1;
 8005070:	682b      	ldr	r3, [r5, #0]
 8005072:	2201      	movs	r2, #1
 8005074:	711a      	strb	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1633
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
 8005076:	4630      	mov	r0, r6
 8005078:	e007      	b.n	800508a <dir_register+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1593

	fn = dp->fn; lfn = dp->lfn;
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;
 800507a:	2006      	movs	r0, #6
 800507c:	e005      	b.n	800508a <dir_register+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1602
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 800507e:	2007      	movs	r0, #7
 8005080:	e003      	b.n	800508a <dir_register+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1603
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8005082:	4630      	mov	r0, r6
 8005084:	e001      	b.n	800508a <dir_register+0x122>
 8005086:	4630      	mov	r0, r6
 8005088:	e7ff      	b.n	800508a <dir_register+0x122>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:1645
			dp->fs->wflag = 1;
		}
	}

	return res;
}
 800508a:	b004      	add	sp, #16
 800508c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005090:	4ec4ec4f 	.word	0x4ec4ec4f

08005094 <remove_chain>:
remove_chain():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:941
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8005094:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:948
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8005096:	2901      	cmp	r1, #1
 8005098:	d927      	bls.n	80050ea <remove_chain+0x56>
 800509a:	4604      	mov	r4, r0
 800509c:	460d      	mov	r5, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:948 (discriminator 1)
 800509e:	6983      	ldr	r3, [r0, #24]
 80050a0:	4299      	cmp	r1, r3
 80050a2:	d224      	bcs.n	80050ee <remove_chain+0x5a>
 80050a4:	2700      	movs	r7, #0
 80050a6:	e01c      	b.n	80050e2 <remove_chain+0x4e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:954
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
 80050a8:	4629      	mov	r1, r5
 80050aa:	4620      	mov	r0, r4
 80050ac:	f7ff fc32 	bl	8004914 <get_fat>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:955
			if (nxt == 0) break;				/* Empty cluster? */
 80050b0:	4606      	mov	r6, r0
 80050b2:	b308      	cbz	r0, 80050f8 <remove_chain+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:956
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 80050b4:	2801      	cmp	r0, #1
 80050b6:	d01c      	beq.n	80050f2 <remove_chain+0x5e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:957
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 80050b8:	f1b0 3fff 	cmp.w	r0, #4294967295
 80050bc:	d01b      	beq.n	80050f6 <remove_chain+0x62>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:958
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 80050be:	2200      	movs	r2, #0
 80050c0:	4629      	mov	r1, r5
 80050c2:	4620      	mov	r0, r4
 80050c4:	f7ff fce6 	bl	8004a94 <put_fat>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:959
			if (res != FR_OK) break;
 80050c8:	4607      	mov	r7, r0
 80050ca:	b9a8      	cbnz	r0, 80050f8 <remove_chain+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:960
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 80050cc:	6923      	ldr	r3, [r4, #16]
 80050ce:	f1b3 3fff 	cmp.w	r3, #4294967295
 80050d2:	d005      	beq.n	80050e0 <remove_chain+0x4c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:961
				fs->free_clust++;
 80050d4:	3301      	adds	r3, #1
 80050d6:	6123      	str	r3, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:962
				fs->fsi_flag |= 1;
 80050d8:	7963      	ldrb	r3, [r4, #5]
 80050da:	f043 0301 	orr.w	r3, r3, #1
 80050de:	7163      	strb	r3, [r4, #5]
 80050e0:	4635      	mov	r5, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:953
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
 80050e2:	69a3      	ldr	r3, [r4, #24]
 80050e4:	429d      	cmp	r5, r3
 80050e6:	d3df      	bcc.n	80050a8 <remove_chain+0x14>
 80050e8:	e006      	b.n	80050f8 <remove_chain+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:949
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;
 80050ea:	2702      	movs	r7, #2
 80050ec:	e004      	b.n	80050f8 <remove_chain+0x64>
 80050ee:	2702      	movs	r7, #2
 80050f0:	e002      	b.n	80050f8 <remove_chain+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:956
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 80050f2:	2702      	movs	r7, #2
 80050f4:	e000      	b.n	80050f8 <remove_chain+0x64>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:957
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 80050f6:	2701      	movs	r7, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:979
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
 80050f8:	4638      	mov	r0, r7
 80050fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080050fc <f_mount>:
f_mount():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2407
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80050fc:	b570      	push	{r4, r5, r6, lr}
 80050fe:	b084      	sub	sp, #16
 8005100:	9001      	str	r0, [sp, #4]
 8005102:	9100      	str	r1, [sp, #0]
 8005104:	4616      	mov	r6, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2411
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 8005106:	a804      	add	r0, sp, #16
 8005108:	f840 1d04 	str.w	r1, [r0, #-4]!
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2414


	vol = get_ldnumber(&rp);
 800510c:	f7fe ff40 	bl	8003f90 <get_ldnumber>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2415
	if (vol < 0) return FR_INVALID_DRIVE;
 8005110:	1e04      	subs	r4, r0, #0
 8005112:	db19      	blt.n	8005148 <f_mount+0x4c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2416
	cfs = FatFs[vol];					/* Pointer to fs object */
 8005114:	4b10      	ldr	r3, [pc, #64]	; (8005158 <f_mount+0x5c>)
 8005116:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2418

	if (cfs) {
 800511a:	b125      	cbz	r5, 8005126 <f_mount+0x2a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2420
#if _FS_LOCK
		clear_lock(cfs);
 800511c:	4628      	mov	r0, r5
 800511e:	f7fe fe77 	bl	8003e10 <clear_lock>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2425
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 8005122:	2300      	movs	r3, #0
 8005124:	702b      	strb	r3, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2428
	}

	if (fs) {
 8005126:	9b01      	ldr	r3, [sp, #4]
 8005128:	b10b      	cbz	r3, 800512e <f_mount+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2429
		fs->fs_type = 0;				/* Clear new fs object */
 800512a:	2200      	movs	r2, #0
 800512c:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2434
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 800512e:	9b01      	ldr	r3, [sp, #4]
 8005130:	4a09      	ldr	r2, [pc, #36]	; (8005158 <f_mount+0x5c>)
 8005132:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2436

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8005136:	b14b      	cbz	r3, 800514c <f_mount+0x50>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2436 (discriminator 2)
 8005138:	2e01      	cmp	r6, #1
 800513a:	d109      	bne.n	8005150 <f_mount+0x54>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2438

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 800513c:	2200      	movs	r2, #0
 800513e:	4669      	mov	r1, sp
 8005140:	a801      	add	r0, sp, #4
 8005142:	f7ff f827 	bl	8004194 <find_volume>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2439
	LEAVE_FF(fs, res);
 8005146:	e004      	b.n	8005152 <f_mount+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2415
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 8005148:	200b      	movs	r0, #11
 800514a:	e002      	b.n	8005152 <f_mount+0x56>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2436
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800514c:	2000      	movs	r0, #0
 800514e:	e000      	b.n	8005152 <f_mount+0x56>
 8005150:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2440

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 8005152:	b004      	add	sp, #16
 8005154:	bd70      	pop	{r4, r5, r6, pc}
 8005156:	bf00      	nop
 8005158:	20001ab4 	.word	0x20001ab4

0800515c <f_open>:
f_open():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2454
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800515c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005160:	b090      	sub	sp, #64	; 0x40
 8005162:	9101      	str	r1, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2464
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
 8005164:	2800      	cmp	r0, #0
 8005166:	f000 80e0 	beq.w	800532a <f_open+0x1ce>
 800516a:	4605      	mov	r5, r0
 800516c:	4616      	mov	r6, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2465
	fp->fs = 0;			/* Clear file object */
 800516e:	2300      	movs	r3, #0
 8005170:	6003      	str	r3, [r0, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2469

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 8005172:	f002 071f 	and.w	r7, r2, #31
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2470
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 8005176:	f002 021e 	and.w	r2, r2, #30
 800517a:	a901      	add	r1, sp, #4
 800517c:	a805      	add	r0, sp, #20
 800517e:	f7ff f809 	bl	8004194 <find_volume>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2475
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
 8005182:	2800      	cmp	r0, #0
 8005184:	f040 80d3 	bne.w	800532e <f_open+0x1d2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2476
		INIT_BUF(dj);
 8005188:	f44f 7000 	mov.w	r0, #512	; 0x200
 800518c:	f000 fac2 	bl	8005714 <ff_memalloc>
 8005190:	4681      	mov	r9, r0
 8005192:	2800      	cmp	r0, #0
 8005194:	f000 80cc 	beq.w	8005330 <f_open+0x1d4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2476 (discriminator 2)
 8005198:	900d      	str	r0, [sp, #52]	; 0x34
 800519a:	ab02      	add	r3, sp, #8
 800519c:	930b      	str	r3, [sp, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2477 (discriminator 2)
		res = follow_path(&dj, path);	/* Follow the file path */
 800519e:	9901      	ldr	r1, [sp, #4]
 80051a0:	a805      	add	r0, sp, #20
 80051a2:	f7ff fe69 	bl	8004e78 <follow_path>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2478 (discriminator 2)
		dir = dj.dir;
 80051a6:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2480 (discriminator 2)
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 80051aa:	4604      	mov	r4, r0
 80051ac:	b968      	cbnz	r0, 80051ca <f_open+0x6e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2481
			if (!dir)	/* Default directory itself */
 80051ae:	f1b8 0f00 	cmp.w	r8, #0
 80051b2:	d009      	beq.n	80051c8 <f_open+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2485
				res = FR_INVALID_NAME;
#if _FS_LOCK
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80051b4:	f037 0301 	bics.w	r3, r7, #1
 80051b8:	bf14      	ite	ne
 80051ba:	2101      	movne	r1, #1
 80051bc:	2100      	moveq	r1, #0
 80051be:	a805      	add	r0, sp, #20
 80051c0:	f7fe fd4c 	bl	8003c5c <chk_lock>
 80051c4:	4604      	mov	r4, r0
 80051c6:	e000      	b.n	80051ca <f_open+0x6e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2482
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
			if (!dir)	/* Default directory itself */
				res = FR_INVALID_NAME;
 80051c8:	2406      	movs	r4, #6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2489
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80051ca:	f016 0f1c 	tst.w	r6, #28
 80051ce:	d062      	beq.n	8005296 <f_open+0x13a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2490
			if (res != FR_OK) {					/* No file, create new */
 80051d0:	b17c      	cbz	r4, 80051f2 <f_open+0x96>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2491
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 80051d2:	2c04      	cmp	r4, #4
 80051d4:	d108      	bne.n	80051e8 <f_open+0x8c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2493
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80051d6:	f7fe fd83 	bl	8003ce0 <enq_lock>
 80051da:	b120      	cbz	r0, 80051e6 <f_open+0x8a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2493 (discriminator 1)
 80051dc:	a805      	add	r0, sp, #20
 80051de:	f7ff fec3 	bl	8004f68 <dir_register>
 80051e2:	4604      	mov	r4, r0
 80051e4:	e000      	b.n	80051e8 <f_open+0x8c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2493
 80051e6:	2412      	movs	r4, #18
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2497
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80051e8:	f047 0708 	orr.w	r7, r7, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2498
				dir = dj.dir;					/* New entry */
 80051ec:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 80051f0:	e00b      	b.n	800520a <f_open+0xae>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2501
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 80051f2:	f898 300b 	ldrb.w	r3, [r8, #11]
 80051f6:	f013 0f11 	tst.w	r3, #17
 80051fa:	d103      	bne.n	8005204 <f_open+0xa8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2504
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 80051fc:	f016 0f04 	tst.w	r6, #4
 8005200:	d102      	bne.n	8005208 <f_open+0xac>
 8005202:	e002      	b.n	800520a <f_open+0xae>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2502
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
 8005204:	2407      	movs	r4, #7
 8005206:	e000      	b.n	800520a <f_open+0xae>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2505
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
 8005208:	2408      	movs	r4, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2508
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 800520a:	2c00      	cmp	r4, #0
 800520c:	d153      	bne.n	80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2508 (discriminator 1)
 800520e:	f017 0f08 	tst.w	r7, #8
 8005212:	d050      	beq.n	80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2509
				dw = GET_FATTIME();
 8005214:	f7fd feda 	bl	8002fcc <get_fattime>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2510
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
 8005218:	b2c1      	uxtb	r1, r0
 800521a:	f888 100e 	strb.w	r1, [r8, #14]
 800521e:	f3c0 2207 	ubfx	r2, r0, #8, #8
 8005222:	f888 200f 	strb.w	r2, [r8, #15]
 8005226:	f3c0 4307 	ubfx	r3, r0, #16, #8
 800522a:	f888 3010 	strb.w	r3, [r8, #16]
 800522e:	0e00      	lsrs	r0, r0, #24
 8005230:	f888 0011 	strb.w	r0, [r8, #17]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2511
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
 8005234:	f888 1016 	strb.w	r1, [r8, #22]
 8005238:	f888 2017 	strb.w	r2, [r8, #23]
 800523c:	f888 3018 	strb.w	r3, [r8, #24]
 8005240:	f888 0019 	strb.w	r0, [r8, #25]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2512
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8005244:	2600      	movs	r6, #0
 8005246:	f888 600b 	strb.w	r6, [r8, #11]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2513
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
 800524a:	f888 601c 	strb.w	r6, [r8, #28]
 800524e:	f888 601d 	strb.w	r6, [r8, #29]
 8005252:	f888 601e 	strb.w	r6, [r8, #30]
 8005256:	f888 601f 	strb.w	r6, [r8, #31]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2514
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
 800525a:	4641      	mov	r1, r8
 800525c:	9805      	ldr	r0, [sp, #20]
 800525e:	f7fe fdef 	bl	8003e40 <ld_clust>
 8005262:	4682      	mov	sl, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2515
				st_clust(dir, 0);				/* Reset cluster */
 8005264:	4631      	mov	r1, r6
 8005266:	4640      	mov	r0, r8
 8005268:	f7fe fdfa 	bl	8003e60 <st_clust>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2516
				dj.fs->wflag = 1;
 800526c:	9805      	ldr	r0, [sp, #20]
 800526e:	2301      	movs	r3, #1
 8005270:	7103      	strb	r3, [r0, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2517
				if (cl) {						/* Remove the cluster chain if exist */
 8005272:	f1ba 0f00 	cmp.w	sl, #0
 8005276:	d01e      	beq.n	80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2518
					dw = dj.fs->winsect;
 8005278:	6b06      	ldr	r6, [r0, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2519
					res = remove_chain(dj.fs, cl);
 800527a:	4651      	mov	r1, sl
 800527c:	f7ff ff0a 	bl	8005094 <remove_chain>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2520
					if (res == FR_OK) {
 8005280:	4604      	mov	r4, r0
 8005282:	b9c0      	cbnz	r0, 80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2521
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8005284:	9805      	ldr	r0, [sp, #20]
 8005286:	f10a 33ff 	add.w	r3, sl, #4294967295
 800528a:	60c3      	str	r3, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2522
						res = move_window(dj.fs, dw);
 800528c:	4631      	mov	r1, r6
 800528e:	f7fe ff03 	bl	8004098 <move_window>
 8005292:	4604      	mov	r4, r0
 8005294:	e00f      	b.n	80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2528
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
 8005296:	b974      	cbnz	r4, 80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2529
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
 8005298:	f898 300b 	ldrb.w	r3, [r8, #11]
 800529c:	f013 0f10 	tst.w	r3, #16
 80052a0:	d106      	bne.n	80052b0 <f_open+0x154>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2532
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 80052a2:	f016 0f02 	tst.w	r6, #2
 80052a6:	d006      	beq.n	80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2532 (discriminator 1)
 80052a8:	f013 0f01 	tst.w	r3, #1
 80052ac:	d102      	bne.n	80052b4 <f_open+0x158>
 80052ae:	e002      	b.n	80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2530
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
					res = FR_NO_FILE;
 80052b0:	2404      	movs	r4, #4
 80052b2:	e000      	b.n	80052b6 <f_open+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2533
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
 80052b4:	2407      	movs	r4, #7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2537
				}
			}
		}
		if (res == FR_OK) {
 80052b6:	b9ac      	cbnz	r4, 80052e4 <f_open+0x188>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2538
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 80052b8:	f017 0f08 	tst.w	r7, #8
 80052bc:	d001      	beq.n	80052c2 <f_open+0x166>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2539
				mode |= FA__WRITTEN;
 80052be:	f047 0720 	orr.w	r7, r7, #32
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2540
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 80052c2:	a810      	add	r0, sp, #64	; 0x40
 80052c4:	f850 3d2c 	ldr.w	r3, [r0, #-44]!
 80052c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80052ca:	61eb      	str	r3, [r5, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2541
			fp->dir_ptr = dir;
 80052cc:	f8c5 8020 	str.w	r8, [r5, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2543
#if _FS_LOCK
			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80052d0:	f037 0301 	bics.w	r3, r7, #1
 80052d4:	bf14      	ite	ne
 80052d6:	2101      	movne	r1, #1
 80052d8:	2100      	moveq	r1, #0
 80052da:	f7fe fd13 	bl	8003d04 <inc_lock>
 80052de:	6268      	str	r0, [r5, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2544
			if (!fp->lockid) res = FR_INT_ERR;
 80052e0:	b900      	cbnz	r0, 80052e4 <f_open+0x188>
 80052e2:	2402      	movs	r4, #2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2559
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
					res = FR_NO_FILE;
			}
		}
#endif
		FREE_BUF();
 80052e4:	4648      	mov	r0, r9
 80052e6:	f000 fa19 	bl	800571c <ff_memfree>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2561

		if (res == FR_OK) {
 80052ea:	bb1c      	cbnz	r4, 8005334 <f_open+0x1d8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2562
			fp->flag = mode;					/* File access mode */
 80052ec:	71af      	strb	r7, [r5, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2563
			fp->err = 0;						/* Clear error flag */
 80052ee:	2700      	movs	r7, #0
 80052f0:	71ef      	strb	r7, [r5, #7]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2564
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 80052f2:	9e05      	ldr	r6, [sp, #20]
 80052f4:	4641      	mov	r1, r8
 80052f6:	4630      	mov	r0, r6
 80052f8:	f7fe fda2 	bl	8003e40 <ld_clust>
 80052fc:	6128      	str	r0, [r5, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2565
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
 80052fe:	f898 201f 	ldrb.w	r2, [r8, #31]
 8005302:	f898 301e 	ldrb.w	r3, [r8, #30]
 8005306:	041b      	lsls	r3, r3, #16
 8005308:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800530c:	f898 201d 	ldrb.w	r2, [r8, #29]
 8005310:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005314:	f898 201c 	ldrb.w	r2, [r8, #28]
 8005318:	4313      	orrs	r3, r2
 800531a:	60eb      	str	r3, [r5, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2566
			fp->fptr = 0;						/* File pointer */
 800531c:	60af      	str	r7, [r5, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2567
			fp->dsect = 0;
 800531e:	61af      	str	r7, [r5, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2571
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
 8005320:	602e      	str	r6, [r5, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2572
			fp->id = fp->fs->id;
 8005322:	88f3      	ldrh	r3, [r6, #6]
 8005324:	80ab      	strh	r3, [r5, #4]
 8005326:	4620      	mov	r0, r4
 8005328:	e005      	b.n	8005336 <f_open+0x1da>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2464
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
 800532a:	2009      	movs	r0, #9
 800532c:	e003      	b.n	8005336 <f_open+0x1da>
 800532e:	e002      	b.n	8005336 <f_open+0x1da>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2476
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 8005330:	2011      	movs	r0, #17
 8005332:	e000      	b.n	8005336 <f_open+0x1da>
 8005334:	4620      	mov	r0, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2577
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
 8005336:	b010      	add	sp, #64	; 0x40
 8005338:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800533c <f_write>:
f_write():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2693
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 800533c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005340:	4604      	mov	r4, r0
 8005342:	4688      	mov	r8, r1
 8005344:	4616      	mov	r6, r2
 8005346:	461f      	mov	r7, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2701
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
 8005348:	2300      	movs	r3, #0
 800534a:	603b      	str	r3, [r7, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2703

	res = validate(fp);						/* Check validity */
 800534c:	f7fe ff06 	bl	800415c <validate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2704
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8005350:	2800      	cmp	r0, #0
 8005352:	f040 80c6 	bne.w	80054e2 <f_write+0x1a6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2705
	if (fp->err)							/* Check error */
 8005356:	79e0      	ldrb	r0, [r4, #7]
 8005358:	2800      	cmp	r0, #0
 800535a:	f040 80c5 	bne.w	80054e8 <f_write+0x1ac>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2707
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 800535e:	79a3      	ldrb	r3, [r4, #6]
 8005360:	f013 0f02 	tst.w	r3, #2
 8005364:	f000 80bf 	beq.w	80054e6 <f_write+0x1aa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2709
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
 8005368:	68a3      	ldr	r3, [r4, #8]
 800536a:	42f3      	cmn	r3, r6
 800536c:	f0c0 80aa 	bcc.w	80054c4 <f_write+0x188>
 8005370:	2600      	movs	r6, #0
 8005372:	e0a7      	b.n	80054c4 <f_write+0x188>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2713

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 8005374:	68a2      	ldr	r2, [r4, #8]
 8005376:	f3c2 0308 	ubfx	r3, r2, #0, #9
 800537a:	2b00      	cmp	r3, #0
 800537c:	f040 8088 	bne.w	8005490 <f_write+0x154>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2714
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 8005380:	6820      	ldr	r0, [r4, #0]
 8005382:	7883      	ldrb	r3, [r0, #2]
 8005384:	3b01      	subs	r3, #1
 8005386:	b2db      	uxtb	r3, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2715
			if (!csect) {					/* On the cluster boundary? */
 8005388:	ea13 2952 	ands.w	r9, r3, r2, lsr #9
 800538c:	d11f      	bne.n	80053ce <f_write+0x92>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2716
				if (fp->fptr == 0) {		/* On the top of the file? */
 800538e:	b932      	cbnz	r2, 800539e <f_write+0x62>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2717
					clst = fp->sclust;		/* Follow from the origin */
 8005390:	6923      	ldr	r3, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2718
					if (clst == 0)			/* When no cluster is allocated, */
 8005392:	b943      	cbnz	r3, 80053a6 <f_write+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2719
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 8005394:	2100      	movs	r1, #0
 8005396:	f7ff fc11 	bl	8004bbc <create_chain>
 800539a:	4603      	mov	r3, r0
 800539c:	e003      	b.n	80053a6 <f_write+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2726
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800539e:	6961      	ldr	r1, [r4, #20]
 80053a0:	f7ff fc0c 	bl	8004bbc <create_chain>
 80053a4:	4603      	mov	r3, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2728
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 80053a6:	2b00      	cmp	r3, #0
 80053a8:	f000 808f 	beq.w	80054ca <f_write+0x18e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2729
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 80053ac:	2b01      	cmp	r3, #1
 80053ae:	d103      	bne.n	80053b8 <f_write+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2729 (discriminator 1)
 80053b0:	2002      	movs	r0, #2
 80053b2:	71e0      	strb	r0, [r4, #7]
 80053b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2730
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 80053b8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80053bc:	d103      	bne.n	80053c6 <f_write+0x8a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2730 (discriminator 1)
 80053be:	2001      	movs	r0, #1
 80053c0:	71e0      	strb	r0, [r4, #7]
 80053c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2731
				fp->clust = clst;			/* Update current cluster */
 80053c6:	6163      	str	r3, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2732
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
 80053c8:	6922      	ldr	r2, [r4, #16]
 80053ca:	b902      	cbnz	r2, 80053ce <f_write+0x92>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2732 (discriminator 1)
 80053cc:	6123      	str	r3, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2738
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 80053ce:	79a3      	ldrb	r3, [r4, #6]
 80053d0:	f013 0f40 	tst.w	r3, #64	; 0x40
 80053d4:	d010      	beq.n	80053f8 <f_write+0xbc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2739
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 80053d6:	4621      	mov	r1, r4
 80053d8:	f851 0b28 	ldr.w	r0, [r1], #40
 80053dc:	2301      	movs	r3, #1
 80053de:	69a2      	ldr	r2, [r4, #24]
 80053e0:	7840      	ldrb	r0, [r0, #1]
 80053e2:	f7fd fdcb 	bl	8002f7c <disk_write>
 80053e6:	b118      	cbz	r0, 80053f0 <f_write+0xb4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2740
					ABORT(fp->fs, FR_DISK_ERR);
 80053e8:	2001      	movs	r0, #1
 80053ea:	71e0      	strb	r0, [r4, #7]
 80053ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2741
				fp->flag &= ~FA__DIRTY;
 80053f0:	79a3      	ldrb	r3, [r4, #6]
 80053f2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80053f6:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2744
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 80053f8:	f8d4 a000 	ldr.w	sl, [r4]
 80053fc:	6961      	ldr	r1, [r4, #20]
 80053fe:	4650      	mov	r0, sl
 8005400:	f7ff fa7c 	bl	80048fc <clust2sect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2745
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8005404:	4605      	mov	r5, r0
 8005406:	b918      	cbnz	r0, 8005410 <f_write+0xd4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2745 (discriminator 1)
 8005408:	2002      	movs	r0, #2
 800540a:	71e0      	strb	r0, [r4, #7]
 800540c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2746
			sect += csect;
 8005410:	444d      	add	r5, r9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2748
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 8005412:	ea5f 2b56 	movs.w	fp, r6, lsr #9
 8005416:	d026      	beq.n	8005466 <f_write+0x12a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2749
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 8005418:	eb09 030b 	add.w	r3, r9, fp
 800541c:	f89a 2002 	ldrb.w	r2, [sl, #2]
 8005420:	4293      	cmp	r3, r2
 8005422:	d901      	bls.n	8005428 <f_write+0xec>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2750
					cc = fp->fs->csize - csect;
 8005424:	ebc9 0b02 	rsb	fp, r9, r2
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2751
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
 8005428:	465b      	mov	r3, fp
 800542a:	462a      	mov	r2, r5
 800542c:	4641      	mov	r1, r8
 800542e:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8005432:	f7fd fda3 	bl	8002f7c <disk_write>
 8005436:	b118      	cbz	r0, 8005440 <f_write+0x104>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2752
					ABORT(fp->fs, FR_DISK_ERR);
 8005438:	2001      	movs	r0, #1
 800543a:	71e0      	strb	r0, [r4, #7]
 800543c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2760
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8005440:	69a1      	ldr	r1, [r4, #24]
 8005442:	1b49      	subs	r1, r1, r5
 8005444:	458b      	cmp	fp, r1
 8005446:	d90b      	bls.n	8005460 <f_write+0x124>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2761
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 8005448:	f44f 7200 	mov.w	r2, #512	; 0x200
 800544c:	eb08 2141 	add.w	r1, r8, r1, lsl #9
 8005450:	f104 0028 	add.w	r0, r4, #40	; 0x28
 8005454:	f7fe fbd4 	bl	8003c00 <mem_cpy>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2762
					fp->flag &= ~FA__DIRTY;
 8005458:	79a3      	ldrb	r3, [r4, #6]
 800545a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800545e:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2766
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 8005460:	ea4f 254b 	mov.w	r5, fp, lsl #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2767
				continue;
 8005464:	e026      	b.n	80054b4 <f_write+0x178>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2775
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 8005466:	69a3      	ldr	r3, [r4, #24]
 8005468:	429d      	cmp	r5, r3
 800546a:	d010      	beq.n	800548e <f_write+0x152>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2776
				if (fp->fptr < fp->fsize &&
 800546c:	68a2      	ldr	r2, [r4, #8]
 800546e:	68e3      	ldr	r3, [r4, #12]
 8005470:	429a      	cmp	r2, r3
 8005472:	d20c      	bcs.n	800548e <f_write+0x152>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2777 (discriminator 1)
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
 8005474:	2301      	movs	r3, #1
 8005476:	462a      	mov	r2, r5
 8005478:	f104 0128 	add.w	r1, r4, #40	; 0x28
 800547c:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8005480:	f7fd fd64 	bl	8002f4c <disk_read>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2776 (discriminator 1)
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
 8005484:	b118      	cbz	r0, 800548e <f_write+0x152>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2778
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
 8005486:	2001      	movs	r0, #1
 8005488:	71e0      	strb	r0, [r4, #7]
 800548a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2781
			}
#endif
			fp->dsect = sect;
 800548e:	61a5      	str	r5, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2783
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 8005490:	68a0      	ldr	r0, [r4, #8]
 8005492:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8005496:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2784
		if (wcnt > btw) wcnt = btw;
 800549a:	42ae      	cmp	r6, r5
 800549c:	d200      	bcs.n	80054a0 <f_write+0x164>
 800549e:	4635      	mov	r5, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2791
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 80054a0:	3028      	adds	r0, #40	; 0x28
 80054a2:	462a      	mov	r2, r5
 80054a4:	4641      	mov	r1, r8
 80054a6:	4420      	add	r0, r4
 80054a8:	f7fe fbaa 	bl	8003c00 <mem_cpy>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2792
		fp->flag |= FA__DIRTY;
 80054ac:	79a3      	ldrb	r3, [r4, #6]
 80054ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80054b2:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2712
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 80054b4:	44a8      	add	r8, r5
 80054b6:	68a3      	ldr	r3, [r4, #8]
 80054b8:	442b      	add	r3, r5
 80054ba:	60a3      	str	r3, [r4, #8]
 80054bc:	683b      	ldr	r3, [r7, #0]
 80054be:	442b      	add	r3, r5
 80054c0:	603b      	str	r3, [r7, #0]
 80054c2:	1b76      	subs	r6, r6, r5
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2711
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 80054c4:	2e00      	cmp	r6, #0
 80054c6:	f47f af55 	bne.w	8005374 <f_write+0x38>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2796
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 80054ca:	68a3      	ldr	r3, [r4, #8]
 80054cc:	68e2      	ldr	r2, [r4, #12]
 80054ce:	4293      	cmp	r3, r2
 80054d0:	d900      	bls.n	80054d4 <f_write+0x198>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2796 (discriminator 1)
 80054d2:	60e3      	str	r3, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2797
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 80054d4:	79a3      	ldrb	r3, [r4, #6]
 80054d6:	f043 0320 	orr.w	r3, r3, #32
 80054da:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2799

	LEAVE_FF(fp->fs, FR_OK);
 80054dc:	2000      	movs	r0, #0
 80054de:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80054e2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2708
	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->err)							/* Check error */
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 80054e6:	2007      	movs	r0, #7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2800

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
 80054e8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080054ec <f_sync>:
f_sync():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2812
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 80054ec:	b538      	push	{r3, r4, r5, lr}
 80054ee:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2818
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
 80054f0:	f7fe fe34 	bl	800415c <validate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2819
	if (res == FR_OK) {
 80054f4:	2800      	cmp	r0, #0
 80054f6:	d144      	bne.n	8005582 <f_sync+0x96>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2820
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
 80054f8:	79a2      	ldrb	r2, [r4, #6]
 80054fa:	f012 0f20 	tst.w	r2, #32
 80054fe:	d041      	beq.n	8005584 <f_sync+0x98>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2822
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
 8005500:	f012 0f40 	tst.w	r2, #64	; 0x40
 8005504:	d00d      	beq.n	8005522 <f_sync+0x36>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2823
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 8005506:	4621      	mov	r1, r4
 8005508:	f851 0b28 	ldr.w	r0, [r1], #40
 800550c:	2301      	movs	r3, #1
 800550e:	69a2      	ldr	r2, [r4, #24]
 8005510:	7840      	ldrb	r0, [r0, #1]
 8005512:	f7fd fd33 	bl	8002f7c <disk_write>
 8005516:	2800      	cmp	r0, #0
 8005518:	d135      	bne.n	8005586 <f_sync+0x9a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2825
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 800551a:	79a3      	ldrb	r3, [r4, #6]
 800551c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005520:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2829
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 8005522:	69e1      	ldr	r1, [r4, #28]
 8005524:	6820      	ldr	r0, [r4, #0]
 8005526:	f7fe fdb7 	bl	8004098 <move_window>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2830
			if (res == FR_OK) {
 800552a:	bb70      	cbnz	r0, 800558a <f_sync+0x9e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2831
				dir = fp->dir_ptr;
 800552c:	6a25      	ldr	r5, [r4, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2832
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 800552e:	7aeb      	ldrb	r3, [r5, #11]
 8005530:	f043 0320 	orr.w	r3, r3, #32
 8005534:	72eb      	strb	r3, [r5, #11]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2833
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
 8005536:	7b23      	ldrb	r3, [r4, #12]
 8005538:	772b      	strb	r3, [r5, #28]
 800553a:	89a3      	ldrh	r3, [r4, #12]
 800553c:	0a1b      	lsrs	r3, r3, #8
 800553e:	776b      	strb	r3, [r5, #29]
 8005540:	7ba3      	ldrb	r3, [r4, #14]
 8005542:	77ab      	strb	r3, [r5, #30]
 8005544:	7be3      	ldrb	r3, [r4, #15]
 8005546:	77eb      	strb	r3, [r5, #31]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2834
				st_clust(dir, fp->sclust);					/* Update start cluster */
 8005548:	6921      	ldr	r1, [r4, #16]
 800554a:	4628      	mov	r0, r5
 800554c:	f7fe fc88 	bl	8003e60 <st_clust>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2835
				tm = GET_FATTIME();							/* Update modified time */
 8005550:	f7fd fd3c 	bl	8002fcc <get_fattime>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2836
				ST_DWORD(dir + DIR_WrtTime, tm);
 8005554:	75a8      	strb	r0, [r5, #22]
 8005556:	f3c0 2307 	ubfx	r3, r0, #8, #8
 800555a:	75eb      	strb	r3, [r5, #23]
 800555c:	f3c0 4307 	ubfx	r3, r0, #16, #8
 8005560:	762b      	strb	r3, [r5, #24]
 8005562:	0e00      	lsrs	r0, r0, #24
 8005564:	7668      	strb	r0, [r5, #25]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2837
				ST_WORD(dir + DIR_LstAccDate, 0);
 8005566:	2300      	movs	r3, #0
 8005568:	74ab      	strb	r3, [r5, #18]
 800556a:	74eb      	strb	r3, [r5, #19]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2838
				fp->flag &= ~FA__WRITTEN;
 800556c:	79a3      	ldrb	r3, [r4, #6]
 800556e:	f023 0320 	bic.w	r3, r3, #32
 8005572:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2839
				fp->fs->wflag = 1;
 8005574:	6823      	ldr	r3, [r4, #0]
 8005576:	2201      	movs	r2, #1
 8005578:	711a      	strb	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2840
				res = sync_fs(fp->fs);
 800557a:	6820      	ldr	r0, [r4, #0]
 800557c:	f7ff f960 	bl	8004840 <sync_fs>
 8005580:	bd38      	pop	{r3, r4, r5, pc}
 8005582:	bd38      	pop	{r3, r4, r5, pc}
 8005584:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2824
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 8005586:	2001      	movs	r0, #1
 8005588:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2846
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 800558a:	bd38      	pop	{r3, r4, r5, pc}

0800558c <f_close>:
f_close():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2860
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 800558c:	b510      	push	{r4, lr}
 800558e:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2865
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8005590:	f7ff ffac 	bl	80054ec <f_sync>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2866
	if (res == FR_OK)
 8005594:	4603      	mov	r3, r0
 8005596:	b958      	cbnz	r0, 80055b0 <f_close+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2869
#endif
	{
		res = validate(fp);				/* Lock volume */
 8005598:	4620      	mov	r0, r4
 800559a:	f7fe fddf 	bl	800415c <validate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2870
		if (res == FR_OK) {
 800559e:	4603      	mov	r3, r0
 80055a0:	b930      	cbnz	r0, 80055b0 <f_close+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2875
#if _FS_REENTRANT
			FATFS *fs = fp->fs;
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
 80055a2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80055a4:	f7fe fc10 	bl	8003dc8 <dec_lock>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2876
			if (res == FR_OK)
 80055a8:	4603      	mov	r3, r0
 80055aa:	b908      	cbnz	r0, 80055b0 <f_close+0x24>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2878
#endif
				fp->fs = 0;				/* Invalidate file object */
 80055ac:	2200      	movs	r2, #0
 80055ae:	6022      	str	r2, [r4, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:2885
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 80055b0:	4618      	mov	r0, r3
 80055b2:	bd10      	pop	{r4, pc}

080055b4 <f_lseek>:
f_lseek():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3033

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
 80055b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80055b6:	4604      	mov	r4, r0
 80055b8:	460d      	mov	r5, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3041
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
 80055ba:	f7fe fdcf 	bl	800415c <validate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3042
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 80055be:	4606      	mov	r6, r0
 80055c0:	2800      	cmp	r0, #0
 80055c2:	f040 80a3 	bne.w	800570c <f_lseek+0x158>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3043
	if (fp->err)						/* Check error */
 80055c6:	79e0      	ldrb	r0, [r4, #7]
 80055c8:	2800      	cmp	r0, #0
 80055ca:	f040 80a1 	bne.w	8005710 <f_lseek+0x15c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3103
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 80055ce:	68e3      	ldr	r3, [r4, #12]
 80055d0:	42ab      	cmp	r3, r5
 80055d2:	d204      	bcs.n	80055de <f_lseek+0x2a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3105
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
 80055d4:	79a2      	ldrb	r2, [r4, #6]
 80055d6:	f012 0f02 	tst.w	r2, #2
 80055da:	d100      	bne.n	80055de <f_lseek+0x2a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3107
#endif
			) ofs = fp->fsize;
 80055dc:	461d      	mov	r5, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3109

		ifptr = fp->fptr;
 80055de:	68a3      	ldr	r3, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3110
		fp->fptr = nsect = 0;
 80055e0:	2200      	movs	r2, #0
 80055e2:	60a2      	str	r2, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3111
		if (ofs) {
 80055e4:	2d00      	cmp	r5, #0
 80055e6:	d05c      	beq.n	80056a2 <f_lseek+0xee>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3112
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 80055e8:	6820      	ldr	r0, [r4, #0]
 80055ea:	7887      	ldrb	r7, [r0, #2]
 80055ec:	027f      	lsls	r7, r7, #9
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3113
			if (ifptr > 0 &&
 80055ee:	b16b      	cbz	r3, 800560c <f_lseek+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3114 (discriminator 1)
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 80055f0:	1e6a      	subs	r2, r5, #1
 80055f2:	fbb2 f2f7 	udiv	r2, r2, r7
 80055f6:	3b01      	subs	r3, #1
 80055f8:	fbb3 f1f7 	udiv	r1, r3, r7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3113 (discriminator 1)

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
 80055fc:	428a      	cmp	r2, r1
 80055fe:	d305      	bcc.n	800560c <f_lseek+0x58>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3115
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 8005600:	427a      	negs	r2, r7
 8005602:	4013      	ands	r3, r2
 8005604:	60a3      	str	r3, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3116
				ofs -= fp->fptr;
 8005606:	1aed      	subs	r5, r5, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3117
				clst = fp->clust;
 8005608:	6961      	ldr	r1, [r4, #20]
 800560a:	e011      	b.n	8005630 <f_lseek+0x7c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3119
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
 800560c:	6921      	ldr	r1, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3121
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 800560e:	b971      	cbnz	r1, 800562e <f_lseek+0x7a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3122
					clst = create_chain(fp->fs, 0);
 8005610:	f7ff fad4 	bl	8004bbc <create_chain>
 8005614:	4601      	mov	r1, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3123
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 8005616:	2801      	cmp	r0, #1
 8005618:	d102      	bne.n	8005620 <f_lseek+0x6c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3123 (discriminator 1)
 800561a:	2002      	movs	r0, #2
 800561c:	71e0      	strb	r0, [r4, #7]
 800561e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3124
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8005620:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005624:	d102      	bne.n	800562c <f_lseek+0x78>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3124 (discriminator 1)
 8005626:	2001      	movs	r0, #1
 8005628:	71e0      	strb	r0, [r4, #7]
 800562a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3125
					fp->sclust = clst;
 800562c:	6120      	str	r0, [r4, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3128
				}
#endif
				fp->clust = clst;
 800562e:	6161      	str	r1, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3130
			}
			if (clst != 0) {
 8005630:	bb19      	cbnz	r1, 800567a <f_lseek+0xc6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3110
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
 8005632:	2500      	movs	r5, #0
 8005634:	e038      	b.n	80056a8 <f_lseek+0xf4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3133
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8005636:	79a3      	ldrb	r3, [r4, #6]
 8005638:	f013 0f02 	tst.w	r3, #2
 800563c:	d005      	beq.n	800564a <f_lseek+0x96>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3134
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 800563e:	6820      	ldr	r0, [r4, #0]
 8005640:	f7ff fabc 	bl	8004bbc <create_chain>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3135
						if (clst == 0) {				/* When disk gets full, clip file size */
 8005644:	4601      	mov	r1, r0
 8005646:	b920      	cbnz	r0, 8005652 <f_lseek+0x9e>
 8005648:	e01a      	b.n	8005680 <f_lseek+0xcc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3140
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
 800564a:	6820      	ldr	r0, [r4, #0]
 800564c:	f7ff f962 	bl	8004914 <get_fat>
 8005650:	4601      	mov	r1, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3141
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8005652:	f1b1 3fff 	cmp.w	r1, #4294967295
 8005656:	d102      	bne.n	800565e <f_lseek+0xaa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3141 (discriminator 1)
 8005658:	2001      	movs	r0, #1
 800565a:	71e0      	strb	r0, [r4, #7]
 800565c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3142
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 800565e:	2901      	cmp	r1, #1
 8005660:	d903      	bls.n	800566a <f_lseek+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3142 (discriminator 2)
 8005662:	6823      	ldr	r3, [r4, #0]
 8005664:	699b      	ldr	r3, [r3, #24]
 8005666:	4299      	cmp	r1, r3
 8005668:	d302      	bcc.n	8005670 <f_lseek+0xbc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3142 (discriminator 3)
 800566a:	2002      	movs	r0, #2
 800566c:	71e0      	strb	r0, [r4, #7]
 800566e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3143
					fp->clust = clst;
 8005670:	6161      	str	r1, [r4, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3144
					fp->fptr += bcs;
 8005672:	68a3      	ldr	r3, [r4, #8]
 8005674:	443b      	add	r3, r7
 8005676:	60a3      	str	r3, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3145
					ofs -= bcs;
 8005678:	1bed      	subs	r5, r5, r7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3131
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
 800567a:	42bd      	cmp	r5, r7
 800567c:	d8db      	bhi.n	8005636 <f_lseek+0x82>
 800567e:	e000      	b.n	8005682 <f_lseek+0xce>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3136
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
 8005680:	463d      	mov	r5, r7
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3147
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
 8005682:	68a3      	ldr	r3, [r4, #8]
 8005684:	442b      	add	r3, r5
 8005686:	60a3      	str	r3, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3148
				if (ofs % SS(fp->fs)) {
 8005688:	f3c5 0308 	ubfx	r3, r5, #0, #9
 800568c:	b15b      	cbz	r3, 80056a6 <f_lseek+0xf2>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3149
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
 800568e:	6820      	ldr	r0, [r4, #0]
 8005690:	f7ff f934 	bl	80048fc <clust2sect>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3150
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 8005694:	b910      	cbnz	r0, 800569c <f_lseek+0xe8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3150 (discriminator 1)
 8005696:	2002      	movs	r0, #2
 8005698:	71e0      	strb	r0, [r4, #7]
 800569a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3151
					nsect += ofs / SS(fp->fs);
 800569c:	eb00 2555 	add.w	r5, r0, r5, lsr #9
 80056a0:	e002      	b.n	80056a8 <f_lseek+0xf4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3110
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
 80056a2:	2500      	movs	r5, #0
 80056a4:	e000      	b.n	80056a8 <f_lseek+0xf4>
 80056a6:	2500      	movs	r5, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3155
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 80056a8:	68a3      	ldr	r3, [r4, #8]
 80056aa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80056ae:	b313      	cbz	r3, 80056f6 <f_lseek+0x142>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3155 (discriminator 1)
 80056b0:	69a2      	ldr	r2, [r4, #24]
 80056b2:	4295      	cmp	r5, r2
 80056b4:	d01f      	beq.n	80056f6 <f_lseek+0x142>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3158
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
 80056b6:	79a3      	ldrb	r3, [r4, #6]
 80056b8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80056bc:	d00e      	beq.n	80056dc <f_lseek+0x128>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3159
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 80056be:	4621      	mov	r1, r4
 80056c0:	f851 0b28 	ldr.w	r0, [r1], #40
 80056c4:	2301      	movs	r3, #1
 80056c6:	7840      	ldrb	r0, [r0, #1]
 80056c8:	f7fd fc58 	bl	8002f7c <disk_write>
 80056cc:	b110      	cbz	r0, 80056d4 <f_lseek+0x120>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3160
					ABORT(fp->fs, FR_DISK_ERR);
 80056ce:	2001      	movs	r0, #1
 80056d0:	71e0      	strb	r0, [r4, #7]
 80056d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3161
				fp->flag &= ~FA__DIRTY;
 80056d4:	79a3      	ldrb	r3, [r4, #6]
 80056d6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80056da:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3164
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
 80056dc:	4621      	mov	r1, r4
 80056de:	f851 0b28 	ldr.w	r0, [r1], #40
 80056e2:	2301      	movs	r3, #1
 80056e4:	462a      	mov	r2, r5
 80056e6:	7840      	ldrb	r0, [r0, #1]
 80056e8:	f7fd fc30 	bl	8002f4c <disk_read>
 80056ec:	b110      	cbz	r0, 80056f4 <f_lseek+0x140>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3165
				ABORT(fp->fs, FR_DISK_ERR);
 80056ee:	2001      	movs	r0, #1
 80056f0:	71e0      	strb	r0, [r4, #7]
 80056f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3167
#endif
			fp->dsect = nsect;
 80056f4:	61a5      	str	r5, [r4, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3170
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
 80056f6:	68a3      	ldr	r3, [r4, #8]
 80056f8:	68e2      	ldr	r2, [r4, #12]
 80056fa:	4293      	cmp	r3, r2
 80056fc:	d907      	bls.n	800570e <f_lseek+0x15a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3171
			fp->fsize = fp->fptr;
 80056fe:	60e3      	str	r3, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3172
			fp->flag |= FA__WRITTEN;
 8005700:	79a3      	ldrb	r3, [r4, #6]
 8005702:	f043 0320 	orr.w	r3, r3, #32
 8005706:	71a3      	strb	r3, [r4, #6]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3177
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
 8005708:	4630      	mov	r0, r6
 800570a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800570c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800570e:	4630      	mov	r0, r6
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/ff.c:3178
}
 8005710:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005712:	bf00      	nop

08005714 <ff_memalloc>:
ff_memalloc():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/syscall.c:136
*/

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
 8005714:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/syscall.c:137
	return malloc(msize);	/* Allocate a new memory block with POSIX API */
 8005716:	f000 fb2f 	bl	8005d78 <malloc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/syscall.c:138
}
 800571a:	bd08      	pop	{r3, pc}

0800571c <ff_memfree>:
ff_memfree():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/syscall.c:148
/*------------------------------------------------------------------------*/

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
 800571c:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/syscall.c:149
	free(mblock);	/* Discard the memory block with POSIX API */
 800571e:	f000 fb33 	bl	8005d88 <free>
 8005722:	bd08      	pop	{r3, pc}

08005724 <TM_DELAY_Init>:
TM_DELAY_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:39
uint32_t TM_DELAY_Init(void) {
#if !defined(STM32F0xx)
	uint32_t c;
	
    /* Enable TRC */
    CoreDebug->DEMCR &= ~0x01000000;
 8005724:	4b0c      	ldr	r3, [pc, #48]	; (8005758 <TM_DELAY_Init+0x34>)
 8005726:	68da      	ldr	r2, [r3, #12]
 8005728:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800572c:	60da      	str	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:40
    CoreDebug->DEMCR |=  0x01000000;
 800572e:	68da      	ldr	r2, [r3, #12]
 8005730:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8005734:	60da      	str	r2, [r3, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:43
	
    /* Enable counter */
    DWT->CTRL &= ~0x00000001;
 8005736:	4b09      	ldr	r3, [pc, #36]	; (800575c <TM_DELAY_Init+0x38>)
 8005738:	681a      	ldr	r2, [r3, #0]
 800573a:	f022 0201 	bic.w	r2, r2, #1
 800573e:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:44
    DWT->CTRL |=  0x00000001;
 8005740:	681a      	ldr	r2, [r3, #0]
 8005742:	f042 0201 	orr.w	r2, r2, #1
 8005746:	601a      	str	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:47
	
    /* Reset counter */
    DWT->CYCCNT = 0;
 8005748:	2200      	movs	r2, #0
 800574a:	605a      	str	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:50
	
	/* Check if DWT has started */
	c = DWT->CYCCNT;
 800574c:	685a      	ldr	r2, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:53
	
	/* 2 dummys */
	__ASM volatile ("NOP");
 800574e:	bf00      	nop
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:54
	__ASM volatile ("NOP");
 8005750:	bf00      	nop
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:57
	
	/* Return difference, if result is zero, DWT has not started */
	return (DWT->CYCCNT - c);
 8005752:	6858      	ldr	r0, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:62
#else
	/* Return OK */
	return 1;
#endif
}
 8005754:	1a80      	subs	r0, r0, r2
 8005756:	4770      	bx	lr
 8005758:	e000edf0 	.word	0xe000edf0
 800575c:	e0001000 	.word	0xe0001000

08005760 <TM_DELAY_1msHandler>:
TM_DELAY_1msHandler():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:180
	/* Return pointer */
	return Timer;
}

/* 1ms function called when systick makes interrupt */
__weak void TM_DELAY_1msHandler(void) {
 8005760:	4770      	bx	lr
 8005762:	bf00      	nop

08005764 <HAL_IncTick>:
HAL_IncTick():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:191
/***************************************************/
/*       Custom HAL function implementations       */
/***************************************************/

/* Called from Systick handler */
void HAL_IncTick(void) {
 8005764:	b538      	push	{r3, r4, r5, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:195
	uint8_t i;
	
	/* Increase system time */
	TM_Time++;
 8005766:	4a1d      	ldr	r2, [pc, #116]	; (80057dc <HAL_IncTick+0x78>)
 8005768:	6813      	ldr	r3, [r2, #0]
 800576a:	3301      	adds	r3, #1
 800576c:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:198
	
	/* Decrease other system time */
	if (TM_Time2) {
 800576e:	4b1c      	ldr	r3, [pc, #112]	; (80057e0 <HAL_IncTick+0x7c>)
 8005770:	681b      	ldr	r3, [r3, #0]
 8005772:	b11b      	cbz	r3, 800577c <HAL_IncTick+0x18>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:199
		TM_Time2--;
 8005774:	4a1a      	ldr	r2, [pc, #104]	; (80057e0 <HAL_IncTick+0x7c>)
 8005776:	6813      	ldr	r3, [r2, #0]
 8005778:	3b01      	subs	r3, #1
 800577a:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:191 (discriminator 1)
/***************************************************/
/*       Custom HAL function implementations       */
/***************************************************/

/* Called from Systick handler */
void HAL_IncTick(void) {
 800577c:	2400      	movs	r4, #0
 800577e:	e026      	b.n	80057ce <HAL_IncTick+0x6a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:207
	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
		/* Check if timer is enabled */
		if (
			CustomTimers.Timers[i] &&             /*!< Pointer exists */
 8005780:	4625      	mov	r5, r4
 8005782:	4b18      	ldr	r3, [pc, #96]	; (80057e4 <HAL_IncTick+0x80>)
 8005784:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8005788:	685b      	ldr	r3, [r3, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:206
	
	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
		/* Check if timer is enabled */
		if (
 800578a:	b1f3      	cbz	r3, 80057ca <HAL_IncTick+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:207
			CustomTimers.Timers[i] &&             /*!< Pointer exists */
 800578c:	781a      	ldrb	r2, [r3, #0]
 800578e:	f012 0f02 	tst.w	r2, #2
 8005792:	d01a      	beq.n	80057ca <HAL_IncTick+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:211
			CustomTimers.Timers[i]->Flags.F.CNTEN /*!< Timer is enabled */
		) {
			/* Decrease counter if needed */
			if (CustomTimers.Timers[i]->CNT) {
 8005794:	689a      	ldr	r2, [r3, #8]
 8005796:	b10a      	cbz	r2, 800579c <HAL_IncTick+0x38>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:212
				CustomTimers.Timers[i]->CNT--;
 8005798:	3a01      	subs	r2, #1
 800579a:	609a      	str	r2, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:216
			}
			
			/* Check if count is zero */
			if (CustomTimers.Timers[i]->CNT == 0) {
 800579c:	4b11      	ldr	r3, [pc, #68]	; (80057e4 <HAL_IncTick+0x80>)
 800579e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 80057a2:	6858      	ldr	r0, [r3, #4]
 80057a4:	6883      	ldr	r3, [r0, #8]
 80057a6:	b983      	cbnz	r3, 80057ca <HAL_IncTick+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:218
				/* Call user callback function */
				CustomTimers.Timers[i]->Callback(CustomTimers.Timers[i], CustomTimers.Timers[i]->UserParameters);
 80057a8:	68c3      	ldr	r3, [r0, #12]
 80057aa:	6901      	ldr	r1, [r0, #16]
 80057ac:	4798      	blx	r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:221
				
				/* Set new counter value */
				CustomTimers.Timers[i]->CNT = CustomTimers.Timers[i]->ARR;
 80057ae:	4b0d      	ldr	r3, [pc, #52]	; (80057e4 <HAL_IncTick+0x80>)
 80057b0:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80057b4:	686b      	ldr	r3, [r5, #4]
 80057b6:	685a      	ldr	r2, [r3, #4]
 80057b8:	609a      	str	r2, [r3, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:224
				
				/* Disable timer if auto reload feature is not used */
				if (!CustomTimers.Timers[i]->Flags.F.AREN) {
 80057ba:	781a      	ldrb	r2, [r3, #0]
 80057bc:	f012 0f01 	tst.w	r2, #1
 80057c0:	d103      	bne.n	80057ca <HAL_IncTick+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:226
					/* Disable counter */
					CustomTimers.Timers[i]->Flags.F.CNTEN = 0;
 80057c2:	781a      	ldrb	r2, [r3, #0]
 80057c4:	f36f 0241 	bfc	r2, #1, #1
 80057c8:	701a      	strb	r2, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:204 (discriminator 2)
		TM_Time2--;
	}
	
	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
 80057ca:	3401      	adds	r4, #1
 80057cc:	b2e4      	uxtb	r4, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:204 (discriminator 1)
 80057ce:	4b05      	ldr	r3, [pc, #20]	; (80057e4 <HAL_IncTick+0x80>)
 80057d0:	781b      	ldrb	r3, [r3, #0]
 80057d2:	429c      	cmp	r4, r3
 80057d4:	d3d4      	bcc.n	8005780 <HAL_IncTick+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:233
			}
		}
	}
	
	/* Call 1ms interrupt handler function */
	TM_DELAY_1msHandler();
 80057d6:	f7ff ffc3 	bl	8005760 <TM_DELAY_1msHandler>
 80057da:	bd38      	pop	{r3, r4, r5, pc}
 80057dc:	20001af0 	.word	0x20001af0
 80057e0:	20001af4 	.word	0x20001af4
 80057e4:	20001ad8 	.word	0x20001ad8

080057e8 <HAL_GetTick>:
HAL_GetTick():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:263
	}
}

uint32_t HAL_GetTick(void) {
	/* Return current time in milliseconds */
	return TM_Time;
 80057e8:	4b01      	ldr	r3, [pc, #4]	; (80057f0 <HAL_GetTick+0x8>)
 80057ea:	6818      	ldr	r0, [r3, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:264
}
 80057ec:	4770      	bx	lr
 80057ee:	bf00      	nop
 80057f0:	20001af0 	.word	0x20001af0

080057f4 <HAL_Delay>:
HAL_Delay():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:236
	
	/* Call 1ms interrupt handler function */
	TM_DELAY_1msHandler();
}

void HAL_Delay(uint32_t Delay) {
 80057f4:	b538      	push	{r3, r4, r5, lr}
 80057f6:	4604      	mov	r4, r0
__get_IPSR():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../system/include/cmsis/cmsis_gcc.h:109
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80057f8:	f3ef 8305 	mrs	r3, IPSR
HAL_Delay():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:239
	/* Delay for amount of milliseconds */
	/* Check if we are called from ISR */
	if (__get_IPSR() == 0) {
 80057fc:	b973      	cbnz	r3, 800581c <HAL_Delay+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:241
		/* Called from thread mode */
		uint32_t tickstart = HAL_GetTick();
 80057fe:	f7ff fff3 	bl	80057e8 <HAL_GetTick>
 8005802:	4605      	mov	r5, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:244 (discriminator 1)
		
		/* Count interrupts */
		while ((HAL_GetTick() - tickstart) < Delay) {
 8005804:	f7ff fff0 	bl	80057e8 <HAL_GetTick>
 8005808:	1b40      	subs	r0, r0, r5
 800580a:	4284      	cmp	r4, r0
 800580c:	d8fa      	bhi.n	8005804 <HAL_Delay+0x10>
 800580e:	bd38      	pop	{r3, r4, r5, pc}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:254
		}
	} else {
		/* Called from interrupt mode */
		while (Delay) {
			/* Check if timer reached zero after we last checked COUNTFLAG bit */
			if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 8005810:	4b04      	ldr	r3, [pc, #16]	; (8005824 <HAL_Delay+0x30>)
 8005812:	681b      	ldr	r3, [r3, #0]
 8005814:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8005818:	d000      	beq.n	800581c <HAL_Delay+0x28>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:255
				Delay--;
 800581a:	3c01      	subs	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_delay.c:252
			__WFI();
#endif
		}
	} else {
		/* Called from interrupt mode */
		while (Delay) {
 800581c:	2c00      	cmp	r4, #0
 800581e:	d1f7      	bne.n	8005810 <HAL_Delay+0x1c>
 8005820:	bd38      	pop	{r3, r4, r5, pc}
 8005822:	bf00      	nop
 8005824:	e000e010 	.word	0xe000e010

08005828 <TM_GPIO_GetPortSource>:
TM_GPIO_GetPortSource():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:185
}

uint16_t TM_GPIO_GetPortSource(GPIO_TypeDef* GPIOx) {
	/* Get port source number */
	/* Offset from GPIOA                       Difference between 2 GPIO addresses */
	return ((uint32_t)GPIOx - (GPIOA_BASE)) / ((GPIOB_BASE) - (GPIOA_BASE));
 8005828:	f100 403f 	add.w	r0, r0, #3204448256	; 0xbf000000
 800582c:	f500 007e 	add.w	r0, r0, #16646144	; 0xfe0000
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:186
}
 8005830:	f3c0 208f 	ubfx	r0, r0, #10, #16
 8005834:	4770      	bx	lr
 8005836:	bf00      	nop

08005838 <TM_GPIO_INT_EnableClock>:
TM_GPIO_INT_EnableClock():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:189

/* Private functions */
void TM_GPIO_INT_EnableClock(GPIO_TypeDef* GPIOx) {
 8005838:	b508      	push	{r3, lr}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:194
	/* Set bit according to the 1 << portsourcenumber */
#if defined(STM32F0xx)
	RCC->AHBENR |= (1 << (TM_GPIO_GetPortSource(GPIOx) + 17));
#else
	RCC->AHB1ENR |= (1 << TM_GPIO_GetPortSource(GPIOx));
 800583a:	f7ff fff5 	bl	8005828 <TM_GPIO_GetPortSource>
 800583e:	2301      	movs	r3, #1
 8005840:	fa03 f000 	lsl.w	r0, r3, r0
 8005844:	4a02      	ldr	r2, [pc, #8]	; (8005850 <TM_GPIO_INT_EnableClock+0x18>)
 8005846:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8005848:	4318      	orrs	r0, r3
 800584a:	6310      	str	r0, [r2, #48]	; 0x30
 800584c:	bd08      	pop	{r3, pc}
 800584e:	bf00      	nop
 8005850:	40023800 	.word	0x40023800

08005854 <TM_GPIO_INT_Init>:
TM_GPIO_INT_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:207
#else
	RCC->AHB1ENR &= ~(1 << TM_GPIO_GetPortSource(GPIOx));
#endif
}

void TM_GPIO_INT_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed) {
 8005854:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005858:	4604      	mov	r4, r0
 800585a:	460d      	mov	r5, r1
 800585c:	4616      	mov	r6, r2
 800585e:	4699      	mov	r9, r3
 8005860:	f89d 7028 	ldrb.w	r7, [sp, #40]	; 0x28
 8005864:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:209
	uint8_t pinpos;
	uint8_t ptr = TM_GPIO_GetPortSource(GPIOx);
 8005868:	f7ff ffde 	bl	8005828 <TM_GPIO_GetPortSource>
 800586c:	b2c0      	uxtb	r0, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:220
		GPIO_Speed = TM_GPIO_Speed_High;
	}
#endif
	
	/* Go through all pins */
	for (pinpos = 0; pinpos < 0x10; pinpos++) {
 800586e:	2300      	movs	r3, #0
 8005870:	e046      	b.n	8005900 <TM_GPIO_INT_Init+0xac>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:222
		/* Check if pin available */
		if ((GPIO_Pin & (1 << pinpos)) == 0) {
 8005872:	fa45 f203 	asr.w	r2, r5, r3
 8005876:	f012 0f01 	tst.w	r2, #1
 800587a:	d03f      	beq.n	80058fc <TM_GPIO_INT_Init+0xa8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:227
			continue;
		}
		
		/* Pin is used */
		GPIO_UsedPins[ptr] |= 1 << pinpos;
 800587c:	f04f 0e01 	mov.w	lr, #1
 8005880:	fa0e fe03 	lsl.w	lr, lr, r3
 8005884:	4920      	ldr	r1, [pc, #128]	; (8005908 <TM_GPIO_INT_Init+0xb4>)
 8005886:	f831 2010 	ldrh.w	r2, [r1, r0, lsl #1]
 800588a:	ea4e 0202 	orr.w	r2, lr, r2
 800588e:	f821 2010 	strh.w	r2, [r1, r0, lsl #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:230
		
		/* Set GPIO PUPD register */
		GPIOx->PUPDR = (GPIOx->PUPDR & ~(0x03 << (2 * pinpos))) | ((uint32_t)(GPIO_PuPd << (2 * pinpos)));
 8005892:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8005896:	0059      	lsls	r1, r3, #1
 8005898:	2203      	movs	r2, #3
 800589a:	408a      	lsls	r2, r1
 800589c:	43d2      	mvns	r2, r2
 800589e:	ea02 0b0c 	and.w	fp, r2, ip
 80058a2:	fa07 fc01 	lsl.w	ip, r7, r1
 80058a6:	ea4b 0c0c 	orr.w	ip, fp, ip
 80058aa:	f8c4 c00c 	str.w	ip, [r4, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:233
		
		/* Set GPIO MODE register */
		GPIOx->MODER = (GPIOx->MODER & ~((uint32_t)(0x03 << (2 * pinpos)))) | ((uint32_t)(GPIO_Mode << (2 * pinpos)));
 80058ae:	f8d4 c000 	ldr.w	ip, [r4]
 80058b2:	ea0c 0b02 	and.w	fp, ip, r2
 80058b6:	fa06 fc01 	lsl.w	ip, r6, r1
 80058ba:	ea4b 0c0c 	orr.w	ip, fp, ip
 80058be:	f8c4 c000 	str.w	ip, [r4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:236
		
		/* Set only if output or alternate functions */
		if (GPIO_Mode == TM_GPIO_Mode_OUT || GPIO_Mode == TM_GPIO_Mode_AF) {		
 80058c2:	f106 3cff 	add.w	ip, r6, #4294967295
 80058c6:	fa5f fc8c 	uxtb.w	ip, ip
 80058ca:	f1bc 0f01 	cmp.w	ip, #1
 80058ce:	d815      	bhi.n	80058fc <TM_GPIO_INT_Init+0xa8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:238
			/* Set GPIO OTYPE register */
			GPIOx->OTYPER = (GPIOx->OTYPER & ~(uint16_t)(0x01 << pinpos)) | ((uint16_t)(GPIO_OType << pinpos));
 80058d0:	f8d4 c004 	ldr.w	ip, [r4, #4]
 80058d4:	fa1f fe8e 	uxth.w	lr, lr
 80058d8:	ea2c 0e0e 	bic.w	lr, ip, lr
 80058dc:	fa09 fa03 	lsl.w	sl, r9, r3
 80058e0:	fa1f fa8a 	uxth.w	sl, sl
 80058e4:	ea4a 0a0e 	orr.w	sl, sl, lr
 80058e8:	f8c4 a004 	str.w	sl, [r4, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:241
			
			/* Set GPIO OSPEED register */
			GPIOx->OSPEEDR = (GPIOx->OSPEEDR & ~((uint32_t)(0x03 << (2 * pinpos)))) | ((uint32_t)(GPIO_Speed << (2 * pinpos)));
 80058ec:	f8d4 e008 	ldr.w	lr, [r4, #8]
 80058f0:	ea02 020e 	and.w	r2, r2, lr
 80058f4:	fa08 f101 	lsl.w	r1, r8, r1
 80058f8:	430a      	orrs	r2, r1
 80058fa:	60a2      	str	r2, [r4, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:220 (discriminator 2)
		GPIO_Speed = TM_GPIO_Speed_High;
	}
#endif
	
	/* Go through all pins */
	for (pinpos = 0; pinpos < 0x10; pinpos++) {
 80058fc:	3301      	adds	r3, #1
 80058fe:	b2db      	uxtb	r3, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:220 (discriminator 1)
 8005900:	2b0f      	cmp	r3, #15
 8005902:	d9b6      	bls.n	8005872 <TM_GPIO_INT_Init+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:244
			
			/* Set GPIO OSPEED register */
			GPIOx->OSPEEDR = (GPIOx->OSPEEDR & ~((uint32_t)(0x03 << (2 * pinpos)))) | ((uint32_t)(GPIO_Speed << (2 * pinpos)));
		}
	}
}
 8005904:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005908:	20001af8 	.word	0x20001af8

0800590c <TM_GPIO_Init>:
TM_GPIO_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:31
void TM_GPIO_INT_DisableClock(GPIO_TypeDef* GPIOx);
void TM_GPIO_INT_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed);

void TM_GPIO_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed) {	
	/* Check input */
	if (GPIO_Pin == 0x00) {
 800590c:	b1a9      	cbz	r1, 800593a <TM_GPIO_Init+0x2e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:29
/* Private functions */
void TM_GPIO_INT_EnableClock(GPIO_TypeDef* GPIOx);
void TM_GPIO_INT_DisableClock(GPIO_TypeDef* GPIOx);
void TM_GPIO_INT_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed);

void TM_GPIO_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed) {	
 800590e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005910:	b083      	sub	sp, #12
 8005912:	460f      	mov	r7, r1
 8005914:	461e      	mov	r6, r3
 8005916:	4615      	mov	r5, r2
 8005918:	4604      	mov	r4, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:36
	if (GPIO_Pin == 0x00) {
		return;
	}
	
	/* Enable clock for GPIO */
	TM_GPIO_INT_EnableClock(GPIOx);
 800591a:	f7ff ff8d 	bl	8005838 <TM_GPIO_INT_EnableClock>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:39
	
	/* Do initialization */
	TM_GPIO_INT_Init(GPIOx, GPIO_Pin, GPIO_Mode, GPIO_OType, GPIO_PuPd, GPIO_Speed);
 800591e:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 8005922:	9301      	str	r3, [sp, #4]
 8005924:	f89d 3020 	ldrb.w	r3, [sp, #32]
 8005928:	9300      	str	r3, [sp, #0]
 800592a:	4633      	mov	r3, r6
 800592c:	462a      	mov	r2, r5
 800592e:	4639      	mov	r1, r7
 8005930:	4620      	mov	r0, r4
 8005932:	f7ff ff8f 	bl	8005854 <TM_GPIO_INT_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:40
}
 8005936:	b003      	add	sp, #12
 8005938:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800593a:	4770      	bx	lr

0800593c <TM_GPIO_InitAlternate>:
TM_GPIO_InitAlternate():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:42

void TM_GPIO_InitAlternate(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed, uint8_t Alternate) {
 800593c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005940:	b082      	sub	sp, #8
 8005942:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:46
	uint32_t pinpos;

	/* Check input */
	if (GPIO_Pin == 0x00) {
 8005946:	b351      	cbz	r1, 800599e <TM_GPIO_InitAlternate+0x62>
 8005948:	460f      	mov	r7, r1
 800594a:	469a      	mov	sl, r3
 800594c:	4691      	mov	r9, r2
 800594e:	4606      	mov	r6, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:51
		return;
	}
	
	/* Enable GPIOx clock */
	TM_GPIO_INT_EnableClock(GPIOx);
 8005950:	f7ff ff72 	bl	8005838 <TM_GPIO_INT_EnableClock>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:54
	
	/* Set alternate functions for all pins */
	for (pinpos = 0; pinpos < 0x10; pinpos++) {
 8005954:	2400      	movs	r4, #0
 8005956:	e015      	b.n	8005984 <TM_GPIO_InitAlternate+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:56
		/* Check pin */
		if ((GPIO_Pin & (1 << pinpos)) == 0) {
 8005958:	fa47 f304 	asr.w	r3, r7, r4
 800595c:	f013 0f01 	tst.w	r3, #1
 8005960:	d00f      	beq.n	8005982 <TM_GPIO_InitAlternate+0x46>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:61
			continue;
		}
		
		/* Set alternate function */
		GPIOx->AFR[pinpos >> 0x03] = (GPIOx->AFR[pinpos >> 0x03] & ~(0x0F << (4 * (pinpos & 0x07)))) | (Alternate << (4 * (pinpos & 0x07)));
 8005962:	08e1      	lsrs	r1, r4, #3
 8005964:	3108      	adds	r1, #8
 8005966:	f856 2021 	ldr.w	r2, [r6, r1, lsl #2]
 800596a:	f004 0507 	and.w	r5, r4, #7
 800596e:	00ad      	lsls	r5, r5, #2
 8005970:	230f      	movs	r3, #15
 8005972:	40ab      	lsls	r3, r5
 8005974:	ea22 0303 	bic.w	r3, r2, r3
 8005978:	fa08 f505 	lsl.w	r5, r8, r5
 800597c:	431d      	orrs	r5, r3
 800597e:	f846 5021 	str.w	r5, [r6, r1, lsl #2]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:54 (discriminator 2)
	
	/* Enable GPIOx clock */
	TM_GPIO_INT_EnableClock(GPIOx);
	
	/* Set alternate functions for all pins */
	for (pinpos = 0; pinpos < 0x10; pinpos++) {
 8005982:	3401      	adds	r4, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:54 (discriminator 1)
 8005984:	2c0f      	cmp	r4, #15
 8005986:	d9e7      	bls.n	8005958 <TM_GPIO_InitAlternate+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:65
		/* Set alternate function */
		GPIOx->AFR[pinpos >> 0x03] = (GPIOx->AFR[pinpos >> 0x03] & ~(0x0F << (4 * (pinpos & 0x07)))) | (Alternate << (4 * (pinpos & 0x07)));
	}
	
	/* Do initialization */
	TM_GPIO_INT_Init(GPIOx, GPIO_Pin, TM_GPIO_Mode_AF, GPIO_OType, GPIO_PuPd, GPIO_Speed);
 8005988:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 800598c:	9301      	str	r3, [sp, #4]
 800598e:	f8cd a000 	str.w	sl, [sp]
 8005992:	464b      	mov	r3, r9
 8005994:	2202      	movs	r2, #2
 8005996:	4639      	mov	r1, r7
 8005998:	4630      	mov	r0, r6
 800599a:	f7ff ff5b 	bl	8005854 <TM_GPIO_INT_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_gpio.c:66
}
 800599e:	b002      	add	sp, #8
 80059a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080059a4 <TM_SPI_WriteMulti>:
TM_SPI_WriteMulti():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:256
	}
}

void TM_SPI_WriteMulti(SPI_TypeDef* SPIx, uint8_t* dataOut, uint32_t count) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED(SPIx);
 80059a4:	6803      	ldr	r3, [r0, #0]
 80059a6:	f013 0f40 	tst.w	r3, #64	; 0x40
 80059aa:	d117      	bne.n	80059dc <TM_SPI_WriteMulti+0x38>
 80059ac:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:260 (discriminator 3)
	
	while (count--) {
		/* Wait busy */
		SPI_WAIT_TX(SPIx);
 80059ae:	6883      	ldr	r3, [r0, #8]
 80059b0:	f013 0f02 	tst.w	r3, #2
 80059b4:	d0fb      	beq.n	80059ae <TM_SPI_WriteMulti+0xa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:260 (discriminator 2)
 80059b6:	6883      	ldr	r3, [r0, #8]
 80059b8:	f013 0f80 	tst.w	r3, #128	; 0x80
 80059bc:	d1f7      	bne.n	80059ae <TM_SPI_WriteMulti+0xa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:263
		
		/* Fill output buffer with data */
		*(__IO uint8_t *)&SPIx->DR = *dataOut++;
 80059be:	1c4d      	adds	r5, r1, #1
 80059c0:	780b      	ldrb	r3, [r1, #0]
 80059c2:	7303      	strb	r3, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:266 (discriminator 3)
		
		/* Wait for SPI to end everything */
		SPI_WAIT_RX(SPIx);
 80059c4:	6883      	ldr	r3, [r0, #8]
 80059c6:	f013 0f01 	tst.w	r3, #1
 80059ca:	d0fb      	beq.n	80059c4 <TM_SPI_WriteMulti+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:266 (discriminator 2)
 80059cc:	6883      	ldr	r3, [r0, #8]
 80059ce:	f013 0f80 	tst.w	r3, #128	; 0x80
 80059d2:	d1f7      	bne.n	80059c4 <TM_SPI_WriteMulti+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:269
		
		/* Read data register */
		(void)*(__IO uint16_t *)&SPIx->DR;
 80059d4:	8983      	ldrh	r3, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:258

void TM_SPI_WriteMulti(SPI_TypeDef* SPIx, uint8_t* dataOut, uint32_t count) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED(SPIx);
	
	while (count--) {
 80059d6:	4622      	mov	r2, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:263
		/* Wait busy */
		SPI_WAIT_TX(SPIx);
		
		/* Fill output buffer with data */
		*(__IO uint8_t *)&SPIx->DR = *dataOut++;
 80059d8:	4629      	mov	r1, r5
 80059da:	e000      	b.n	80059de <TM_SPI_WriteMulti+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:254
		/* Read data register */
		*dataIn++ = *(__IO uint8_t *)&SPIx->DR;
	}
}

void TM_SPI_WriteMulti(SPI_TypeDef* SPIx, uint8_t* dataOut, uint32_t count) {
 80059dc:	b430      	push	{r4, r5}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:258
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED(SPIx);
	
	while (count--) {
 80059de:	1e54      	subs	r4, r2, #1
 80059e0:	2a00      	cmp	r2, #0
 80059e2:	d1e4      	bne.n	80059ae <TM_SPI_WriteMulti+0xa>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:271
		SPI_WAIT_RX(SPIx);
		
		/* Read data register */
		(void)*(__IO uint16_t *)&SPIx->DR;
	}
}
 80059e4:	bc30      	pop	{r4, r5}
 80059e6:	4770      	bx	lr

080059e8 <TM_SPI_ReadMulti>:
TM_SPI_ReadMulti():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:273

void TM_SPI_ReadMulti(SPI_TypeDef* SPIx, uint8_t* dataIn, uint8_t dummy, uint32_t count) {
 80059e8:	b410      	push	{r4}
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:275
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED(SPIx);
 80059ea:	6804      	ldr	r4, [r0, #0]
 80059ec:	f014 0f40 	tst.w	r4, #64	; 0x40
 80059f0:	d115      	bne.n	8005a1e <TM_SPI_ReadMulti+0x36>
 80059f2:	e017      	b.n	8005a24 <TM_SPI_ReadMulti+0x3c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:279 (discriminator 3)
	
	while (count--) {
		/* Wait busy */
		SPI_WAIT_TX(SPIx);
 80059f4:	6883      	ldr	r3, [r0, #8]
 80059f6:	f013 0f02 	tst.w	r3, #2
 80059fa:	d0fb      	beq.n	80059f4 <TM_SPI_ReadMulti+0xc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:279 (discriminator 2)
 80059fc:	6883      	ldr	r3, [r0, #8]
 80059fe:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005a02:	d1f7      	bne.n	80059f4 <TM_SPI_ReadMulti+0xc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:282
		
		/* Fill output buffer with data */
		*(__IO uint8_t *)&SPIx->DR = dummy;
 8005a04:	7302      	strb	r2, [r0, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:285 (discriminator 3)
		
		/* Wait for SPI to end everything */
		SPI_WAIT_RX(SPIx);
 8005a06:	6883      	ldr	r3, [r0, #8]
 8005a08:	f013 0f01 	tst.w	r3, #1
 8005a0c:	d0fb      	beq.n	8005a06 <TM_SPI_ReadMulti+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:285 (discriminator 2)
 8005a0e:	6883      	ldr	r3, [r0, #8]
 8005a10:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005a14:	d1f7      	bne.n	8005a06 <TM_SPI_ReadMulti+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:288
		
		/* Save data to buffer */
		*dataIn++ = *(__IO uint8_t *)&SPIx->DR;
 8005a16:	7b03      	ldrb	r3, [r0, #12]
 8005a18:	700b      	strb	r3, [r1, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:277

void TM_SPI_ReadMulti(SPI_TypeDef* SPIx, uint8_t* dataIn, uint8_t dummy, uint32_t count) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED(SPIx);
	
	while (count--) {
 8005a1a:	4623      	mov	r3, r4
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:288
		
		/* Wait for SPI to end everything */
		SPI_WAIT_RX(SPIx);
		
		/* Save data to buffer */
		*dataIn++ = *(__IO uint8_t *)&SPIx->DR;
 8005a1c:	3101      	adds	r1, #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:277

void TM_SPI_ReadMulti(SPI_TypeDef* SPIx, uint8_t* dataIn, uint8_t dummy, uint32_t count) {
	/* Check if SPI is enabled */
	SPI_CHECK_ENABLED(SPIx);
	
	while (count--) {
 8005a1e:	1e5c      	subs	r4, r3, #1
 8005a20:	2b00      	cmp	r3, #0
 8005a22:	d1e7      	bne.n	80059f4 <TM_SPI_ReadMulti+0xc>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:290
		SPI_WAIT_RX(SPIx);
		
		/* Save data to buffer */
		*dataIn++ = *(__IO uint8_t *)&SPIx->DR;
	}
}
 8005a24:	bc10      	pop	{r4}
 8005a26:	4770      	bx	lr

08005a28 <TM_SPI_InitCustomPinsCallback>:
TM_SPI_InitCustomPinsCallback():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:352
		/* Save data to buffer */
		*dataIn++ = SPIx->DR;
	}
}

__weak void TM_SPI_InitCustomPinsCallback(SPI_TypeDef* SPIx, uint16_t AlternateFunction) { 
 8005a28:	4770      	bx	lr
 8005a2a:	bf00      	nop

08005a2c <TM_SPI1_INT_InitPins>:
TM_SPI1_INT_InitPins():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:482
	__HAL_SPI_ENABLE(&SPIHandle);
}

/* Private functions */
#ifdef SPI1
void TM_SPI1_INT_InitPins(TM_SPI_PinsPack_t pinspack) {
 8005a2c:	b510      	push	{r4, lr}
 8005a2e:	b082      	sub	sp, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:485
	/* Init SPI pins */
#if defined(GPIOA)
	if (pinspack == TM_SPI_PinsPack_1) {
 8005a30:	4604      	mov	r4, r0
 8005a32:	b948      	cbnz	r0, 8005a48 <TM_SPI1_INT_InitPins+0x1c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:486
		TM_GPIO_InitAlternate(GPIOA, GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI1);
 8005a34:	2305      	movs	r3, #5
 8005a36:	9301      	str	r3, [sp, #4]
 8005a38:	2303      	movs	r3, #3
 8005a3a:	9300      	str	r3, [sp, #0]
 8005a3c:	2300      	movs	r3, #0
 8005a3e:	461a      	mov	r2, r3
 8005a40:	21e0      	movs	r1, #224	; 0xe0
 8005a42:	480b      	ldr	r0, [pc, #44]	; (8005a70 <TM_SPI1_INT_InitPins+0x44>)
 8005a44:	f7ff ff7a 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:490
	}
#endif
#if defined(GPIOB)
	if (pinspack == TM_SPI_PinsPack_2) {
 8005a48:	2c01      	cmp	r4, #1
 8005a4a:	d109      	bne.n	8005a60 <TM_SPI1_INT_InitPins+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:491
		TM_GPIO_InitAlternate(GPIOB, GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_5, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI1);
 8005a4c:	2305      	movs	r3, #5
 8005a4e:	9301      	str	r3, [sp, #4]
 8005a50:	2303      	movs	r3, #3
 8005a52:	9300      	str	r3, [sp, #0]
 8005a54:	2300      	movs	r3, #0
 8005a56:	461a      	mov	r2, r3
 8005a58:	2138      	movs	r1, #56	; 0x38
 8005a5a:	4806      	ldr	r0, [pc, #24]	; (8005a74 <TM_SPI1_INT_InitPins+0x48>)
 8005a5c:	f7ff ff6e 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:494
	}
#endif
	if (pinspack == TM_SPI_PinsPack_Custom) {
 8005a60:	2c04      	cmp	r4, #4
 8005a62:	d103      	bne.n	8005a6c <TM_SPI1_INT_InitPins+0x40>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:496
		/* Call user function */
		TM_SPI_InitCustomPinsCallback(SPI1, GPIO_AFx_SPI1);
 8005a64:	2105      	movs	r1, #5
 8005a66:	4804      	ldr	r0, [pc, #16]	; (8005a78 <TM_SPI1_INT_InitPins+0x4c>)
 8005a68:	f7ff ffde 	bl	8005a28 <TM_SPI_InitCustomPinsCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:498
	}
}
 8005a6c:	b002      	add	sp, #8
 8005a6e:	bd10      	pop	{r4, pc}
 8005a70:	40020000 	.word	0x40020000
 8005a74:	40020400 	.word	0x40020400
 8005a78:	40013000 	.word	0x40013000

08005a7c <TM_SPI2_INT_InitPins>:
TM_SPI2_INT_InitPins():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:502
#endif

#ifdef SPI2
void TM_SPI2_INT_InitPins(TM_SPI_PinsPack_t pinspack) {
 8005a7c:	b570      	push	{r4, r5, r6, lr}
 8005a7e:	b082      	sub	sp, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:505
	/* Init SPI pins */
#if defined(GPIOB) && defined(GPIOC)
	if (pinspack == TM_SPI_PinsPack_1) {
 8005a80:	4604      	mov	r4, r0
 8005a82:	b9a8      	cbnz	r0, 8005ab0 <TM_SPI2_INT_InitPins+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:506
		TM_GPIO_InitAlternate(GPIOB, GPIO_PIN_10, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI2);
 8005a84:	2605      	movs	r6, #5
 8005a86:	9601      	str	r6, [sp, #4]
 8005a88:	2503      	movs	r5, #3
 8005a8a:	9500      	str	r5, [sp, #0]
 8005a8c:	2300      	movs	r3, #0
 8005a8e:	461a      	mov	r2, r3
 8005a90:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8005a94:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8005a98:	f500 3001 	add.w	r0, r0, #132096	; 0x20400
 8005a9c:	f7ff ff4e 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:507
		TM_GPIO_InitAlternate(GPIOC, GPIO_PIN_2 | GPIO_PIN_3, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI2);
 8005aa0:	9601      	str	r6, [sp, #4]
 8005aa2:	9500      	str	r5, [sp, #0]
 8005aa4:	2300      	movs	r3, #0
 8005aa6:	461a      	mov	r2, r3
 8005aa8:	210c      	movs	r1, #12
 8005aaa:	481c      	ldr	r0, [pc, #112]	; (8005b1c <TM_SPI2_INT_InitPins+0xa0>)
 8005aac:	f7ff ff46 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:511
	}
#endif
#if defined(GPIOB)
	if (pinspack == TM_SPI_PinsPack_2) {
 8005ab0:	2c01      	cmp	r4, #1
 8005ab2:	d10a      	bne.n	8005aca <TM_SPI2_INT_InitPins+0x4e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:512
		TM_GPIO_InitAlternate(GPIOB, GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI2);
 8005ab4:	2305      	movs	r3, #5
 8005ab6:	9301      	str	r3, [sp, #4]
 8005ab8:	2303      	movs	r3, #3
 8005aba:	9300      	str	r3, [sp, #0]
 8005abc:	2300      	movs	r3, #0
 8005abe:	461a      	mov	r2, r3
 8005ac0:	f44f 4160 	mov.w	r1, #57344	; 0xe000
 8005ac4:	4816      	ldr	r0, [pc, #88]	; (8005b20 <TM_SPI2_INT_InitPins+0xa4>)
 8005ac6:	f7ff ff39 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:516
	}
#endif
#if defined(GPIOI)
	if (pinspack == TM_SPI_PinsPack_3) {
 8005aca:	2c02      	cmp	r4, #2
 8005acc:	d109      	bne.n	8005ae2 <TM_SPI2_INT_InitPins+0x66>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:517
		TM_GPIO_InitAlternate(GPIOI, GPIO_PIN_0 | GPIO_PIN_2 | GPIO_PIN_3, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI2);
 8005ace:	2305      	movs	r3, #5
 8005ad0:	9301      	str	r3, [sp, #4]
 8005ad2:	2303      	movs	r3, #3
 8005ad4:	9300      	str	r3, [sp, #0]
 8005ad6:	2300      	movs	r3, #0
 8005ad8:	461a      	mov	r2, r3
 8005ada:	210d      	movs	r1, #13
 8005adc:	4811      	ldr	r0, [pc, #68]	; (8005b24 <TM_SPI2_INT_InitPins+0xa8>)
 8005ade:	f7ff ff2d 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:521
	}
#endif
#if defined(GPIOB) && defined(GPIOI)
	if (pinspack == TM_SPI_PinsPack_4) {
 8005ae2:	2c03      	cmp	r4, #3
 8005ae4:	d112      	bne.n	8005b0c <TM_SPI2_INT_InitPins+0x90>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:522
		TM_GPIO_InitAlternate(GPIOB, GPIO_PIN_14 | GPIO_PIN_15, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI2);
 8005ae6:	2605      	movs	r6, #5
 8005ae8:	9601      	str	r6, [sp, #4]
 8005aea:	2503      	movs	r5, #3
 8005aec:	9500      	str	r5, [sp, #0]
 8005aee:	2300      	movs	r3, #0
 8005af0:	461a      	mov	r2, r3
 8005af2:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 8005af6:	480a      	ldr	r0, [pc, #40]	; (8005b20 <TM_SPI2_INT_InitPins+0xa4>)
 8005af8:	f7ff ff20 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:523
		TM_GPIO_InitAlternate(GPIOI, GPIO_PIN_1, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI2);
 8005afc:	9601      	str	r6, [sp, #4]
 8005afe:	9500      	str	r5, [sp, #0]
 8005b00:	2300      	movs	r3, #0
 8005b02:	461a      	mov	r2, r3
 8005b04:	2102      	movs	r1, #2
 8005b06:	4807      	ldr	r0, [pc, #28]	; (8005b24 <TM_SPI2_INT_InitPins+0xa8>)
 8005b08:	f7ff ff18 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:526
	}
#endif
	if (pinspack == TM_SPI_PinsPack_Custom) {
 8005b0c:	2c04      	cmp	r4, #4
 8005b0e:	d103      	bne.n	8005b18 <TM_SPI2_INT_InitPins+0x9c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:528
		/* Call user function */
		TM_SPI_InitCustomPinsCallback(SPI2, GPIO_AFx_SPI2);
 8005b10:	2105      	movs	r1, #5
 8005b12:	4805      	ldr	r0, [pc, #20]	; (8005b28 <TM_SPI2_INT_InitPins+0xac>)
 8005b14:	f7ff ff88 	bl	8005a28 <TM_SPI_InitCustomPinsCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:530
	}
}
 8005b18:	b002      	add	sp, #8
 8005b1a:	bd70      	pop	{r4, r5, r6, pc}
 8005b1c:	40020800 	.word	0x40020800
 8005b20:	40020400 	.word	0x40020400
 8005b24:	40022000 	.word	0x40022000
 8005b28:	40003800 	.word	0x40003800

08005b2c <TM_SPI3_INT_InitPins>:
TM_SPI3_INT_InitPins():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:534
#endif

#ifdef SPI3
void TM_SPI3_INT_InitPins(TM_SPI_PinsPack_t pinspack) {
 8005b2c:	b510      	push	{r4, lr}
 8005b2e:	b082      	sub	sp, #8
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:537
	/* Enable SPI pins */
#if defined(GPIOB)
	if (pinspack == TM_SPI_PinsPack_1) {
 8005b30:	4604      	mov	r4, r0
 8005b32:	b960      	cbnz	r0, 8005b4e <TM_SPI3_INT_InitPins+0x22>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:538
		TM_GPIO_InitAlternate(GPIOB, GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_5, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI3);
 8005b34:	2305      	movs	r3, #5
 8005b36:	9301      	str	r3, [sp, #4]
 8005b38:	2303      	movs	r3, #3
 8005b3a:	9300      	str	r3, [sp, #0]
 8005b3c:	2300      	movs	r3, #0
 8005b3e:	461a      	mov	r2, r3
 8005b40:	2138      	movs	r1, #56	; 0x38
 8005b42:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8005b46:	f500 3001 	add.w	r0, r0, #132096	; 0x20400
 8005b4a:	f7ff fef7 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:542
	}
#endif
#if defined(GPIOC)
	if (pinspack == TM_SPI_PinsPack_2) {
 8005b4e:	2c01      	cmp	r4, #1
 8005b50:	d10a      	bne.n	8005b68 <TM_SPI3_INT_InitPins+0x3c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:543
		TM_GPIO_InitAlternate(GPIOC, GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High, GPIO_AFx_SPI3);
 8005b52:	2305      	movs	r3, #5
 8005b54:	9301      	str	r3, [sp, #4]
 8005b56:	2303      	movs	r3, #3
 8005b58:	9300      	str	r3, [sp, #0]
 8005b5a:	2300      	movs	r3, #0
 8005b5c:	461a      	mov	r2, r3
 8005b5e:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 8005b62:	4805      	ldr	r0, [pc, #20]	; (8005b78 <TM_SPI3_INT_InitPins+0x4c>)
 8005b64:	f7ff feea 	bl	800593c <TM_GPIO_InitAlternate>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:546
	}
#endif
	if (pinspack == TM_SPI_PinsPack_Custom) {
 8005b68:	2c04      	cmp	r4, #4
 8005b6a:	d103      	bne.n	8005b74 <TM_SPI3_INT_InitPins+0x48>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:548
		/* Call user function */
		TM_SPI_InitCustomPinsCallback(SPI3, GPIO_AFx_SPI3);
 8005b6c:	2105      	movs	r1, #5
 8005b6e:	4803      	ldr	r0, [pc, #12]	; (8005b7c <TM_SPI3_INT_InitPins+0x50>)
 8005b70:	f7ff ff5a 	bl	8005a28 <TM_SPI_InitCustomPinsCallback>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:550
	}
}
 8005b74:	b002      	add	sp, #8
 8005b76:	bd10      	pop	{r4, pc}
 8005b78:	40020800 	.word	0x40020800
 8005b7c:	40003c00 	.word	0x40003c00

08005b80 <TM_SPIx_Init>:
TM_SPIx_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:359
           the TM_SPI_InitCustomPinsCallback could be implemented in the user file
   */
}

/* Private functions */
static void TM_SPIx_Init(SPI_TypeDef* SPIx, TM_SPI_PinsPack_t pinspack, TM_SPI_Mode_t SPI_Mode, uint16_t SPI_BaudRatePrescaler, uint16_t SPI_MasterSlave, uint16_t SPI_FirstBit) {
 8005b80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005b82:	b09b      	sub	sp, #108	; 0x6c
 8005b84:	4604      	mov	r4, r0
 8005b86:	460f      	mov	r7, r1
 8005b88:	4615      	mov	r5, r2
 8005b8a:	461e      	mov	r6, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:363
	SPI_HandleTypeDef SPIHandle;
	
	/* Save instance */
	SPIHandle.Instance = SPIx;
 8005b8c:	9004      	str	r0, [sp, #16]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:366
	
#ifdef SPI1	
	if (SPIx == SPI1) {
 8005b8e:	4b38      	ldr	r3, [pc, #224]	; (8005c70 <TM_SPIx_Init+0xf0>)
 8005b90:	4298      	cmp	r0, r3
 8005b92:	d10f      	bne.n	8005bb4 <TM_SPIx_Init+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:368
		/* Enable SPI clock */
		__HAL_RCC_SPI1_CLK_ENABLE();
 8005b94:	f503 3384 	add.w	r3, r3, #67584	; 0x10800
 8005b98:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005b9a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8005b9e:	645a      	str	r2, [r3, #68]	; 0x44
 8005ba0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005ba2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8005ba6:	9301      	str	r3, [sp, #4]
 8005ba8:	9b01      	ldr	r3, [sp, #4]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:371
		
		/* Init pins */
		TM_SPI1_INT_InitPins(pinspack);
 8005baa:	4608      	mov	r0, r1
 8005bac:	f7ff ff3e 	bl	8005a2c <TM_SPI1_INT_InitPins>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:374
		
		/* Set options */
		SPIHandle.Init.DataSize = TM_SPI1_DATASIZE;
 8005bb0:	2300      	movs	r3, #0
 8005bb2:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:378
	}
#endif
#ifdef SPI2
	if (SPIx == SPI2) {
 8005bb4:	4b2f      	ldr	r3, [pc, #188]	; (8005c74 <TM_SPIx_Init+0xf4>)
 8005bb6:	429c      	cmp	r4, r3
 8005bb8:	d10f      	bne.n	8005bda <TM_SPIx_Init+0x5a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:380
		/* Enable SPI clock */
		__HAL_RCC_SPI2_CLK_ENABLE();
 8005bba:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8005bbe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005bc0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005bc4:	641a      	str	r2, [r3, #64]	; 0x40
 8005bc6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005bc8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8005bcc:	9302      	str	r3, [sp, #8]
 8005bce:	9b02      	ldr	r3, [sp, #8]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:383
		
		/* Init pins */
		TM_SPI2_INT_InitPins(pinspack);
 8005bd0:	4638      	mov	r0, r7
 8005bd2:	f7ff ff53 	bl	8005a7c <TM_SPI2_INT_InitPins>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:386
		
		/* Set options */
		SPIHandle.Init.DataSize = TM_SPI2_DATASIZE;
 8005bd6:	2300      	movs	r3, #0
 8005bd8:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:390
	}
#endif
#ifdef SPI3
	if (SPIx == SPI3) {
 8005bda:	4b27      	ldr	r3, [pc, #156]	; (8005c78 <TM_SPIx_Init+0xf8>)
 8005bdc:	429c      	cmp	r4, r3
 8005bde:	d10f      	bne.n	8005c00 <TM_SPIx_Init+0x80>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:392
		/* Enable SPI clock */
		__HAL_RCC_SPI3_CLK_ENABLE();
 8005be0:	f503 33fe 	add.w	r3, r3, #130048	; 0x1fc00
 8005be4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005be6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8005bea:	641a      	str	r2, [r3, #64]	; 0x40
 8005bec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005bee:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8005bf2:	9303      	str	r3, [sp, #12]
 8005bf4:	9b03      	ldr	r3, [sp, #12]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:395
		
		/* Init pins */
		TM_SPI3_INT_InitPins(pinspack);
 8005bf6:	4638      	mov	r0, r7
 8005bf8:	f7ff ff98 	bl	8005b2c <TM_SPI3_INT_InitPins>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:398
		
		/* Set options */
		SPIHandle.Init.DataSize = TM_SPI3_DATASIZE;
 8005bfc:	2300      	movs	r3, #0
 8005bfe:	9307      	str	r3, [sp, #28]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:440
		SPIHandle.Init.DataSize = TM_SPI6_DATASIZE;
	}
#endif

	/* Fill SPI settings */
	SPIHandle.Init.BaudRatePrescaler = SPI_BaudRatePrescaler;
 8005c00:	960b      	str	r6, [sp, #44]	; 0x2c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:441
	SPIHandle.Init.FirstBit = SPI_FirstBit;
 8005c02:	f8bd 3084 	ldrh.w	r3, [sp, #132]	; 0x84
 8005c06:	930c      	str	r3, [sp, #48]	; 0x30
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:442
	SPIHandle.Init.Mode = SPI_MasterSlave;
 8005c08:	f8bd 3080 	ldrh.w	r3, [sp, #128]	; 0x80
 8005c0c:	9305      	str	r3, [sp, #20]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:444
	
	SPIHandle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005c0e:	2300      	movs	r3, #0
 8005c10:	930e      	str	r3, [sp, #56]	; 0x38
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:445
	SPIHandle.Init.CRCPolynomial = 7;
 8005c12:	2207      	movs	r2, #7
 8005c14:	920f      	str	r2, [sp, #60]	; 0x3c
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:446
	SPIHandle.Init.TIMode = SPI_TIMODE_DISABLE;
 8005c16:	930d      	str	r3, [sp, #52]	; 0x34
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:447
	SPIHandle.Init.NSS = SPI_NSS_SOFT;
 8005c18:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c1c:	920a      	str	r2, [sp, #40]	; 0x28
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:448
	SPIHandle.Init.Direction = SPI_DIRECTION_2LINES;
 8005c1e:	9306      	str	r3, [sp, #24]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:456
	SPIHandle.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
	SPIHandle.Init.CRCLength = SPI_CRC_LENGTH_8BIT;
#endif
	
	/* SPI mode */
	if (SPI_Mode == TM_SPI_Mode_0) {
 8005c20:	b915      	cbnz	r5, 8005c28 <TM_SPIx_Init+0xa8>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:457
		SPIHandle.Init.CLKPolarity = SPI_POLARITY_LOW;
 8005c22:	9308      	str	r3, [sp, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:458
		SPIHandle.Init.CLKPhase = SPI_PHASE_1EDGE;
 8005c24:	9309      	str	r3, [sp, #36]	; 0x24
 8005c26:	e013      	b.n	8005c50 <TM_SPIx_Init+0xd0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:459
	} else if (SPI_Mode == TM_SPI_Mode_1) {
 8005c28:	2d01      	cmp	r5, #1
 8005c2a:	d104      	bne.n	8005c36 <TM_SPIx_Init+0xb6>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:460
		SPIHandle.Init.CLKPolarity = SPI_POLARITY_LOW;
 8005c2c:	2300      	movs	r3, #0
 8005c2e:	9308      	str	r3, [sp, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:461
		SPIHandle.Init.CLKPhase = SPI_PHASE_2EDGE;
 8005c30:	2301      	movs	r3, #1
 8005c32:	9309      	str	r3, [sp, #36]	; 0x24
 8005c34:	e00c      	b.n	8005c50 <TM_SPIx_Init+0xd0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:462
	} else if (SPI_Mode == TM_SPI_Mode_2) {
 8005c36:	2d02      	cmp	r5, #2
 8005c38:	d104      	bne.n	8005c44 <TM_SPIx_Init+0xc4>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:463
		SPIHandle.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8005c3a:	2302      	movs	r3, #2
 8005c3c:	9308      	str	r3, [sp, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:464
		SPIHandle.Init.CLKPhase = SPI_PHASE_1EDGE;
 8005c3e:	2300      	movs	r3, #0
 8005c40:	9309      	str	r3, [sp, #36]	; 0x24
 8005c42:	e005      	b.n	8005c50 <TM_SPIx_Init+0xd0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:465
	} else if (SPI_Mode == TM_SPI_Mode_3) {
 8005c44:	2d03      	cmp	r5, #3
 8005c46:	d103      	bne.n	8005c50 <TM_SPIx_Init+0xd0>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:466
		SPIHandle.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8005c48:	2302      	movs	r3, #2
 8005c4a:	9308      	str	r3, [sp, #32]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:467
		SPIHandle.Init.CLKPhase = SPI_PHASE_2EDGE;
 8005c4c:	2301      	movs	r3, #1
 8005c4e:	9309      	str	r3, [sp, #36]	; 0x24
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:471
	}
	
	/* Disable first */
	__HAL_SPI_DISABLE(&SPIHandle);
 8005c50:	a81a      	add	r0, sp, #104	; 0x68
 8005c52:	f850 2d58 	ldr.w	r2, [r0, #-88]!
 8005c56:	6813      	ldr	r3, [r2, #0]
 8005c58:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005c5c:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:474
	
	/* Init SPI */
	HAL_SPI_Init(&SPIHandle);
 8005c5e:	f7fb ff2f 	bl	8001ac0 <HAL_SPI_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:477
	
	/* Enable SPI */
	__HAL_SPI_ENABLE(&SPIHandle);
 8005c62:	9a04      	ldr	r2, [sp, #16]
 8005c64:	6813      	ldr	r3, [r2, #0]
 8005c66:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005c6a:	6013      	str	r3, [r2, #0]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:478
}
 8005c6c:	b01b      	add	sp, #108	; 0x6c
 8005c6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005c70:	40013000 	.word	0x40013000
 8005c74:	40003800 	.word	0x40003800
 8005c78:	40003c00 	.word	0x40003c00

08005c7c <TM_SPI_Init>:
TM_SPI_Init():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:44
void TM_SPI3_INT_InitPins(TM_SPI_PinsPack_t pinspack);
void TM_SPI4_INT_InitPins(TM_SPI_PinsPack_t pinspack);
void TM_SPI5_INT_InitPins(TM_SPI_PinsPack_t pinspack);
void TM_SPI6_INT_InitPins(TM_SPI_PinsPack_t pinspack);

void TM_SPI_Init(SPI_TypeDef* SPIx, TM_SPI_PinsPack_t pinspack) {
 8005c7c:	b530      	push	{r4, r5, lr}
 8005c7e:	b083      	sub	sp, #12
 8005c80:	4604      	mov	r4, r0
 8005c82:	460d      	mov	r5, r1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:47
	/* Init with default settings */
#ifdef SPI1
	if (SPIx == SPI1) {
 8005c84:	4b13      	ldr	r3, [pc, #76]	; (8005cd4 <TM_SPI_Init+0x58>)
 8005c86:	4298      	cmp	r0, r3
 8005c88:	d108      	bne.n	8005c9c <TM_SPI_Init+0x20>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:48
		TM_SPIx_Init(SPI1, pinspack, TM_SPI1_MODE, TM_SPI1_PRESCALER, TM_SPI1_MASTERSLAVE, TM_SPI1_FIRSTBIT);
 8005c8a:	2200      	movs	r2, #0
 8005c8c:	9201      	str	r2, [sp, #4]
 8005c8e:	f44f 7382 	mov.w	r3, #260	; 0x104
 8005c92:	9300      	str	r3, [sp, #0]
 8005c94:	2320      	movs	r3, #32
 8005c96:	480f      	ldr	r0, [pc, #60]	; (8005cd4 <TM_SPI_Init+0x58>)
 8005c98:	f7ff ff72 	bl	8005b80 <TM_SPIx_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:52
	}
#endif
#ifdef SPI2
	if (SPIx == SPI2) {
 8005c9c:	4b0e      	ldr	r3, [pc, #56]	; (8005cd8 <TM_SPI_Init+0x5c>)
 8005c9e:	429c      	cmp	r4, r3
 8005ca0:	d109      	bne.n	8005cb6 <TM_SPI_Init+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:53
		TM_SPIx_Init(SPI2, pinspack, TM_SPI2_MODE, TM_SPI2_PRESCALER, TM_SPI2_MASTERSLAVE, TM_SPI2_FIRSTBIT);
 8005ca2:	2200      	movs	r2, #0
 8005ca4:	9201      	str	r2, [sp, #4]
 8005ca6:	f44f 7382 	mov.w	r3, #260	; 0x104
 8005caa:	9300      	str	r3, [sp, #0]
 8005cac:	4613      	mov	r3, r2
 8005cae:	4629      	mov	r1, r5
 8005cb0:	4809      	ldr	r0, [pc, #36]	; (8005cd8 <TM_SPI_Init+0x5c>)
 8005cb2:	f7ff ff65 	bl	8005b80 <TM_SPIx_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:57
	}
#endif
#ifdef SPI3
	if (SPIx == SPI3) {
 8005cb6:	4b09      	ldr	r3, [pc, #36]	; (8005cdc <TM_SPI_Init+0x60>)
 8005cb8:	429c      	cmp	r4, r3
 8005cba:	d109      	bne.n	8005cd0 <TM_SPI_Init+0x54>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:58
		TM_SPIx_Init(SPI3, pinspack, TM_SPI3_MODE, TM_SPI3_PRESCALER, TM_SPI3_MASTERSLAVE, TM_SPI3_FIRSTBIT);
 8005cbc:	2200      	movs	r2, #0
 8005cbe:	9201      	str	r2, [sp, #4]
 8005cc0:	f44f 7382 	mov.w	r3, #260	; 0x104
 8005cc4:	9300      	str	r3, [sp, #0]
 8005cc6:	2320      	movs	r3, #32
 8005cc8:	4629      	mov	r1, r5
 8005cca:	4804      	ldr	r0, [pc, #16]	; (8005cdc <TM_SPI_Init+0x60>)
 8005ccc:	f7ff ff58 	bl	8005b80 <TM_SPIx_Init>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../TM/tm_stm32_spi.c:76
#ifdef SPI6
	if (SPIx == SPI6) {
		TM_SPIx_Init(SPI6, pinspack, TM_SPI6_MODE, TM_SPI6_PRESCALER, TM_SPI6_MASTERSLAVE, TM_SPI6_FIRSTBIT);
	}
#endif
}
 8005cd0:	b003      	add	sp, #12
 8005cd2:	bd30      	pop	{r4, r5, pc}
 8005cd4:	40013000 	.word	0x40013000
 8005cd8:	40003800 	.word	0x40003800
 8005cdc:	40003c00 	.word	0x40003c00

08005ce0 <ff_convert>:
ff_convert():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:283
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 8005ce0:	287f      	cmp	r0, #127	; 0x7f
 8005ce2:	d917      	bls.n	8005d14 <ff_convert+0x34>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:287
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
 8005ce4:	b179      	cbz	r1, 8005d06 <ff_convert+0x26>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:288
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8005ce6:	28ff      	cmp	r0, #255	; 0xff
 8005ce8:	d813      	bhi.n	8005d12 <ff_convert+0x32>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:288 (discriminator 1)
 8005cea:	f1a0 0380 	sub.w	r3, r0, #128	; 0x80
 8005cee:	4a0a      	ldr	r2, [pc, #40]	; (8005d18 <ff_convert+0x38>)
 8005cf0:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
 8005cf4:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:292

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
				if (chr == Tbl[c]) break;
 8005cf6:	4a08      	ldr	r2, [pc, #32]	; (8005d18 <ff_convert+0x38>)
 8005cf8:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 8005cfc:	4290      	cmp	r0, r2
 8005cfe:	d005      	beq.n	8005d0c <ff_convert+0x2c>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:291 (discriminator 2)
	} else {
		if (dir) {		/* OEM code to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 8005d00:	3301      	adds	r3, #1
 8005d02:	b29b      	uxth	r3, r3
 8005d04:	e000      	b.n	8005d08 <ff_convert+0x28>
 8005d06:	2300      	movs	r3, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:291 (discriminator 1)
 8005d08:	2b7f      	cmp	r3, #127	; 0x7f
 8005d0a:	d9f4      	bls.n	8005cf6 <ff_convert+0x16>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:294
				if (chr == Tbl[c]) break;
			}
			c = (c + 0x80) & 0xFF;
 8005d0c:	3380      	adds	r3, #128	; 0x80
 8005d0e:	b2d8      	uxtb	r0, r3
 8005d10:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:288
	if (chr < 0x80) {	/* ASCII */
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8005d12:	2000      	movs	r0, #0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:299
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 8005d14:	4770      	bx	lr
 8005d16:	bf00      	nop
 8005d18:	08006d4c 	.word	0x08006d4c

08005d1c <ff_wtoupper>:
ff_wtoupper():
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:333
									0xFF21,0xFF22,0xFF23,0xFF24,0xFF25,0xFF26,0xFF27,0xFF28,0xFF29,0xFF2A,0xFF2B,0xFF2C,0xFF2D,0xFF2E,0xFF2F,0xFF30,0xFF31,0xFF32,0xFF33,0xFF34,0xFF35,0xFF36,0xFF37,0xFF38,0xFF39,0xFF3A
	};
	UINT i, n, hi, li;


	if (chr < 0x80) {	/* ASCII characters (acceleration) */
 8005d1c:	287f      	cmp	r0, #127	; 0x7f
 8005d1e:	d807      	bhi.n	8005d30 <ff_wtoupper+0x14>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:334
		if (chr >= 0x61 && chr <= 0x7A) chr -= 0x20;
 8005d20:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 8005d24:	b29b      	uxth	r3, r3
 8005d26:	2b19      	cmp	r3, #25
 8005d28:	d81a      	bhi.n	8005d60 <ff_wtoupper+0x44>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:334 (discriminator 1)
 8005d2a:	3820      	subs	r0, #32
 8005d2c:	b280      	uxth	r0, r0
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:347 (discriminator 1)
		} while (--n);
		if (n) chr = upper[i];
	}

	return chr;
}
 8005d2e:	4770      	bx	lr
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:307


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted */
)
{
 8005d30:	b430      	push	{r4, r5}
 8005d32:	2400      	movs	r4, #0
 8005d34:	f44f 75f7 	mov.w	r5, #494	; 0x1ee
 8005d38:	220c      	movs	r2, #12
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:339
		if (chr >= 0x61 && chr <= 0x7A) chr -= 0x20;

	} else {			/* Non ASCII characters (table search) */
		n = 12; li = 0; hi = sizeof lower / sizeof lower[0];
		do {
			i = li + (hi - li) / 2;
 8005d3a:	1b2b      	subs	r3, r5, r4
 8005d3c:	eb04 0353 	add.w	r3, r4, r3, lsr #1
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:340
			if (chr == lower[i]) break;
 8005d40:	4908      	ldr	r1, [pc, #32]	; (8005d64 <ff_wtoupper+0x48>)
 8005d42:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
 8005d46:	4288      	cmp	r0, r1
 8005d48:	d005      	beq.n	8005d56 <ff_wtoupper+0x3a>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:341
			if (chr > lower[i]) li = i; else hi = i;
 8005d4a:	d901      	bls.n	8005d50 <ff_wtoupper+0x34>
 8005d4c:	461c      	mov	r4, r3
 8005d4e:	e000      	b.n	8005d52 <ff_wtoupper+0x36>
 8005d50:	461d      	mov	r5, r3
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:342
		} while (--n);
 8005d52:	3a01      	subs	r2, #1
 8005d54:	d1f1      	bne.n	8005d3a <ff_wtoupper+0x1e>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:343
		if (n) chr = upper[i];
 8005d56:	b112      	cbz	r2, 8005d5e <ff_wtoupper+0x42>
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:343 (discriminator 1)
 8005d58:	4a03      	ldr	r2, [pc, #12]	; (8005d68 <ff_wtoupper+0x4c>)
 8005d5a:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
C:\STM32_Toolchain\Workspace\CANSPI_v4\Debug/../STMLIBRARIES/fatfs/option/ccsbcs.c:347
	}

	return chr;
}
 8005d5e:	bc30      	pop	{r4, r5}
 8005d60:	4770      	bx	lr
 8005d62:	bf00      	nop
 8005d64:	08006970 	.word	0x08006970
 8005d68:	08006e4c 	.word	0x08006e4c

08005d6c <__errno>:
__errno():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/errno/errno.c:14
 8005d6c:	4b01      	ldr	r3, [pc, #4]	; (8005d74 <__errno+0x8>)
 8005d6e:	6818      	ldr	r0, [r3, #0]
 8005d70:	4770      	bx	lr
 8005d72:	bf00      	nop
 8005d74:	2000013c 	.word	0x2000013c

08005d78 <malloc>:
malloc():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/malloc.c:215
 8005d78:	4b02      	ldr	r3, [pc, #8]	; (8005d84 <malloc+0xc>)
 8005d7a:	4601      	mov	r1, r0
 8005d7c:	6818      	ldr	r0, [r3, #0]
 8005d7e:	f000 b851 	b.w	8005e24 <_malloc_r>
 8005d82:	bf00      	nop
 8005d84:	2000013c 	.word	0x2000013c

08005d88 <free>:
free():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/malloc.c:222
 8005d88:	4b02      	ldr	r3, [pc, #8]	; (8005d94 <free+0xc>)
 8005d8a:	4601      	mov	r1, r0
 8005d8c:	6818      	ldr	r0, [r3, #0]
 8005d8e:	f000 b803 	b.w	8005d98 <_free_r>
 8005d92:	bf00      	nop
 8005d94:	2000013c 	.word	0x2000013c

08005d98 <_free_r>:
_free_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:337
 8005d98:	b530      	push	{r4, r5, lr}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:341
 8005d9a:	2900      	cmp	r1, #0
 8005d9c:	d03e      	beq.n	8005e1c <_free_r+0x84>
get_chunk_from_ptr():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:191
 8005d9e:	f851 2c04 	ldr.w	r2, [r1, #-4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:189
 8005da2:	1f0b      	subs	r3, r1, #4
_free_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:346
 8005da4:	491e      	ldr	r1, [pc, #120]	; (8005e20 <_free_r+0x88>)
get_chunk_from_ptr():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:191
 8005da6:	2a00      	cmp	r2, #0
 8005da8:	bfb8      	it	lt
 8005daa:	189b      	addlt	r3, r3, r2
_free_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:346
 8005dac:	680a      	ldr	r2, [r1, #0]
 8005dae:	460c      	mov	r4, r1
 8005db0:	b912      	cbnz	r2, 8005db8 <_free_r+0x20>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:349
 8005db2:	605a      	str	r2, [r3, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:350
 8005db4:	600b      	str	r3, [r1, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:352
 8005db6:	bd30      	pop	{r4, r5, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:355
 8005db8:	429a      	cmp	r2, r3
 8005dba:	d90e      	bls.n	8005dda <_free_r+0x42>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:357
 8005dbc:	6819      	ldr	r1, [r3, #0]
 8005dbe:	1858      	adds	r0, r3, r1
 8005dc0:	4282      	cmp	r2, r0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:361
 8005dc2:	bf04      	itt	eq
 8005dc4:	6810      	ldreq	r0, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:362
 8005dc6:	6852      	ldreq	r2, [r2, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:367
 8005dc8:	605a      	str	r2, [r3, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:361
 8005dca:	bf04      	itt	eq
 8005dcc:	1809      	addeq	r1, r1, r0
 8005dce:	6019      	streq	r1, [r3, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:369
 8005dd0:	6023      	str	r3, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:371
 8005dd2:	bd30      	pop	{r4, r5, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:380 (discriminator 1)
 8005dd4:	4299      	cmp	r1, r3
 8005dd6:	d803      	bhi.n	8005de0 <_free_r+0x48>
 8005dd8:	460a      	mov	r2, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:379 (discriminator 2)
 8005dda:	6851      	ldr	r1, [r2, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:380 (discriminator 2)
 8005ddc:	2900      	cmp	r1, #0
 8005dde:	d1f9      	bne.n	8005dd4 <_free_r+0x3c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:385
 8005de0:	6814      	ldr	r4, [r2, #0]
 8005de2:	1915      	adds	r5, r2, r4
 8005de4:	429d      	cmp	r5, r3
 8005de6:	d10a      	bne.n	8005dfe <_free_r+0x66>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:389
 8005de8:	681b      	ldr	r3, [r3, #0]
 8005dea:	4423      	add	r3, r4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:392
 8005dec:	18d0      	adds	r0, r2, r3
 8005dee:	4281      	cmp	r1, r0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:389
 8005df0:	6013      	str	r3, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:392
 8005df2:	d113      	bne.n	8005e1c <_free_r+0x84>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:394
 8005df4:	6808      	ldr	r0, [r1, #0]
 8005df6:	4403      	add	r3, r0
 8005df8:	6013      	str	r3, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:395
 8005dfa:	684b      	ldr	r3, [r1, #4]
 8005dfc:	e00d      	b.n	8005e1a <_free_r+0x82>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:399
 8005dfe:	d902      	bls.n	8005e06 <_free_r+0x6e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:402
 8005e00:	230c      	movs	r3, #12
 8005e02:	6003      	str	r3, [r0, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:404
 8005e04:	bd30      	pop	{r4, r5, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:407
 8005e06:	6818      	ldr	r0, [r3, #0]
 8005e08:	181c      	adds	r4, r3, r0
 8005e0a:	42a1      	cmp	r1, r4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:411
 8005e0c:	bf04      	itt	eq
 8005e0e:	680c      	ldreq	r4, [r1, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:412
 8005e10:	6849      	ldreq	r1, [r1, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:419
 8005e12:	6059      	str	r1, [r3, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:411
 8005e14:	bf04      	itt	eq
 8005e16:	1900      	addeq	r0, r0, r4
 8005e18:	6018      	streq	r0, [r3, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:420
 8005e1a:	6053      	str	r3, [r2, #4]
 8005e1c:	bd30      	pop	{r4, r5, pc}
 8005e1e:	bf00      	nop
 8005e20:	20001b18 	.word	0x20001b18

08005e24 <_malloc_r>:
_malloc_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:238
 8005e24:	b570      	push	{r4, r5, r6, lr}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:245
 8005e26:	1ccd      	adds	r5, r1, #3
 8005e28:	f025 0503 	bic.w	r5, r5, #3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:247
 8005e2c:	3508      	adds	r5, #8
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:248
 8005e2e:	2d0c      	cmp	r5, #12
 8005e30:	bf38      	it	cc
 8005e32:	250c      	movcc	r5, #12
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:250
 8005e34:	2d00      	cmp	r5, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:238
 8005e36:	4606      	mov	r6, r0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:250
 8005e38:	da03      	bge.n	8005e42 <_malloc_r+0x1e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:252
 8005e3a:	230c      	movs	r3, #12
 8005e3c:	6033      	str	r3, [r6, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:253
 8005e3e:	2000      	movs	r0, #0
 8005e40:	bd70      	pop	{r4, r5, r6, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:250 (discriminator 1)
 8005e42:	42a9      	cmp	r1, r5
 8005e44:	d8f9      	bhi.n	8005e3a <_malloc_r+0x16>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:258
 8005e46:	4b1f      	ldr	r3, [pc, #124]	; (8005ec4 <_malloc_r+0xa0>)
 8005e48:	681c      	ldr	r4, [r3, #0]
 8005e4a:	461a      	mov	r2, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:259
 8005e4c:	4621      	mov	r1, r4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:261
 8005e4e:	b1a1      	cbz	r1, 8005e7a <_malloc_r+0x56>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:263
 8005e50:	680b      	ldr	r3, [r1, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:264
 8005e52:	1b5b      	subs	r3, r3, r5
 8005e54:	d40e      	bmi.n	8005e74 <_malloc_r+0x50>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:266
 8005e56:	2b0b      	cmp	r3, #11
 8005e58:	d903      	bls.n	8005e62 <_malloc_r+0x3e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:270
 8005e5a:	600b      	str	r3, [r1, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:271
 8005e5c:	18cc      	adds	r4, r1, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:272
 8005e5e:	50cd      	str	r5, [r1, r3]
 8005e60:	e01e      	b.n	8005ea0 <_malloc_r+0x7c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:276
 8005e62:	428c      	cmp	r4, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:280
 8005e64:	bf0d      	iteet	eq
 8005e66:	6863      	ldreq	r3, [r4, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:285
 8005e68:	684b      	ldrne	r3, [r1, #4]
 8005e6a:	6063      	strne	r3, [r4, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:280
 8005e6c:	6013      	streq	r3, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:285
 8005e6e:	bf18      	it	ne
 8005e70:	460c      	movne	r4, r1
 8005e72:	e015      	b.n	8005ea0 <_malloc_r+0x7c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:290
 8005e74:	460c      	mov	r4, r1
 8005e76:	6849      	ldr	r1, [r1, #4]
 8005e78:	e7e9      	b.n	8005e4e <_malloc_r+0x2a>
sbrk_aligned():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:212
 8005e7a:	4c13      	ldr	r4, [pc, #76]	; (8005ec8 <_malloc_r+0xa4>)
 8005e7c:	6823      	ldr	r3, [r4, #0]
 8005e7e:	b91b      	cbnz	r3, 8005e88 <_malloc_r+0x64>
 8005e80:	4630      	mov	r0, r6
 8005e82:	f000 f823 	bl	8005ecc <_sbrk_r>
 8005e86:	6020      	str	r0, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:214
 8005e88:	4629      	mov	r1, r5
 8005e8a:	4630      	mov	r0, r6
 8005e8c:	f000 f81e 	bl	8005ecc <_sbrk_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:217
 8005e90:	1c43      	adds	r3, r0, #1
 8005e92:	d0d2      	beq.n	8005e3a <_malloc_r+0x16>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:220
 8005e94:	1cc4      	adds	r4, r0, #3
 8005e96:	f024 0403 	bic.w	r4, r4, #3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:221
 8005e9a:	42a0      	cmp	r0, r4
 8005e9c:	d10a      	bne.n	8005eb4 <_malloc_r+0x90>
_malloc_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:305
 8005e9e:	6025      	str	r5, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:311
 8005ea0:	f104 000b 	add.w	r0, r4, #11
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:309
 8005ea4:	1d23      	adds	r3, r4, #4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:311
 8005ea6:	f020 0007 	bic.w	r0, r0, #7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:314
 8005eaa:	1ac3      	subs	r3, r0, r3
 8005eac:	d009      	beq.n	8005ec2 <_malloc_r+0x9e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:316
 8005eae:	425a      	negs	r2, r3
 8005eb0:	50e2      	str	r2, [r4, r3]
 8005eb2:	bd70      	pop	{r4, r5, r6, pc}
sbrk_aligned():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:225
 8005eb4:	1a21      	subs	r1, r4, r0
 8005eb6:	4630      	mov	r0, r6
 8005eb8:	f000 f808 	bl	8005ecc <_sbrk_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:226
 8005ebc:	3001      	adds	r0, #1
 8005ebe:	d1ee      	bne.n	8005e9e <_malloc_r+0x7a>
 8005ec0:	e7bb      	b.n	8005e3a <_malloc_r+0x16>
_malloc_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:321
 8005ec2:	bd70      	pop	{r4, r5, r6, pc}
 8005ec4:	20001b18 	.word	0x20001b18
 8005ec8:	20001b14 	.word	0x20001b14

08005ecc <_sbrk_r>:
_sbrk_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:53
 8005ecc:	b538      	push	{r3, r4, r5, lr}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:57
 8005ece:	4c06      	ldr	r4, [pc, #24]	; (8005ee8 <_sbrk_r+0x1c>)
 8005ed0:	2300      	movs	r3, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:53
 8005ed2:	4605      	mov	r5, r0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:58
 8005ed4:	4608      	mov	r0, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:57
 8005ed6:	6023      	str	r3, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:58
 8005ed8:	f7fc f920 	bl	800211c <_sbrk>
 8005edc:	1c43      	adds	r3, r0, #1
 8005ede:	d102      	bne.n	8005ee6 <_sbrk_r+0x1a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:58 (discriminator 1)
 8005ee0:	6823      	ldr	r3, [r4, #0]
 8005ee2:	b103      	cbz	r3, 8005ee6 <_sbrk_r+0x1a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:59
 8005ee4:	602b      	str	r3, [r5, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/reent/sbrkr.c:61
 8005ee6:	bd38      	pop	{r3, r4, r5, pc}
 8005ee8:	20001b1c 	.word	0x20001b1c

08005eec <siprintf>:
sprintf():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:633
 8005eec:	b40e      	push	{r1, r2, r3}
 8005eee:	b500      	push	{lr}
 8005ef0:	b09c      	sub	sp, #112	; 0x70
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:638
 8005ef2:	f44f 7102 	mov.w	r1, #520	; 0x208
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:633
 8005ef6:	ab1d      	add	r3, sp, #116	; 0x74
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:638
 8005ef8:	f8ad 1014 	strh.w	r1, [sp, #20]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:639
 8005efc:	9002      	str	r0, [sp, #8]
 8005efe:	9006      	str	r0, [sp, #24]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:640
 8005f00:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:647
 8005f04:	480a      	ldr	r0, [pc, #40]	; (8005f30 <siprintf+0x44>)
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:640
 8005f06:	9104      	str	r1, [sp, #16]
 8005f08:	9107      	str	r1, [sp, #28]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:641
 8005f0a:	f64f 71ff 	movw	r1, #65535	; 0xffff
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:633
 8005f0e:	f853 2b04 	ldr.w	r2, [r3], #4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:641
 8005f12:	f8ad 1016 	strh.w	r1, [sp, #22]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:647
 8005f16:	6800      	ldr	r0, [r0, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:643
 8005f18:	9301      	str	r3, [sp, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:647
 8005f1a:	a902      	add	r1, sp, #8
 8005f1c:	f000 f864 	bl	8005fe8 <_svfiprintf_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:649
 8005f20:	9b02      	ldr	r3, [sp, #8]
 8005f22:	2200      	movs	r2, #0
 8005f24:	701a      	strb	r2, [r3, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/sprintf.c:651
 8005f26:	b01c      	add	sp, #112	; 0x70
 8005f28:	f85d eb04 	ldr.w	lr, [sp], #4
 8005f2c:	b003      	add	sp, #12
 8005f2e:	4770      	bx	lr
 8005f30:	2000013c 	.word	0x2000013c

08005f34 <__ssputs_r>:
__ssputs_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:180
 8005f34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:183
 8005f38:	688e      	ldr	r6, [r1, #8]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:184
 8005f3a:	429e      	cmp	r6, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:180
 8005f3c:	4682      	mov	sl, r0
 8005f3e:	460c      	mov	r4, r1
 8005f40:	4691      	mov	r9, r2
 8005f42:	4698      	mov	r8, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:184
 8005f44:	d83e      	bhi.n	8005fc4 <__ssputs_r+0x90>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:184 (discriminator 1)
 8005f46:	898a      	ldrh	r2, [r1, #12]
 8005f48:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8005f4c:	d03a      	beq.n	8005fc4 <__ssputs_r+0x90>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:188
 8005f4e:	6825      	ldr	r5, [r4, #0]
 8005f50:	6909      	ldr	r1, [r1, #16]
 8005f52:	1a6f      	subs	r7, r5, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:196
 8005f54:	6965      	ldr	r5, [r4, #20]
 8005f56:	2302      	movs	r3, #2
 8005f58:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8005f5c:	fb95 f5f3 	sdiv	r5, r5, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:197
 8005f60:	1c7b      	adds	r3, r7, #1
 8005f62:	4443      	add	r3, r8
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:198
 8005f64:	429d      	cmp	r5, r3
 8005f66:	bf38      	it	cc
 8005f68:	461d      	movcc	r5, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:199
 8005f6a:	0553      	lsls	r3, r2, #21
 8005f6c:	d50f      	bpl.n	8005f8e <__ssputs_r+0x5a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:202
 8005f6e:	4629      	mov	r1, r5
 8005f70:	f7ff ff58 	bl	8005e24 <_malloc_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:203
 8005f74:	4606      	mov	r6, r0
 8005f76:	b198      	cbz	r0, 8005fa0 <__ssputs_r+0x6c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:208
 8005f78:	463a      	mov	r2, r7
 8005f7a:	6921      	ldr	r1, [r4, #16]
 8005f7c:	f000 fb18 	bl	80065b0 <memcpy>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:209
 8005f80:	89a3      	ldrh	r3, [r4, #12]
 8005f82:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8005f86:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005f8a:	81a3      	strh	r3, [r4, #12]
 8005f8c:	e013      	b.n	8005fb6 <__ssputs_r+0x82>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:213
 8005f8e:	462a      	mov	r2, r5
 8005f90:	f000 fb34 	bl	80065fc <_realloc_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:214
 8005f94:	4606      	mov	r6, r0
 8005f96:	b970      	cbnz	r0, 8005fb6 <__ssputs_r+0x82>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:217
 8005f98:	6921      	ldr	r1, [r4, #16]
 8005f9a:	4650      	mov	r0, sl
 8005f9c:	f7ff fefc 	bl	8005d98 <_free_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:219
 8005fa0:	230c      	movs	r3, #12
 8005fa2:	f8ca 3000 	str.w	r3, [sl]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:238
 8005fa6:	89a3      	ldrh	r3, [r4, #12]
 8005fa8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005fac:	81a3      	strh	r3, [r4, #12]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:239
 8005fae:	f04f 30ff 	mov.w	r0, #4294967295
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:240
 8005fb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:223
 8005fb6:	6126      	str	r6, [r4, #16]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:225
 8005fb8:	6165      	str	r5, [r4, #20]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:224
 8005fba:	443e      	add	r6, r7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:227
 8005fbc:	1bed      	subs	r5, r5, r7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:224
 8005fbe:	6026      	str	r6, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:227
 8005fc0:	60a5      	str	r5, [r4, #8]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:226
 8005fc2:	4646      	mov	r6, r8
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:230
 8005fc4:	4546      	cmp	r6, r8
 8005fc6:	bf28      	it	cs
 8005fc8:	4646      	movcs	r6, r8
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:232
 8005fca:	4632      	mov	r2, r6
 8005fcc:	4649      	mov	r1, r9
 8005fce:	6820      	ldr	r0, [r4, #0]
 8005fd0:	f000 faf9 	bl	80065c6 <memmove>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:233
 8005fd4:	68a3      	ldr	r3, [r4, #8]
 8005fd6:	1b9b      	subs	r3, r3, r6
 8005fd8:	60a3      	str	r3, [r4, #8]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:234
 8005fda:	6823      	ldr	r3, [r4, #0]
 8005fdc:	441e      	add	r6, r3
 8005fde:	6026      	str	r6, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:235
 8005fe0:	2000      	movs	r0, #0
 8005fe2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08005fe8 <_svfiprintf_r>:
_svfprintf_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:479
 8005fe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005fec:	b09d      	sub	sp, #116	; 0x74
 8005fee:	4680      	mov	r8, r0
 8005ff0:	9303      	str	r3, [sp, #12]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:505
 8005ff2:	898b      	ldrh	r3, [r1, #12]
 8005ff4:	061c      	lsls	r4, r3, #24
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:479
 8005ff6:	460d      	mov	r5, r1
 8005ff8:	4616      	mov	r6, r2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:505
 8005ffa:	d50d      	bpl.n	8006018 <_svfiprintf_r+0x30>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:505 (discriminator 1)
 8005ffc:	690b      	ldr	r3, [r1, #16]
 8005ffe:	b95b      	cbnz	r3, 8006018 <_svfiprintf_r+0x30>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:507
 8006000:	2140      	movs	r1, #64	; 0x40
 8006002:	f7ff ff0f 	bl	8005e24 <_malloc_r>
 8006006:	6028      	str	r0, [r5, #0]
 8006008:	6128      	str	r0, [r5, #16]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:508
 800600a:	b918      	cbnz	r0, 8006014 <_svfiprintf_r+0x2c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:510
 800600c:	230c      	movs	r3, #12
 800600e:	f8c8 3000 	str.w	r3, [r8]
 8006012:	e0cd      	b.n	80061b0 <_svfiprintf_r+0x1c8>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:513
 8006014:	2340      	movs	r3, #64	; 0x40
 8006016:	616b      	str	r3, [r5, #20]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:518
 8006018:	2300      	movs	r3, #0
 800601a:	9309      	str	r3, [sp, #36]	; 0x24
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:519
 800601c:	2320      	movs	r3, #32
 800601e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:612
 8006022:	f8df b19c 	ldr.w	fp, [pc, #412]	; 80061c0 <_svfiprintf_r+0x1d8>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:520
 8006026:	2330      	movs	r3, #48	; 0x30
 8006028:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800602c:	4637      	mov	r7, r6
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:526
 800602e:	463c      	mov	r4, r7
 8006030:	f814 3b01 	ldrb.w	r3, [r4], #1
 8006034:	b91b      	cbnz	r3, 800603e <_svfiprintf_r+0x56>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:529
 8006036:	ebb7 0906 	subs.w	r9, r7, r6
 800603a:	d010      	beq.n	800605e <_svfiprintf_r+0x76>
 800603c:	e003      	b.n	8006046 <_svfiprintf_r+0x5e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:526 (discriminator 1)
 800603e:	2b25      	cmp	r3, #37	; 0x25
 8006040:	d0f9      	beq.n	8006036 <_svfiprintf_r+0x4e>
 8006042:	4627      	mov	r7, r4
 8006044:	e7f3      	b.n	800602e <_svfiprintf_r+0x46>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:531
 8006046:	464b      	mov	r3, r9
 8006048:	4632      	mov	r2, r6
 800604a:	4629      	mov	r1, r5
 800604c:	4640      	mov	r0, r8
 800604e:	f7ff ff71 	bl	8005f34 <__ssputs_r>
 8006052:	3001      	adds	r0, #1
 8006054:	f000 80a7 	beq.w	80061a6 <_svfiprintf_r+0x1be>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:532
 8006058:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800605a:	444b      	add	r3, r9
 800605c:	9309      	str	r3, [sp, #36]	; 0x24
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:534
 800605e:	783b      	ldrb	r3, [r7, #0]
 8006060:	2b00      	cmp	r3, #0
 8006062:	f000 80a0 	beq.w	80061a6 <_svfiprintf_r+0x1be>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:539
 8006066:	2300      	movs	r3, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:541
 8006068:	f04f 32ff 	mov.w	r2, #4294967295
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:539
 800606c:	9304      	str	r3, [sp, #16]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:540
 800606e:	9307      	str	r3, [sp, #28]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:541
 8006070:	9205      	str	r2, [sp, #20]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:542
 8006072:	9306      	str	r3, [sp, #24]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:543
 8006074:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:545
 8006078:	931a      	str	r3, [sp, #104]	; 0x68
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:555
 800607a:	2601      	movs	r6, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:554 (discriminator 1)
 800607c:	2205      	movs	r2, #5
 800607e:	7821      	ldrb	r1, [r4, #0]
 8006080:	484e      	ldr	r0, [pc, #312]	; (80061bc <_svfiprintf_r+0x1d4>)
 8006082:	f000 fa45 	bl	8006510 <memchr>
 8006086:	1c67      	adds	r7, r4, #1
 8006088:	9b04      	ldr	r3, [sp, #16]
 800608a:	b138      	cbz	r0, 800609c <_svfiprintf_r+0xb4>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:555 (discriminator 2)
 800608c:	4a4b      	ldr	r2, [pc, #300]	; (80061bc <_svfiprintf_r+0x1d4>)
 800608e:	1a80      	subs	r0, r0, r2
 8006090:	fa06 f000 	lsl.w	r0, r6, r0
 8006094:	4318      	orrs	r0, r3
 8006096:	9004      	str	r0, [sp, #16]
 8006098:	463c      	mov	r4, r7
 800609a:	e7ef      	b.n	800607c <_svfiprintf_r+0x94>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:557
 800609c:	06d9      	lsls	r1, r3, #27
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:558
 800609e:	bf44      	itt	mi
 80060a0:	2220      	movmi	r2, #32
 80060a2:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:565
 80060a6:	071a      	lsls	r2, r3, #28
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:566
 80060a8:	bf44      	itt	mi
 80060aa:	222b      	movmi	r2, #43	; 0x2b
 80060ac:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:569
 80060b0:	7822      	ldrb	r2, [r4, #0]
 80060b2:	2a2a      	cmp	r2, #42	; 0x2a
 80060b4:	d003      	beq.n	80060be <_svfiprintf_r+0xd6>
 80060b6:	9a07      	ldr	r2, [sp, #28]
 80060b8:	2100      	movs	r1, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:588
 80060ba:	200a      	movs	r0, #10
 80060bc:	e00b      	b.n	80060d6 <_svfiprintf_r+0xee>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:577
 80060be:	9a03      	ldr	r2, [sp, #12]
 80060c0:	1d11      	adds	r1, r2, #4
 80060c2:	6812      	ldr	r2, [r2, #0]
 80060c4:	9103      	str	r1, [sp, #12]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:578
 80060c6:	2a00      	cmp	r2, #0
 80060c8:	da10      	bge.n	80060ec <_svfiprintf_r+0x104>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:580
 80060ca:	4252      	negs	r2, r2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:581
 80060cc:	f043 0002 	orr.w	r0, r3, #2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:580
 80060d0:	9207      	str	r2, [sp, #28]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:581
 80060d2:	9004      	str	r0, [sp, #16]
 80060d4:	e00b      	b.n	80060ee <_svfiprintf_r+0x106>
 80060d6:	4627      	mov	r7, r4
 80060d8:	3401      	adds	r4, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:587 (discriminator 1)
 80060da:	783b      	ldrb	r3, [r7, #0]
 80060dc:	3b30      	subs	r3, #48	; 0x30
 80060de:	2b09      	cmp	r3, #9
 80060e0:	d803      	bhi.n	80060ea <_svfiprintf_r+0x102>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:588 (discriminator 2)
 80060e2:	fb00 3202 	mla	r2, r0, r2, r3
 80060e6:	2101      	movs	r1, #1
 80060e8:	e7f5      	b.n	80060d6 <_svfiprintf_r+0xee>
 80060ea:	b101      	cbz	r1, 80060ee <_svfiprintf_r+0x106>
 80060ec:	9207      	str	r2, [sp, #28]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:592
 80060ee:	783b      	ldrb	r3, [r7, #0]
 80060f0:	2b2e      	cmp	r3, #46	; 0x2e
 80060f2:	d11e      	bne.n	8006132 <_svfiprintf_r+0x14a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:595
 80060f4:	787b      	ldrb	r3, [r7, #1]
 80060f6:	2b2a      	cmp	r3, #42	; 0x2a
 80060f8:	d10a      	bne.n	8006110 <_svfiprintf_r+0x128>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:598
 80060fa:	9b03      	ldr	r3, [sp, #12]
 80060fc:	1d1a      	adds	r2, r3, #4
 80060fe:	681b      	ldr	r3, [r3, #0]
 8006100:	9203      	str	r2, [sp, #12]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:599
 8006102:	2b00      	cmp	r3, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:600
 8006104:	bfb8      	it	lt
 8006106:	f04f 33ff 	movlt.w	r3, #4294967295
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:597
 800610a:	3702      	adds	r7, #2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:600
 800610c:	9305      	str	r3, [sp, #20]
 800610e:	e010      	b.n	8006132 <_svfiprintf_r+0x14a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:604
 8006110:	2300      	movs	r3, #0
 8006112:	9305      	str	r3, [sp, #20]
 8006114:	1c78      	adds	r0, r7, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:605
 8006116:	4619      	mov	r1, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:606
 8006118:	240a      	movs	r4, #10
 800611a:	4607      	mov	r7, r0
 800611c:	3001      	adds	r0, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:605 (discriminator 1)
 800611e:	783a      	ldrb	r2, [r7, #0]
 8006120:	3a30      	subs	r2, #48	; 0x30
 8006122:	2a09      	cmp	r2, #9
 8006124:	d803      	bhi.n	800612e <_svfiprintf_r+0x146>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:606 (discriminator 2)
 8006126:	fb04 2101 	mla	r1, r4, r1, r2
 800612a:	2301      	movs	r3, #1
 800612c:	e7f5      	b.n	800611a <_svfiprintf_r+0x132>
 800612e:	b103      	cbz	r3, 8006132 <_svfiprintf_r+0x14a>
 8006130:	9105      	str	r1, [sp, #20]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:612
 8006132:	2203      	movs	r2, #3
 8006134:	7839      	ldrb	r1, [r7, #0]
 8006136:	4822      	ldr	r0, [pc, #136]	; (80061c0 <_svfiprintf_r+0x1d8>)
 8006138:	f000 f9ea 	bl	8006510 <memchr>
 800613c:	b140      	cbz	r0, 8006150 <_svfiprintf_r+0x168>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:614
 800613e:	2340      	movs	r3, #64	; 0x40
 8006140:	ebcb 0000 	rsb	r0, fp, r0
 8006144:	fa03 f000 	lsl.w	r0, r3, r0
 8006148:	9b04      	ldr	r3, [sp, #16]
 800614a:	4318      	orrs	r0, r3
 800614c:	9004      	str	r0, [sp, #16]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:615
 800614e:	3701      	adds	r7, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:619
 8006150:	7839      	ldrb	r1, [r7, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:620
 8006152:	481c      	ldr	r0, [pc, #112]	; (80061c4 <_svfiprintf_r+0x1dc>)
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:619
 8006154:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:620
 8006158:	2206      	movs	r2, #6
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:619
 800615a:	1c7e      	adds	r6, r7, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:620
 800615c:	f000 f9d8 	bl	8006510 <memchr>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:623
 8006160:	b188      	cbz	r0, 8006186 <_svfiprintf_r+0x19e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:627
 8006162:	4b19      	ldr	r3, [pc, #100]	; (80061c8 <_svfiprintf_r+0x1e0>)
 8006164:	b933      	cbnz	r3, 8006174 <_svfiprintf_r+0x18c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:630
 8006166:	9b03      	ldr	r3, [sp, #12]
 8006168:	3307      	adds	r3, #7
 800616a:	f023 0307 	bic.w	r3, r3, #7
 800616e:	3308      	adds	r3, #8
 8006170:	9303      	str	r3, [sp, #12]
 8006172:	e014      	b.n	800619e <_svfiprintf_r+0x1b6>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:636
 8006174:	ab03      	add	r3, sp, #12
 8006176:	9300      	str	r3, [sp, #0]
 8006178:	462a      	mov	r2, r5
 800617a:	4b14      	ldr	r3, [pc, #80]	; (80061cc <_svfiprintf_r+0x1e4>)
 800617c:	a904      	add	r1, sp, #16
 800617e:	4640      	mov	r0, r8
 8006180:	f3af 8000 	nop.w
 8006184:	e007      	b.n	8006196 <_svfiprintf_r+0x1ae>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:641
 8006186:	ab03      	add	r3, sp, #12
 8006188:	9300      	str	r3, [sp, #0]
 800618a:	462a      	mov	r2, r5
 800618c:	4b0f      	ldr	r3, [pc, #60]	; (80061cc <_svfiprintf_r+0x1e4>)
 800618e:	a904      	add	r1, sp, #16
 8006190:	4640      	mov	r0, r8
 8006192:	f000 f893 	bl	80062bc <_printf_i>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:643
 8006196:	f1b0 3fff 	cmp.w	r0, #4294967295
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:641
 800619a:	4682      	mov	sl, r0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:643
 800619c:	d003      	beq.n	80061a6 <_svfiprintf_r+0x1be>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:646
 800619e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80061a0:	4453      	add	r3, sl
 80061a2:	9309      	str	r3, [sp, #36]	; 0x24
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:647
 80061a4:	e742      	b.n	800602c <_svfiprintf_r+0x44>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:654
 80061a6:	89ab      	ldrh	r3, [r5, #12]
 80061a8:	065b      	lsls	r3, r3, #25
 80061aa:	d401      	bmi.n	80061b0 <_svfiprintf_r+0x1c8>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:654 (discriminator 1)
 80061ac:	9809      	ldr	r0, [sp, #36]	; 0x24
 80061ae:	e001      	b.n	80061b4 <_svfiprintf_r+0x1cc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:654
 80061b0:	f04f 30ff 	mov.w	r0, #4294967295
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf.c:655
 80061b4:	b01d      	add	sp, #116	; 0x74
 80061b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80061ba:	bf00      	nop
 80061bc:	0800722a 	.word	0x0800722a
 80061c0:	08007230 	.word	0x08007230
 80061c4:	08007234 	.word	0x08007234
 80061c8:	00000000 	.word	0x00000000
 80061cc:	08005f35 	.word	0x08005f35

080061d0 <_printf_common>:
_printf_common():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:55
 80061d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80061d4:	4691      	mov	r9, r2
 80061d6:	461f      	mov	r7, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:72
 80061d8:	690a      	ldr	r2, [r1, #16]
 80061da:	688b      	ldr	r3, [r1, #8]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:55
 80061dc:	f8dd 8020 	ldr.w	r8, [sp, #32]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:72
 80061e0:	4293      	cmp	r3, r2
 80061e2:	bfb8      	it	lt
 80061e4:	4613      	movlt	r3, r2
 80061e6:	f8c9 3000 	str.w	r3, [r9]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:73
 80061ea:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:55
 80061ee:	4606      	mov	r6, r0
 80061f0:	460c      	mov	r4, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:73
 80061f2:	b112      	cbz	r2, 80061fa <_printf_common+0x2a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:74
 80061f4:	3301      	adds	r3, #1
 80061f6:	f8c9 3000 	str.w	r3, [r9]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:76
 80061fa:	6823      	ldr	r3, [r4, #0]
 80061fc:	0699      	lsls	r1, r3, #26
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:77
 80061fe:	bf42      	ittt	mi
 8006200:	f8d9 3000 	ldrmi.w	r3, [r9]
 8006204:	3302      	addmi	r3, #2
 8006206:	f8c9 3000 	strmi.w	r3, [r9]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:80
 800620a:	6825      	ldr	r5, [r4, #0]
 800620c:	f015 0506 	ands.w	r5, r5, #6
 8006210:	d110      	bne.n	8006234 <_printf_common+0x64>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:81 (discriminator 3)
 8006212:	f104 0a19 	add.w	sl, r4, #25
 8006216:	e007      	b.n	8006228 <_printf_common+0x58>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:81 (discriminator 4)
 8006218:	2301      	movs	r3, #1
 800621a:	4652      	mov	r2, sl
 800621c:	4639      	mov	r1, r7
 800621e:	4630      	mov	r0, r6
 8006220:	47c0      	blx	r8
 8006222:	3001      	adds	r0, #1
 8006224:	d01a      	beq.n	800625c <_printf_common+0x8c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:81 (discriminator 2)
 8006226:	3501      	adds	r5, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:81 (discriminator 3)
 8006228:	68e3      	ldr	r3, [r4, #12]
 800622a:	f8d9 2000 	ldr.w	r2, [r9]
 800622e:	1a9b      	subs	r3, r3, r2
 8006230:	429d      	cmp	r5, r3
 8006232:	dbf1      	blt.n	8006218 <_printf_common+0x48>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:84
 8006234:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:88
 8006238:	6822      	ldr	r2, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:84
 800623a:	3300      	adds	r3, #0
 800623c:	bf18      	it	ne
 800623e:	2301      	movne	r3, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:88
 8006240:	0692      	lsls	r2, r2, #26
 8006242:	d50f      	bpl.n	8006264 <_printf_common+0x94>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:90
 8006244:	18e1      	adds	r1, r4, r3
 8006246:	1c5a      	adds	r2, r3, #1
 8006248:	2030      	movs	r0, #48	; 0x30
 800624a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:91
 800624e:	4422      	add	r2, r4
 8006250:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8006254:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8006258:	3302      	adds	r3, #2
 800625a:	e003      	b.n	8006264 <_printf_common+0x94>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:105
 800625c:	f04f 30ff 	mov.w	r0, #4294967295
 8006260:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:94
 8006264:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8006268:	4639      	mov	r1, r7
 800626a:	4630      	mov	r0, r6
 800626c:	47c0      	blx	r8
 800626e:	3001      	adds	r0, #1
 8006270:	d0f4      	beq.n	800625c <_printf_common+0x8c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:96
 8006272:	6822      	ldr	r2, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:95
 8006274:	f8d9 5000 	ldr.w	r5, [r9]
 8006278:	68e3      	ldr	r3, [r4, #12]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:96
 800627a:	f002 0206 	and.w	r2, r2, #6
 800627e:	2a04      	cmp	r2, #4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:95
 8006280:	bf08      	it	eq
 8006282:	1b5d      	subeq	r5, r3, r5
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:99
 8006284:	6922      	ldr	r2, [r4, #16]
 8006286:	68a3      	ldr	r3, [r4, #8]
 8006288:	bf0c      	ite	eq
 800628a:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:97
 800628e:	2500      	movne	r5, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:99
 8006290:	4293      	cmp	r3, r2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:100
 8006292:	bfc4      	itt	gt
 8006294:	1a9b      	subgt	r3, r3, r2
 8006296:	18ed      	addgt	r5, r5, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:102
 8006298:	f04f 0900 	mov.w	r9, #0
 800629c:	341a      	adds	r4, #26
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:102 (discriminator 3)
 800629e:	454d      	cmp	r5, r9
 80062a0:	d009      	beq.n	80062b6 <_printf_common+0xe6>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:102 (discriminator 4)
 80062a2:	2301      	movs	r3, #1
 80062a4:	4622      	mov	r2, r4
 80062a6:	4639      	mov	r1, r7
 80062a8:	4630      	mov	r0, r6
 80062aa:	47c0      	blx	r8
 80062ac:	3001      	adds	r0, #1
 80062ae:	d0d5      	beq.n	800625c <_printf_common+0x8c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:102 (discriminator 2)
 80062b0:	f109 0901 	add.w	r9, r9, #1
 80062b4:	e7f3      	b.n	800629e <_printf_common+0xce>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:103
 80062b6:	2000      	movs	r0, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:106
 80062b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080062bc <_printf_i>:
_printf_i():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:111
 80062bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80062c0:	4617      	mov	r7, r2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:121
 80062c2:	7e0a      	ldrb	r2, [r1, #24]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:111
 80062c4:	b085      	sub	sp, #20
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:121
 80062c6:	2a6e      	cmp	r2, #110	; 0x6e
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:111
 80062c8:	4698      	mov	r8, r3
 80062ca:	4606      	mov	r6, r0
 80062cc:	460c      	mov	r4, r1
 80062ce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:117
 80062d0:	f101 0e43 	add.w	lr, r1, #67	; 0x43
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:121
 80062d4:	f000 80ae 	beq.w	8006434 <_printf_i+0x178>
 80062d8:	d811      	bhi.n	80062fe <_printf_i+0x42>
 80062da:	2a63      	cmp	r2, #99	; 0x63
 80062dc:	d022      	beq.n	8006324 <_printf_i+0x68>
 80062de:	d809      	bhi.n	80062f4 <_printf_i+0x38>
 80062e0:	2a00      	cmp	r2, #0
 80062e2:	f000 80bb 	beq.w	800645c <_printf_i+0x1a0>
 80062e6:	2a58      	cmp	r2, #88	; 0x58
 80062e8:	f040 80ca 	bne.w	8006480 <_printf_i+0x1c4>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:143
 80062ec:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:118
 80062f0:	4983      	ldr	r1, [pc, #524]	; (8006500 <_printf_i+0x244>)
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:144
 80062f2:	e055      	b.n	80063a0 <_printf_i+0xe4>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:121
 80062f4:	2a64      	cmp	r2, #100	; 0x64
 80062f6:	d01e      	beq.n	8006336 <_printf_i+0x7a>
 80062f8:	2a69      	cmp	r2, #105	; 0x69
 80062fa:	d01c      	beq.n	8006336 <_printf_i+0x7a>
 80062fc:	e0c0      	b.n	8006480 <_printf_i+0x1c4>
 80062fe:	2a73      	cmp	r2, #115	; 0x73
 8006300:	f000 80b0 	beq.w	8006464 <_printf_i+0x1a8>
 8006304:	d809      	bhi.n	800631a <_printf_i+0x5e>
 8006306:	2a6f      	cmp	r2, #111	; 0x6f
 8006308:	d02e      	beq.n	8006368 <_printf_i+0xac>
 800630a:	2a70      	cmp	r2, #112	; 0x70
 800630c:	f040 80b8 	bne.w	8006480 <_printf_i+0x1c4>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:153
 8006310:	680a      	ldr	r2, [r1, #0]
 8006312:	f042 0220 	orr.w	r2, r2, #32
 8006316:	600a      	str	r2, [r1, #0]
 8006318:	e03e      	b.n	8006398 <_printf_i+0xdc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:121
 800631a:	2a75      	cmp	r2, #117	; 0x75
 800631c:	d024      	beq.n	8006368 <_printf_i+0xac>
 800631e:	2a78      	cmp	r2, #120	; 0x78
 8006320:	d03a      	beq.n	8006398 <_printf_i+0xdc>
 8006322:	e0ad      	b.n	8006480 <_printf_i+0x1c4>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:124
 8006324:	681a      	ldr	r2, [r3, #0]
 8006326:	f101 0542 	add.w	r5, r1, #66	; 0x42
 800632a:	1d11      	adds	r1, r2, #4
 800632c:	6019      	str	r1, [r3, #0]
 800632e:	6813      	ldr	r3, [r2, #0]
 8006330:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8006334:	e0a8      	b.n	8006488 <_printf_i+0x1cc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:129
 8006336:	6821      	ldr	r1, [r4, #0]
 8006338:	681a      	ldr	r2, [r3, #0]
 800633a:	f011 0f80 	tst.w	r1, #128	; 0x80
 800633e:	d002      	beq.n	8006346 <_printf_i+0x8a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:129 (discriminator 1)
 8006340:	1d11      	adds	r1, r2, #4
 8006342:	6019      	str	r1, [r3, #0]
 8006344:	e008      	b.n	8006358 <_printf_i+0x9c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:129 (discriminator 2)
 8006346:	f011 0f40 	tst.w	r1, #64	; 0x40
 800634a:	f102 0104 	add.w	r1, r2, #4
 800634e:	6019      	str	r1, [r3, #0]
 8006350:	d002      	beq.n	8006358 <_printf_i+0x9c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:129 (discriminator 4)
 8006352:	f9b2 3000 	ldrsh.w	r3, [r2]
 8006356:	e000      	b.n	800635a <_printf_i+0x9e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:129 (discriminator 5)
 8006358:	6813      	ldr	r3, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:130 (discriminator 8)
 800635a:	2b00      	cmp	r3, #0
 800635c:	da3c      	bge.n	80063d8 <_printf_i+0x11c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:133
 800635e:	222d      	movs	r2, #45	; 0x2d
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:132
 8006360:	425b      	negs	r3, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:133
 8006362:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8006366:	e037      	b.n	80063d8 <_printf_i+0x11c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:139
 8006368:	6821      	ldr	r1, [r4, #0]
 800636a:	681a      	ldr	r2, [r3, #0]
 800636c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006370:	d002      	beq.n	8006378 <_printf_i+0xbc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:139 (discriminator 1)
 8006372:	1d11      	adds	r1, r2, #4
 8006374:	6019      	str	r1, [r3, #0]
 8006376:	e007      	b.n	8006388 <_printf_i+0xcc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:139 (discriminator 2)
 8006378:	f011 0f40 	tst.w	r1, #64	; 0x40
 800637c:	f102 0104 	add.w	r1, r2, #4
 8006380:	6019      	str	r1, [r3, #0]
 8006382:	d001      	beq.n	8006388 <_printf_i+0xcc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:139 (discriminator 4)
 8006384:	8813      	ldrh	r3, [r2, #0]
 8006386:	e000      	b.n	800638a <_printf_i+0xce>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:139 (discriminator 5)
 8006388:	6813      	ldr	r3, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:140 (discriminator 8)
 800638a:	7e22      	ldrb	r2, [r4, #24]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:118 (discriminator 8)
 800638c:	495c      	ldr	r1, [pc, #368]	; (8006500 <_printf_i+0x244>)
 800638e:	2a6f      	cmp	r2, #111	; 0x6f
 8006390:	bf14      	ite	ne
 8006392:	220a      	movne	r2, #10
 8006394:	2208      	moveq	r2, #8
 8006396:	e01b      	b.n	80063d0 <_printf_i+0x114>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:158
 8006398:	2278      	movs	r2, #120	; 0x78
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:159
 800639a:	495a      	ldr	r1, [pc, #360]	; (8006504 <_printf_i+0x248>)
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:158
 800639c:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:161
 80063a0:	6822      	ldr	r2, [r4, #0]
 80063a2:	6818      	ldr	r0, [r3, #0]
 80063a4:	f012 0f80 	tst.w	r2, #128	; 0x80
 80063a8:	f100 0504 	add.w	r5, r0, #4
 80063ac:	601d      	str	r5, [r3, #0]
 80063ae:	d103      	bne.n	80063b8 <_printf_i+0xfc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:161 (discriminator 2)
 80063b0:	0655      	lsls	r5, r2, #25
 80063b2:	d501      	bpl.n	80063b8 <_printf_i+0xfc>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:161 (discriminator 4)
 80063b4:	8803      	ldrh	r3, [r0, #0]
 80063b6:	e000      	b.n	80063ba <_printf_i+0xfe>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:161 (discriminator 5)
 80063b8:	6803      	ldr	r3, [r0, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:163 (discriminator 8)
 80063ba:	07d0      	lsls	r0, r2, #31
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:164 (discriminator 8)
 80063bc:	bf44      	itt	mi
 80063be:	f042 0220 	orrmi.w	r2, r2, #32
 80063c2:	6022      	strmi	r2, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:167 (discriminator 8)
 80063c4:	b91b      	cbnz	r3, 80063ce <_printf_i+0x112>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:168
 80063c6:	6822      	ldr	r2, [r4, #0]
 80063c8:	f022 0220 	bic.w	r2, r2, #32
 80063cc:	6022      	str	r2, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:162
 80063ce:	2210      	movs	r2, #16
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:172
 80063d0:	2000      	movs	r0, #0
 80063d2:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 80063d6:	e001      	b.n	80063dc <_printf_i+0x120>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:118
 80063d8:	4949      	ldr	r1, [pc, #292]	; (8006500 <_printf_i+0x244>)
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:135
 80063da:	220a      	movs	r2, #10
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:179
 80063dc:	6865      	ldr	r5, [r4, #4]
 80063de:	60a5      	str	r5, [r4, #8]
 80063e0:	2d00      	cmp	r5, #0
 80063e2:	db08      	blt.n	80063f6 <_printf_i+0x13a>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:180
 80063e4:	6820      	ldr	r0, [r4, #0]
 80063e6:	f020 0004 	bic.w	r0, r0, #4
 80063ea:	6020      	str	r0, [r4, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:187
 80063ec:	b92b      	cbnz	r3, 80063fa <_printf_i+0x13e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:187 (discriminator 1)
 80063ee:	2d00      	cmp	r5, #0
 80063f0:	d17d      	bne.n	80064ee <_printf_i+0x232>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:117
 80063f2:	4675      	mov	r5, lr
 80063f4:	e00c      	b.n	8006410 <_printf_i+0x154>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:187
 80063f6:	2b00      	cmp	r3, #0
 80063f8:	d079      	beq.n	80064ee <_printf_i+0x232>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:135
 80063fa:	4675      	mov	r5, lr
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:191 (discriminator 1)
 80063fc:	fbb3 f0f2 	udiv	r0, r3, r2
 8006400:	fb02 3310 	mls	r3, r2, r0, r3
 8006404:	5ccb      	ldrb	r3, [r1, r3]
 8006406:	f805 3d01 	strb.w	r3, [r5, #-1]!
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:194 (discriminator 1)
 800640a:	4603      	mov	r3, r0
 800640c:	2800      	cmp	r0, #0
 800640e:	d1f5      	bne.n	80063fc <_printf_i+0x140>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:198
 8006410:	2a08      	cmp	r2, #8
 8006412:	d10b      	bne.n	800642c <_printf_i+0x170>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:198 (discriminator 1)
 8006414:	6823      	ldr	r3, [r4, #0]
 8006416:	07da      	lsls	r2, r3, #31
 8006418:	d508      	bpl.n	800642c <_printf_i+0x170>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:198 (discriminator 2)
 800641a:	6923      	ldr	r3, [r4, #16]
 800641c:	6862      	ldr	r2, [r4, #4]
 800641e:	429a      	cmp	r2, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:199 (discriminator 2)
 8006420:	bfde      	ittt	le
 8006422:	2330      	movle	r3, #48	; 0x30
 8006424:	f805 3c01 	strble.w	r3, [r5, #-1]
 8006428:	f105 35ff 	addle.w	r5, r5, #4294967295
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:201
 800642c:	ebc5 030e 	rsb	r3, r5, lr
 8006430:	6123      	str	r3, [r4, #16]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:202
 8006432:	e02e      	b.n	8006492 <_printf_i+0x1d6>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:204
 8006434:	6808      	ldr	r0, [r1, #0]
 8006436:	681a      	ldr	r2, [r3, #0]
 8006438:	6949      	ldr	r1, [r1, #20]
 800643a:	f010 0f80 	tst.w	r0, #128	; 0x80
 800643e:	d003      	beq.n	8006448 <_printf_i+0x18c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:205
 8006440:	1d10      	adds	r0, r2, #4
 8006442:	6018      	str	r0, [r3, #0]
 8006444:	6813      	ldr	r3, [r2, #0]
 8006446:	e008      	b.n	800645a <_printf_i+0x19e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:206
 8006448:	f010 0f40 	tst.w	r0, #64	; 0x40
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:207
 800644c:	f102 0004 	add.w	r0, r2, #4
 8006450:	6018      	str	r0, [r3, #0]
 8006452:	6813      	ldr	r3, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:206
 8006454:	d001      	beq.n	800645a <_printf_i+0x19e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:207
 8006456:	8019      	strh	r1, [r3, #0]
 8006458:	e000      	b.n	800645c <_printf_i+0x1a0>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:209
 800645a:	6019      	str	r1, [r3, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:211
 800645c:	2300      	movs	r3, #0
 800645e:	6123      	str	r3, [r4, #16]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:117
 8006460:	4675      	mov	r5, lr
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:212
 8006462:	e016      	b.n	8006492 <_printf_i+0x1d6>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:214
 8006464:	681a      	ldr	r2, [r3, #0]
 8006466:	1d11      	adds	r1, r2, #4
 8006468:	6019      	str	r1, [r3, #0]
 800646a:	6815      	ldr	r5, [r2, #0]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:219
 800646c:	6862      	ldr	r2, [r4, #4]
 800646e:	2100      	movs	r1, #0
 8006470:	4628      	mov	r0, r5
 8006472:	f000 f84d 	bl	8006510 <memchr>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:221
 8006476:	b108      	cbz	r0, 800647c <_printf_i+0x1c0>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:222
 8006478:	1b40      	subs	r0, r0, r5
 800647a:	6060      	str	r0, [r4, #4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:224
 800647c:	6863      	ldr	r3, [r4, #4]
 800647e:	e004      	b.n	800648a <_printf_i+0x1ce>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:229
 8006480:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8006484:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:230
 8006488:	2301      	movs	r3, #1
 800648a:	6123      	str	r3, [r4, #16]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:232
 800648c:	2300      	movs	r3, #0
 800648e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:237
 8006492:	f8cd 8000 	str.w	r8, [sp]
 8006496:	463b      	mov	r3, r7
 8006498:	aa03      	add	r2, sp, #12
 800649a:	4621      	mov	r1, r4
 800649c:	4630      	mov	r0, r6
 800649e:	f7ff fe97 	bl	80061d0 <_printf_common>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:238
 80064a2:	3001      	adds	r0, #1
 80064a4:	d102      	bne.n	80064ac <_printf_i+0x1f0>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:248
 80064a6:	f04f 30ff 	mov.w	r0, #4294967295
 80064aa:	e026      	b.n	80064fa <_printf_i+0x23e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:241
 80064ac:	6923      	ldr	r3, [r4, #16]
 80064ae:	462a      	mov	r2, r5
 80064b0:	4639      	mov	r1, r7
 80064b2:	4630      	mov	r0, r6
 80064b4:	47c0      	blx	r8
 80064b6:	3001      	adds	r0, #1
 80064b8:	d0f5      	beq.n	80064a6 <_printf_i+0x1ea>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:243
 80064ba:	6823      	ldr	r3, [r4, #0]
 80064bc:	079b      	lsls	r3, r3, #30
 80064be:	d510      	bpl.n	80064e2 <_printf_i+0x226>
 80064c0:	2500      	movs	r5, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:244 (discriminator 3)
 80064c2:	f104 0919 	add.w	r9, r4, #25
 80064c6:	e007      	b.n	80064d8 <_printf_i+0x21c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:244 (discriminator 4)
 80064c8:	2301      	movs	r3, #1
 80064ca:	464a      	mov	r2, r9
 80064cc:	4639      	mov	r1, r7
 80064ce:	4630      	mov	r0, r6
 80064d0:	47c0      	blx	r8
 80064d2:	3001      	adds	r0, #1
 80064d4:	d0e7      	beq.n	80064a6 <_printf_i+0x1ea>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:244 (discriminator 2)
 80064d6:	3501      	adds	r5, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:244 (discriminator 3)
 80064d8:	68e3      	ldr	r3, [r4, #12]
 80064da:	9a03      	ldr	r2, [sp, #12]
 80064dc:	1a9b      	subs	r3, r3, r2
 80064de:	429d      	cmp	r5, r3
 80064e0:	dbf2      	blt.n	80064c8 <_printf_i+0x20c>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:246
 80064e2:	68e0      	ldr	r0, [r4, #12]
 80064e4:	9b03      	ldr	r3, [sp, #12]
 80064e6:	4298      	cmp	r0, r3
 80064e8:	bfb8      	it	lt
 80064ea:	4618      	movlt	r0, r3
 80064ec:	e005      	b.n	80064fa <_printf_i+0x23e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:191
 80064ee:	780b      	ldrb	r3, [r1, #0]
 80064f0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80064f4:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80064f8:	e78a      	b.n	8006410 <_printf_i+0x154>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdio/nano-vfprintf_i.c:249
 80064fa:	b005      	add	sp, #20
 80064fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006500:	0800723b 	.word	0x0800723b
 8006504:	0800724c 	.word	0x0800724c
	...

08006510 <memchr>:
memchr():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:110
 8006510:	f001 01ff 	and.w	r1, r1, #255	; 0xff
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:112
 8006514:	2a10      	cmp	r2, #16
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:113
 8006516:	db2b      	blt.n	8006570 <memchr+0x60>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:115
 8006518:	f010 0f07 	tst.w	r0, #7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:116
 800651c:	d008      	beq.n	8006530 <memchr+0x20>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:120
 800651e:	f810 3b01 	ldrb.w	r3, [r0], #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:121
 8006522:	3a01      	subs	r2, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:122
 8006524:	428b      	cmp	r3, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:123
 8006526:	d02d      	beq.n	8006584 <memchr+0x74>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:124
 8006528:	f010 0f07 	tst.w	r0, #7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:125
 800652c:	b342      	cbz	r2, 8006580 <memchr+0x70>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:126
 800652e:	d1f6      	bne.n	800651e <memchr+0xe>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:130
 8006530:	b4f0      	push	{r4, r5, r6, r7}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:131
 8006532:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:132
 8006536:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:133
 800653a:	f022 0407 	bic.w	r4, r2, #7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:134
 800653e:	f07f 0700 	mvns.w	r7, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:135
 8006542:	2300      	movs	r3, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:138
 8006544:	e8f0 5602 	ldrd	r5, r6, [r0], #8
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:139
 8006548:	3c08      	subs	r4, #8
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:140
 800654a:	ea85 0501 	eor.w	r5, r5, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:141
 800654e:	ea86 0601 	eor.w	r6, r6, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:142
 8006552:	fa85 f547 	uadd8	r5, r5, r7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:143
 8006556:	faa3 f587 	sel	r5, r3, r7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:145
 800655a:	fa86 f647 	uadd8	r6, r6, r7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:146
 800655e:	faa5 f687 	sel	r6, r5, r7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:148
 8006562:	b98e      	cbnz	r6, 8006588 <memchr+0x78>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:149
 8006564:	d1ee      	bne.n	8006544 <memchr+0x34>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:151
 8006566:	bcf0      	pop	{r4, r5, r6, r7}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:152
 8006568:	f001 01ff 	and.w	r1, r1, #255	; 0xff
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:153
 800656c:	f002 0207 	and.w	r2, r2, #7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:157
 8006570:	b132      	cbz	r2, 8006580 <memchr+0x70>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:160
 8006572:	f810 3b01 	ldrb.w	r3, [r0], #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:161
 8006576:	3a01      	subs	r2, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:162
 8006578:	ea83 0301 	eor.w	r3, r3, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:163
 800657c:	b113      	cbz	r3, 8006584 <memchr+0x74>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:164
 800657e:	d1f8      	bne.n	8006572 <memchr+0x62>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:167
 8006580:	2000      	movs	r0, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:168
 8006582:	4770      	bx	lr
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:171
 8006584:	3801      	subs	r0, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:172
 8006586:	4770      	bx	lr
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:178
 8006588:	2d00      	cmp	r5, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:179
 800658a:	bf06      	itte	eq
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:180
 800658c:	4635      	moveq	r5, r6
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:181
 800658e:	3803      	subeq	r0, #3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:182
 8006590:	3807      	subne	r0, #7
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:185
 8006592:	f015 0f01 	tst.w	r5, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:186
 8006596:	d107      	bne.n	80065a8 <memchr+0x98>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:187
 8006598:	3001      	adds	r0, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:188
 800659a:	f415 7f80 	tst.w	r5, #256	; 0x100
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:189
 800659e:	bf02      	ittt	eq
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:190
 80065a0:	3001      	addeq	r0, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:191
 80065a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:193
 80065a6:	3001      	addeq	r0, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:196
 80065a8:	bcf0      	pop	{r4, r5, r6, r7}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:197
 80065aa:	3801      	subs	r0, #1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/memchr.S:198
 80065ac:	4770      	bx	lr
 80065ae:	bf00      	nop

080065b0 <memcpy>:
memcpy():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/../../string/memcpy.c:58
 80065b0:	b510      	push	{r4, lr}
 80065b2:	1e43      	subs	r3, r0, #1
 80065b4:	440a      	add	r2, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/../../string/memcpy.c:65
 80065b6:	4291      	cmp	r1, r2
 80065b8:	d004      	beq.n	80065c4 <memcpy+0x14>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/../../string/memcpy.c:67
 80065ba:	f811 4b01 	ldrb.w	r4, [r1], #1
 80065be:	f803 4f01 	strb.w	r4, [r3, #1]!
 80065c2:	e7f8      	b.n	80065b6 <memcpy+0x6>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/machine/arm/../../string/memcpy.c:111
 80065c4:	bd10      	pop	{r4, pc}

080065c6 <memmove>:
memmove():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:69
 80065c6:	4288      	cmp	r0, r1
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:64
 80065c8:	b510      	push	{r4, lr}
 80065ca:	eb01 0302 	add.w	r3, r1, r2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:69
 80065ce:	d801      	bhi.n	80065d4 <memmove+0xe>
 80065d0:	1e42      	subs	r2, r0, #1
 80065d2:	e00b      	b.n	80065ec <memmove+0x26>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:69 (discriminator 1)
 80065d4:	4298      	cmp	r0, r3
 80065d6:	d2fb      	bcs.n	80065d0 <memmove+0xa>
 80065d8:	1881      	adds	r1, r0, r2
 80065da:	1ad2      	subs	r2, r2, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:74
 80065dc:	42d3      	cmn	r3, r2
 80065de:	d004      	beq.n	80065ea <memmove+0x24>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:76
 80065e0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80065e4:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80065e8:	e7f8      	b.n	80065dc <memmove+0x16>
 80065ea:	bd10      	pop	{r4, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:81
 80065ec:	4299      	cmp	r1, r3
 80065ee:	d004      	beq.n	80065fa <memmove+0x34>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:83
 80065f0:	f811 4b01 	ldrb.w	r4, [r1], #1
 80065f4:	f802 4f01 	strb.w	r4, [r2, #1]!
 80065f8:	e7f8      	b.n	80065ec <memmove+0x26>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/string/memmove.c:144
 80065fa:	bd10      	pop	{r4, pc}

080065fc <_realloc_r>:
_realloc_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:448
 80065fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80065fe:	4607      	mov	r7, r0
 8006600:	4615      	mov	r5, r2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:452
 8006602:	460e      	mov	r6, r1
 8006604:	b921      	cbnz	r1, 8006610 <_realloc_r+0x14>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:452 (discriminator 1)
 8006606:	4611      	mov	r1, r2
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:472 (discriminator 1)
 8006608:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:452 (discriminator 1)
 800660c:	f7ff bc0a 	b.w	8005e24 <_malloc_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:454
 8006610:	b91a      	cbnz	r2, 800661a <_realloc_r+0x1e>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:456
 8006612:	f7ff fbc1 	bl	8005d98 <_free_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:457
 8006616:	4628      	mov	r0, r5
 8006618:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:462
 800661a:	f000 f815 	bl	8006648 <_malloc_usable_size_r>
 800661e:	4285      	cmp	r5, r0
 8006620:	d90e      	bls.n	8006640 <_realloc_r+0x44>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:465
 8006622:	4629      	mov	r1, r5
 8006624:	4638      	mov	r0, r7
 8006626:	f7ff fbfd 	bl	8005e24 <_malloc_r>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:466
 800662a:	4604      	mov	r4, r0
 800662c:	b150      	cbz	r0, 8006644 <_realloc_r+0x48>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:468
 800662e:	4631      	mov	r1, r6
 8006630:	462a      	mov	r2, r5
 8006632:	f7ff ffbd 	bl	80065b0 <memcpy>
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:469
 8006636:	4631      	mov	r1, r6
 8006638:	4638      	mov	r0, r7
 800663a:	f7ff fbad 	bl	8005d98 <_free_r>
 800663e:	e001      	b.n	8006644 <_realloc_r+0x48>
 8006640:	4630      	mov	r0, r6
 8006642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006644:	4620      	mov	r0, r4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:472
 8006646:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006648 <_malloc_usable_size_r>:
_malloc_usable_size_r():
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:526
 8006648:	f851 0c04 	ldr.w	r0, [r1, #-4]
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:528
 800664c:	2800      	cmp	r0, #0
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:532
 800664e:	bfbe      	ittt	lt
 8006650:	1809      	addlt	r1, r1, r0
 8006652:	f851 3c04 	ldrlt.w	r3, [r1, #-4]
 8006656:	18c0      	addlt	r0, r0, r3
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:534
 8006658:	3804      	subs	r0, #4
/home/freddie/bleeding-edge-toolchain/src/newlib-cygwin/newlib/libc/stdlib/nano-mallocr.c:535
 800665a:	4770      	bx	lr
 800665c:	732f2e2e 	.word	0x732f2e2e
 8006660:	65747379 	.word	0x65747379
 8006664:	72732f6d 	.word	0x72732f6d
 8006668:	74732f63 	.word	0x74732f63
 800666c:	6632336d 	.word	0x6632336d
 8006670:	61682d34 	.word	0x61682d34
 8006674:	74732f6c 	.word	0x74732f6c
 8006678:	6632336d 	.word	0x6632336d
 800667c:	5f787834 	.word	0x5f787834
 8006680:	5f6c6168 	.word	0x5f6c6168
 8006684:	2e6e6163 	.word	0x2e6e6163
 8006688:	00000063 	.word	0x00000063
 800668c:	732f2e2e 	.word	0x732f2e2e
 8006690:	65747379 	.word	0x65747379
 8006694:	72732f6d 	.word	0x72732f6d
 8006698:	74732f63 	.word	0x74732f63
 800669c:	6632336d 	.word	0x6632336d
 80066a0:	61682d34 	.word	0x61682d34
 80066a4:	74732f6c 	.word	0x74732f6c
 80066a8:	6632336d 	.word	0x6632336d
 80066ac:	5f787834 	.word	0x5f787834
 80066b0:	5f6c6168 	.word	0x5f6c6168
 80066b4:	74726f63 	.word	0x74726f63
 80066b8:	632e7865 	.word	0x632e7865
 80066bc:	00000000 	.word	0x00000000
 80066c0:	732f2e2e 	.word	0x732f2e2e
 80066c4:	65747379 	.word	0x65747379
 80066c8:	72732f6d 	.word	0x72732f6d
 80066cc:	74732f63 	.word	0x74732f63
 80066d0:	6632336d 	.word	0x6632336d
 80066d4:	61682d34 	.word	0x61682d34
 80066d8:	74732f6c 	.word	0x74732f6c
 80066dc:	6632336d 	.word	0x6632336d
 80066e0:	5f787834 	.word	0x5f787834
 80066e4:	5f6c6168 	.word	0x5f6c6168
 80066e8:	6f697067 	.word	0x6f697067
 80066ec:	0000632e 	.word	0x0000632e

080066f0 <APBAHBPrescTable>:
 80066f0:	00000000 04030201 04030201 09080706     ................
 8006700:	732f2e2e 65747379 72732f6d 74732f63     ../system/src/st
 8006710:	6632336d 61682d34 74732f6c 6632336d     m32f4-hal/stm32f
 8006720:	5f787834 5f6c6168 2e636372 00000063     4xx_hal_rcc.c...
 8006730:	732f2e2e 65747379 72732f6d 74732f63     ../system/src/st
 8006740:	6632336d 61682d34 74732f6c 6632336d     m32f4-hal/stm32f
 8006750:	5f787834 5f6c6168 2e697073 00000063     4xx_hal_spi.c...
 8006760:	732f2e2e 65747379 72732f6d 74732f63     ../system/src/st
 8006770:	6632336d 61682d34 74732f6c 6632336d     m32f4-hal/stm32f
 8006780:	5f787834 5f6c6168 2e6d6974 00000063     4xx_hal_tim.c...

08006790 <AHBPrescTable>:
	...
 8006798:	04030201 09080706 003a4453 253b7525     ........SD:.%u;%
 80067a8:	00000a64 743a4453 7571726f 7a5f3165     d...SD:torque1_z
 80067b8:	632e7375 00007673 743a4453 7571726f     us.csv..SD:torqu
 80067c8:	7a5f3365 632e7375 00007673 673a4453     e3_zus.csv..SD:g
 80067d8:	68637365 646e6977 656b6769 725f7469     eschwindigkeit_r
 80067e8:	7a5f6461 632e7375 00007673 673a4453     ad_zus.csv..SD:g
 80067f8:	68637365 646e6977 656b6769 615f7469     eschwindigkeit_a
 8006808:	5f6f7475 2e73757a 00767363              uto_zus.csv.

08006814 <GPIO_PIN>:
 8006814:	20001000 80004000                       ... .@..

0800681c <ExCvt>:
 800681c:	41455543 43414141 49454545 41414949     CUEAAAACEEEIIIAA
 800682c:	4f929245 55554f4f 4f554f59 9f9e4f9c     E..OOOUUYOUO.O..
 800683c:	554f4941 a7a6a5a5 abaaa9a8 afaeadac     AIOU............
 800684c:	b3b2b1b0 414141b4 bbbab9b8 bfbebdbc     .....AAA........
 800685c:	c3c2c1c0 4141c5c4 cbcac9c8 cfcecdcc     ......AA........
 800686c:	4545d1d1 49494945 dbdad949 df49dddc     ..EEEIIII.....I.
 800687c:	4f4fe14f e8e64f4f 555555e8 efee5959     O.OOOO...UUUYY..
 800688c:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................
 800689c:	3c3a2a22 7f7c3f3e 00000000 3d3b2c2b     "*:<>?|.....+,;=
 80068ac:	00005d5b 2c2b2a22 3c3b3a2e 5b3f3e3d     [].."*+,.:;<=>?[
 80068bc:	007f7c5d 4d90feeb 534f4453 00302e35     ]|.....MSDOS5.0.
 80068cc:	4e204f4e 20454d41 46202020 32335441     NO NAME    FAT32
 80068dc:	00202020 4e204f4e 20454d41 46202020        .NO NAME    F
 80068ec:	20205441 00202020 00004453 46425355     AT     .SD..USBF
 80068fc:	00000053 48425355 00000053 41524453     S...USBHS...SDRA
 800690c:	0000004d 46495053 4853414c 00000000     M...SPIFLASH....
 800691c:	31554652 00000000 32554652 00000000     RFU1....RFU2....
 800692c:	52455355 00000031 52455355 00000032     USER1...USER2...

0800693c <LfnOfs>:
 800693c:	07050301 12100e09 1c181614 0000001e     ................

0800694c <str.4426>:
 800694c:	080068f4 080068f8 08006900 08006908     .h...h...i...i..
 800695c:	08006910 0800691c 08006924 0800692c     .i...i..$i..,i..
 800696c:	08006934                                4i..

08006970 <lower.3901>:
 8006970:	00e100e0 00e300e2 00e500e4 00e700e6     ................
 8006980:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
 8006990:	00f100f0 00f300f2 00f500f4 00f800f6     ................
 80069a0:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
 80069b0:	01050103 01090107 010d010b 0111010f     ................
 80069c0:	01150113 01190117 011d011b 0121011f     ..............!.
 80069d0:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
 80069e0:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
 80069f0:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
 8006a00:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
 8006a10:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
 8006a20:	01770175 017c017a 0183017e 01880185     u.w.z.|.~.......
 8006a30:	0192018c 01a10199 01a801a3 01b001ad     ................
 8006a40:	01b601b4 01bd01b9 01c901c6 01ce01cc     ................
 8006a50:	01d201d0 01d601d4 01da01d8 01dd01dc     ................
 8006a60:	01e101df 01e501e3 01e901e7 01ed01eb     ................
 8006a70:	01f301ef 01fb01f5 01ff01fd 02030201     ................
 8006a80:	02070205 020b0209 020f020d 02130211     ................
 8006a90:	02170215 03b203b1 03b403b3 03b603b5     ................
 8006aa0:	03b803b7 03ba03b9 03bc03bb 03be03bd     ................
 8006ab0:	03c003bf 03c303c1 03c503c4 03c703c6     ................
 8006ac0:	03c903c8 03cb03ca 03cd03cc 03e303ce     ................
 8006ad0:	03e703e5 03eb03e9 04310430 04330432     ........0.1.2.3.
 8006ae0:	04350434 04370436 04390438 043b043a     4.5.6.7.8.9.:.;.
 8006af0:	043d043c 043f043e 04410440 04430442     <.=.>.?.@.A.B.C.
 8006b00:	04450444 04470446 04490448 044b044a     D.E.F.G.H.I.J.K.
 8006b10:	044d044c 044f044e 04530452 04550454     L.M.N.O.R.S.T.U.
 8006b20:	04570456 04590458 045b045a 045e045c     V.W.X.Y.Z.[.\.^.
 8006b30:	0461045f 04650463 04690467 046d046b     _.a.c.e.g.i.k.m.
 8006b40:	0471046f 04750473 04790477 047d047b     o.q.s.u.w.y.{.}.
 8006b50:	0481047f 04930491 04970495 049b0499     ................
 8006b60:	049f049d 04a304a1 04a704a5 04ab04a9     ................
 8006b70:	04af04ad 04b304b1 04b704b5 04bb04b9     ................
 8006b80:	04bf04bd 04c404c2 04d104c8 04d504d3     ................
 8006b90:	04d904d7 04dd04db 04e104df 04e504e3     ................
 8006ba0:	04e904e7 04ed04eb 04f104ef 04f504f3     ................
 8006bb0:	056104f9 05630562 05650564 05670566     ..a.b.c.d.e.f.g.
 8006bc0:	05690568 056b056a 056d056c 056f056e     h.i.j.k.l.m.n.o.
 8006bd0:	05710570 05730572 05750574 05770576     p.q.r.s.t.u.v.w.
 8006be0:	05790578 057b057a 057d057c 057f057e     x.y.z.{.|.}.~...
 8006bf0:	05810580 05830582 05850584 1e010586     ................
 8006c00:	1e051e03 1e091e07 1e0d1e0b 1e111e0f     ................
 8006c10:	1e151e13 1e191e17 1e1d1e1b 1e211e1f     ..............!.
 8006c20:	1e251e23 1e291e27 1e2d1e2b 1e311e2f     #.%.'.).+.-./.1.
 8006c30:	1e351e33 1e391e37 1e3d1e3b 1e411e3f     3.5.7.9.;.=.?.A.
 8006c40:	1e451e43 1e491e47 1e4d1e4b 1e511e4f     C.E.G.I.K.M.O.Q.
 8006c50:	1e551e53 1e591e57 1e5d1e5b 1e611e5f     S.U.W.Y.[.]._.a.
 8006c60:	1e651e63 1e691e67 1e6d1e6b 1e711e6f     c.e.g.i.k.m.o.q.
 8006c70:	1e751e73 1e791e77 1e7d1e7b 1e811e7f     s.u.w.y.{.}.....
 8006c80:	1e851e83 1e891e87 1e8d1e8b 1e911e8f     ................
 8006c90:	1e951e93 1e991e97 1e9d1e9b 1ea11e9f     ................
 8006ca0:	1ea51ea3 1ea91ea7 1ead1eab 1eb11eaf     ................
 8006cb0:	1eb51eb3 1eb91eb7 1ebd1ebb 1ec11ebf     ................
 8006cc0:	1ec51ec3 1ec91ec7 1ecd1ecb 1ed11ecf     ................
 8006cd0:	1ed51ed3 1ed91ed7 1edd1edb 1ee11edf     ................
 8006ce0:	1ee51ee3 1ee91ee7 1eed1eeb 1ef11eef     ................
 8006cf0:	1ef51ef3 1ef91ef7 21712170 21732172     ........p!q!r!s!
 8006d00:	21752174 21772176 21792178 217b217a     t!u!v!w!x!y!z!{!
 8006d10:	217d217c 217f217e ff42ff41 ff44ff43     |!}!~!.!A.B.C.D.
 8006d20:	ff46ff45 ff48ff47 ff4aff49 ff4cff4b     E.F.G.H.I.J.K.L.
 8006d30:	ff4eff4d ff50ff4f ff52ff51 ff54ff53     M.N.O.P.Q.R.S.T.
 8006d40:	ff56ff55 ff58ff57 ff5aff59              U.V.W.X.Y.Z.

08006d4c <Tbl>:
 8006d4c:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
 8006d5c:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
 8006d6c:	00e600c9 00f400c6 00f200f6 00f900fb     ................
 8006d7c:	00d600ff 00f800dc 00d800a3 019200d7     ................
 8006d8c:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
 8006d9c:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
 8006dac:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
 8006dbc:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
 8006dcc:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
 8006ddc:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
 8006dec:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
 8006dfc:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
 8006e0c:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
 8006e1c:	00da00de 00d900db 00dd00fd 00b400af     ................
 8006e2c:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
 8006e3c:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

08006e4c <upper.3902>:
 8006e4c:	00c100c0 00c300c2 00c500c4 00c700c6     ................
 8006e5c:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
 8006e6c:	00d100d0 00d300d2 00d500d4 00d800d6     ................
 8006e7c:	00da00d9 00dc00db 00de00dd 01000178     ............x...
 8006e8c:	01040102 01080106 010c010a 0110010e     ................
 8006e9c:	01140112 01180116 011c011a 0120011e     .............. .
 8006eac:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
 8006ebc:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
 8006ecc:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
 8006edc:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
 8006eec:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
 8006efc:	01760174 017b0179 0182017d 01870184     t.v.y.{.}.......
 8006f0c:	0191018b 01a00198 01a701a2 01af01ac     ................
 8006f1c:	01b501b3 01bc01b8 01c701c4 01cd01ca     ................
 8006f2c:	01d101cf 01d501d3 01d901d7 018e01db     ................
 8006f3c:	01e001de 01e401e2 01e801e6 01ec01ea     ................
 8006f4c:	01f101ee 01fa01f4 01fe01fc 02020200     ................
 8006f5c:	02060204 020a0208 020e020c 02120210     ................
 8006f6c:	02160214 03920391 03940393 03960395     ................
 8006f7c:	03980397 039a0399 039c039b 039e039d     ................
 8006f8c:	03a0039f 03a303a1 03a503a4 03a703a6     ................
 8006f9c:	03a903a8 03ab03aa 038e038c 03e2038f     ................
 8006fac:	03e603e4 03ea03e8 04110410 04130412     ................
 8006fbc:	04150414 04170416 04190418 041b041a     ................
 8006fcc:	041d041c 041f041e 04210420 04230422     ........ .!.".#.
 8006fdc:	04250424 04270426 04290428 042b042a     $.%.&.'.(.).*.+.
 8006fec:	042d042c 042f042e 04030402 04050404     ,.-.../.........
 8006ffc:	04070406 04090408 040b040a 040e040c     ................
 800700c:	0460040f 04640462 04680466 046c046a     ..`.b.d.f.h.j.l.
 800701c:	0470046e 04740472 04780476 047c047a     n.p.r.t.v.x.z.|.
 800702c:	0480047e 04920490 04960494 049a0498     ~...............
 800703c:	049e049c 04a204a0 04a604a4 04aa04a8     ................
 800704c:	04ae04ac 04b204b0 04b604b4 04ba04b8     ................
 800705c:	04be04bc 04c304c1 04d005c7 04d404d2     ................
 800706c:	04d804d6 04dc04da 04e004de 04e404e2     ................
 800707c:	04e804e6 04ec04ea 04f004ee 04f404f2     ................
 800708c:	053104f8 05330532 05350534 05370536     ..1.2.3.4.5.6.7.
 800709c:	05390538 053b053a 053d053c 053f053e     8.9.:.;.<.=.>.?.
 80070ac:	05410540 05430542 05450544 05470546     @.A.B.C.D.E.F.G.
 80070bc:	05490548 054b054a 054d054c 054f054e     H.I.J.K.L.M.N.O.
 80070cc:	05510550 05530552 05550554 1e000556     P.Q.R.S.T.U.V...
 80070dc:	1e041e02 1e081e06 1e0c1e0a 1e101e0e     ................
 80070ec:	1e141e12 1e181e16 1e1c1e1a 1e201e1e     .............. .
 80070fc:	1e241e22 1e281e26 1e2c1e2a 1e301e2e     ".$.&.(.*.,...0.
 800710c:	1e341e32 1e381e36 1e3c1e3a 1e401e3e     2.4.6.8.:.<.>.@.
 800711c:	1e441e42 1e481e46 1e4c1e4a 1e501e4e     B.D.F.H.J.L.N.P.
 800712c:	1e541e52 1e581e56 1e5c1e5a 1e601e5e     R.T.V.X.Z.\.^.`.
 800713c:	1e641e62 1e681e66 1e6c1e6a 1e701e6e     b.d.f.h.j.l.n.p.
 800714c:	1e741e72 1e781e76 1e7c1e7a 1e801e7e     r.t.v.x.z.|.~...
 800715c:	1e841e82 1e881e86 1e8c1e8a 1e901e8e     ................
 800716c:	1e941e92 1e981e96 1e9c1e9a 1ea01e9e     ................
 800717c:	1ea41ea2 1ea81ea6 1eac1eaa 1eb01eae     ................
 800718c:	1eb41eb2 1eb81eb6 1ebc1eba 1ec01ebe     ................
 800719c:	1ec41ec2 1ec81ec6 1ecc1eca 1ed01ece     ................
 80071ac:	1ed41ed2 1ed81ed6 1edc1eda 1ee01ede     ................
 80071bc:	1ee41ee2 1ee81ee6 1eec1eea 1ef01eee     ................
 80071cc:	1ef41ef2 1ef81ef6 21612160 21632162     ........`!a!b!c!
 80071dc:	21652164 21672166 21692168 216b216a     d!e!f!g!h!i!j!k!
 80071ec:	216d216c 216f216e ff22ff21 ff24ff23     l!m!n!o!!.".#.$.
 80071fc:	ff26ff25 ff28ff27 ff2aff29 ff2cff2b     %.&.'.(.).*.+.,.
 800720c:	ff2eff2d ff30ff2f ff32ff31 ff34ff33     -.../.0.1.2.3.4.
 800721c:	ff36ff35 ff38ff37 ff3aff39 2d230043     5.6.7.8.9.:.C.#-
 800722c:	00202b30 004c6c68 45676665 30004746     0+ .hlL.efgEFG.0
 800723c:	34333231 38373635 43424139 00464544     123456789ABCDEF.
 800724c:	33323130 37363534 62613938 66656463     0123456789abcdef
	...
